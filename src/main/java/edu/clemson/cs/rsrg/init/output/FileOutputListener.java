/*
 * FileOutputListener.java
 * ---------------------------------
 * Copyright (c) 2017
 * RESOLVE Software Research Group
 * School of Computing
 * Clemson University
 * All rights reserved.
 * ---------------------------------
 * This file is subject to the terms and conditions defined in
 * file 'LICENSE.txt', which is part of this source code package.
 */
package edu.clemson.cs.rsrg.init.output;

import edu.clemson.cs.r2jt.rewriteprover.Metrics;
import edu.clemson.cs.r2jt.rewriteprover.model.PerVCProverModel;
import edu.clemson.cs.rsrg.astoutput.GenerateGraphvizModel;
import edu.clemson.cs.rsrg.init.file.ResolveFile;
import edu.clemson.cs.rsrg.parsing.data.Location;
import edu.clemson.cs.rsrg.statushandling.StatusHandler;
import edu.clemson.cs.rsrg.vcgeneration.VCGenerator;
import edu.clemson.cs.rsrg.vcgeneration.vcs.AssertiveCodeBlock;
import edu.clemson.cs.rsrg.vcgeneration.vcs.Sequent;
import java.io.*;
import java.util.Date;
import java.util.List;
import java.util.Map;
import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;
import org.stringtemplate.v4.STGroupFile;

/**
 * <p>A listener that contains methods for retrieving compilation
 * results from the compiler and outputs them to different files.</p>
 *
 * @author Yu-Shan Sun
 * @version 1.0
 */
public class FileOutputListener implements OutputListener {

    // ===========================================================
    // Member Fields
    // ===========================================================

    /** <p>This is the status handler for the RESOLVE compiler.</p> */
    private final StatusHandler myStatusHandler;

    // ===========================================================
    // Constructors
    // ===========================================================

    /**
     * <p>This constructs a output listener to different
     * {@link File Files}.</p>
     *
     * @param handler The status handler for the RESOLVE compiler.
     */
    public FileOutputListener(StatusHandler handler) {
        myStatusHandler = handler;
    }

    // ===========================================================
    // Public Methods
    // ===========================================================

    /**
     * <p>This method outputs the provided {@code Graphviz} model generated
     * from the {@link GenerateGraphvizModel}.</p>
     *
     * @param outputFileName A name for the output file.
     * @param graphvizModel The inner {@code AST} represented in a {@code GraphViz}
     *                      file format.
     */
    @Override
    public final void astGraphvizModelResult(String outputFileName,
            String graphvizModel) {
        writeToFile(outputFileName + "_ModuleDec.gv", graphvizModel);
    }

    /**
     * <p>This method outputs the provided the java translation results
     * from the {@code JavaTranslator}.</p>
     *
     * @param inputFileName Name of the {@link ResolveFile} we are generating {@code Java} translations.
     * @param outputFileName A name for the output file.
     * @param javaTranslation The translated {@code Java} source code.
     */
    @Override
    public final void javaTranslationResult(String inputFileName,
            String outputFileName, String javaTranslation) {
        throw new UnsupportedOperationException("Needs to be implemented!");
    }

    /**
     * <p>This method outputs the provided results
     * from the {@code CCProver}.</p>
     *
     * @param inputFileName Name of the {@link ResolveFile} we are generating proofs.
     * @param outputFileName A name for the output file.
     */
    @Override
    public final void proverResult(String inputFileName, String outputFileName) {
        throw new UnsupportedOperationException("Needs to be implemented!");
    }

    /**
     * <p>This method outputs the provided {@link AssertiveCodeBlock AssertiveCodeBlocks}
     * and/or raw output result from the {@link VCGenerator}.</p>
     *
     * @param inputFileName Name of the {@link ResolveFile} we are generating VCs for.
     * @param outputFileName A name for the output file.
     * @param blocks A list of final {@link AssertiveCodeBlock AssertiveCodeBlocks}.
     * @param locationDetails A map containing details about encountered {@link Location Locations}.
     * @param verboseOutput The verbose output string generated by the {@link VCGenerator}.
     */
    @Override
    public final void vcGeneratorResult(String inputFileName,
            String outputFileName, List<AssertiveCodeBlock> blocks,
            Map<Location, String> locationDetails, String verboseOutput) {
        StringBuffer sb = new StringBuffer();

        // String template to hold the VC generation details
        STGroup group = new STGroupFile("templates/VCGenOutput.stg");
        ST model =
                group.getInstanceOf("outputVCGenFile").add("fileName",
                        inputFileName).add("dateGenerated", new Date());

        // Add the VC output in human readable format
        int blockCount = 0;
        for (AssertiveCodeBlock block : blocks) {
            // Obtain the final list of sequents
            int vcCount = 1;
            List<Sequent> sequents = block.getSequents();
            for (Sequent s : sequents) {
                // Create a model for adding all the details
                // associated with this VC.
                Location loc = s.getLocation();
                ST vcModel = group.getInstanceOf("outputVC");
                vcModel.add("vcNum", blockCount + "_" + vcCount);
                vcModel.add("location", loc);
                vcModel.add("locationDetail", locationDetails.get(loc));
                vcModel.add("consequents", s.getConcequents());
                vcModel.add("antecedents", s.getAntecedents());

                // Add the VC to the model and increase the vcCount
                model.add("vcs", vcModel.render());
                vcCount++;
            }

            // Increase the block number
            blockCount++;
        }

        // Append the generated VC details from the model
        sb.append(model.render());

        // Append VC details with any verbose output
        sb.append(verboseOutput);

        // Output the results to file
        writeToFile(outputFileName + ".asrt", sb.toString());
    }

    /**
     * <p>This method outputs the prover results for a given {@code VC}.</p>
     *
     * @param proved {@code true} if the {@code VC} was proved,
     *               {@code false} otherwise.
     * @param finalModel The prover representation for a {@code VC}.
     * @param m The prover generated metrics.
     */
    @Override
    public final void vcResult(boolean proved, PerVCProverModel finalModel,
            Metrics m) {
        throw new UnsupportedOperationException("Needs to be implemented!");
    }

    // ===========================================================
    // Private Methods
    // ===========================================================

    /**
     * <p>Writes the content to the specified filename.</p>
     *
     * @param outputFileName Output filename.
     * @param outputString Contents to be written in file.
     */
    private void writeToFile(String outputFileName, String outputString) {
        try {
            // Write the contents to file
            Writer writer =
                    new BufferedWriter(new FileWriter(new File(outputFileName),
                            false));
            writer.write(outputString);
            writer.close();
        }
        catch (IOException ioe) {
            myStatusHandler.error(null, "Error while writing to file: "
                    + outputFileName);
        }
    }
}