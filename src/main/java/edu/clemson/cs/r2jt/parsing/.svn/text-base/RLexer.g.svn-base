lexer grammar RLexer;

options {
    language=Java;
}

@header {
    package edu.clemson.cs.r2jt.parsing;
    //import org.antlr.*;
    }

ABS
  : 'abs'
  ;
  
AD
  : 'ad'
  ;
  
ABSURDUM
  : 'absurdum'
  ;
  
ALL
  : 'all'
  ;
  
ALTERS
  : 'alt' | 'alters'
  ;
  
ALTERNATIVE
  : 'alternative' 
  ;
  
AND
  : 'and'
  ;
  
ARRAY
  : 'Array'
  ;
  
ASSUME
  : 'assume'
  ;
  
AUX_CODE
  : 'Aux_Code'
  ;
  
AUX_VAR
  : 'Aux_Var'
  ;
  
AUX_VARS
  : 'Aux_Vars'
  ;
  
AUXILIARY
  : 'Aux' | 'Auxiliary'
  ;
  
AXIOM
  : 'Axiom'
  ;
  
BOOLEAN
  : 'B' | 'false' | 'true'
  ;
  
BASECASE
  : 'Base_Case'
  ;
  
BY
  : 'By' | 'by'
  ;
  
CARTPROD
  : 'Cart_Prod'
  ;
  
CATEGORICAL
  : 'Categorical'
  ;
  
CASE
  : 'Case'
  ;
    
CHANGING
  : 'changing'
  ;
  
CLEARS
  : 'clr' | 'clears'
  ;
  
COMMON
  : 'common'
  ;
  
CONCLUSION
  : 'conclusion'
  ;
  
COMMUTATIVITY
  : 'Commutativity'
  ;
  
COMPLEMENT
  : 'complement'
  ;
  
CONCEPT
  : 'concept'
  ;
  
MODULE_CONCEPT
  : 'Concept'
  ;
  
CONFIRM
  : 'Confirm'
  ;
  
CONJUNCT
  : 'conjunct'
  ;
  
CONSTRAINT
  : 'Constraint' | 'Constraints' | 'constraint' | 'constraints'
  ;
  
CONTRADICTION
  : 'contradiction'
  ;
  
CONVENTION
  : 'Convention' | 'Conventions' | 'convention' | 'conventions'
  ;
  
COROLLARY
  : 'Corollary'
  ;
  
CORR
  : 'Correspondence' | 'correspondence'
  ;
  
DECREASING
  : 'decreasing'
  ;
  
DEDUCTION
  : 'Deduction'
  ;
  
DEFINES
  : 'Defines' | 'defines'
  ;
  
DEFINITION
  : 'Def' | 'def' | 'Definition' | 'definition'
  ;
  
DISTRIBUTION
  : 'distribution'
  ;
  
DIV
  : 'div'
  ;
  
DO
  : 'do'
  ;
  
DURATION
  : 'duration'
  ;
  
ELAPSED_TIME
  : 'elapsed_time'
  ;
  
ELSE
  : 'else'
  ;
  
ELIMINATION
  : 'elimination'
  ;
  
END
  : 'end'
  ;
  
ENHANCED
  : 'enhanced'
  ;
  
ENHANCEMENT
  : 'enhancement'
  ;
  
MODULE_ENHANCEMENT
  : 'Enhancement'
  ;
  
ENSURES
  : 'ensures'
  ;
  
EQUALITY
  : 'equality'
  ;
  
EVALUATES
  : 'eval' | 'evaluates'
  ;
  
EXCLUDED
  : 'excluded'
  ;
  
EXEMPLAR
  : 'exemplar'
  ;
  
EXISTENTIAL
  : 'existantial'
  ;
  
EXISTS
  : 'exists'
  ;
  
EXIT
  : 'exit'
  ;
  
FACILITY
  : 'Facility'
  ;
  
FAC_FINAL
  : 'Facility_Finalization'
  ;
  
FAC_INIT
  : 'Facility_Initialization'
  ;
  
FAMILY
  : 'Family'
  ;
  
FINALIZATION
  : 'finalization'
  ;
  
FROM
  : 'from'
  ;
  
FOR
  : 'For' | 'for'
  ;
  
FORGET
  : 'Forget'
  ;
  
GENERALIZATION
  : 'generalization'
  ;
  
IF
  : 'If' | 'if'
  ;
  
IFF
  : 'iff'
  ;
  
IMPLICIT
  : 'Inplicit'
  ;
  
IMPLIES
  : 'implies'
  ;
  
INDUCTIVE
  : 'Inductive'
  ;
  
INDUCTIVECASE
  : 'Inductive_case'
  ;
  
INITIALIZATION
  : 'initialization'
  ;
  
INSTANTIATION
  : 'instantiation'
  ;
  
INTERSECT
  : 'intersect'
  ;
  
INTRODUCES
  : 'introduces'
  ;
  
IS
  : 'is'
  ;
  
IN
  : 'is_in'
  ;
  
NOT_IN
  : 'is_not_in'
  ;
  
NOT_PROP_SUBSET
  : 'is_not_proper_subset_of'
  ;
  
NOT_SUBSET
  : 'is_not_subset_of'
  ;
  
NOT_SUBSTR
  : 'is_not_substring_of'
  ;
  
PROP_SUBSET
  : 'is_proper_subset_of'
  ;
  
SUBSET
  : 'is_subset_of'
  ;
  
SUBSTR
  : 'is_substring_of'
  ;
  
ITERATE
  : 'Iterate'
  ;
  
LAMBDA
  : 'lambda'
  ;
  
LEMMA
  : 'Lemma'
  ;
  
LOCAL
  : 'Local'
  ;
  
MAINP_DISP
  : 'mainp_disp'
  ;
  
MAINTAINING
  : 'maintaining'
  ;
  
MATH
  : 'Math'
  ;
  
MIDDLE
  : 'middle'
  ;
  
MOD
  : 'mod'
  ;
  
MODELED
  : 'modeled'
  ;
  
MODUS
  : 'modus'
  ;
  
NOT
  : 'not'
  ;
  
CAT
  : 'o'
  ;
  
OF
  : 'of'
  ;
  
OPERATION
  : 'oper' | 'operation' | 'Oper' | 'Operation'
  ;
  
OR
  : 'or'
  ;
  
OTHERWISE
  : 'otherwise'
  ;
  
PERF_FINAL
  : 'perf_finalization'
  ;
  
PERF_INIT
  : 'perf_initialization'
  ;
  
PONENS
  : 'ponens'
  ;
  
//POWERSET
//  : 'Powerset' | 'powerset'
//  ;
  
PRESERVES
  : 'preserves' | 'pres'
  ;
  
PROCEDURE
  : 'Procedure' | 'Proc'
  ;
  
MODULE_PROFILE
  : 'Profile' | 'profile'
  ;
  
PROOF
  : 'Proof' | 'proof'
  ;
  
PROOFS_FOR
  : 'Proofs_for'
  ;
  
PROPERTY
  : 'Property' | 'Pty'
  ;
  
QED
  : 'QED'
  ;
  
QUANTIFIER
  : 'quantifier'
  ;
  
REALIZATION
  : 'realization'
  ;
  
MODULE_REALIZATION
  : 'Realization'
  ;
  
REALIZED
  : 'realized'
  ;
  
REASSIGNS
  : 'reassigns' | 'res'
  ;
  
RECORD
  : 'Record'
  ;
  
RECURSIVE
  : 'Recursive' | 'recursive'
  ;
  
REDUCTIO
  : 'reductio'
  ;
  
RELATED
  : 'related'
  ;
  
REM
  : 'rem'
  ;
  
REMEMBER
  : 'Remember'
  ;
  
REPEAT
  : 'repeat'
  ;
  
REPLACES
  : 'replaces' | 'rpl'
  ;
  
REPRESENTED
  : 'represented'
  ;
  
REQUIRES
  : 'requires'
  ;
  
RESPECTS
  : 'respects'
  ;
  
RESTORES
  : 'restores' | 'rest'
  ;
  
RULE
  : 'rule'
  ;
  
SELF
  : 'self'
  ;
  
SHORT_FOR
  : 'short_for'
  ;
  
STATIC
  : 'Static'
  ;
  
SUBTYPE
  : 'Subtype'
  ;
  
SUCH
  : 'such'
  ;
  
SUPPOSITION
  : 'Supposition'
  ;
  
THAT
  : 'that'
  ;
  
THEN
  : 'then'
  ;
  
THEOREM
  : 'Theorem'
  ;
  
THEORY
  : 'Theory' | 'Precis'
  ;
  
THERE
  : 'There' | 'there'
  ;
  
TIMES
  : 'times'
  ;
  
TYPE
  : 'Type' | 'type'
  ;
  
TYPE_FAMILY
  : 'Type_Family'
  ;
  
UNION
  : 'union'
  ;
  
UNIQUE
  : 'Unique' | 'unique'
  ;
  
UNIT
  : 'Unit' | 'unit'
  ;
  
UNIVERSAL
  : 'universal'
  ;
  
UPDATES
  : 'updates' | 'upd'
  ;
  
USES
  : 'uses'
  ;
  
VAR
  : 'Variable' | 'Var'
  ;
  
VARIABLES
  : 'Variables' | 'Vars'
  ;
  
WHEN
  : 'when'
  ;
  
WHERE
  : 'where'
  ;
  
WHILE
  : 'While'
  ;
  
WITHOUT
  : 'without'
  ;
  
WITH_PROFILE
  : 'with_profile'
  ;
  
IDENTIFIER
  : LETTER (ALPHABETIC)*
  ;


// ---------------------------------------------------------------
// White Space
// ---------------------------------------------------------------

WS
    : ( ' ' | '\t' | '\f' |
          ( ('\r\n') => '\r\n' | '\r' | '\n' ) {  }
      ) { $channel=HIDDEN; }
    ;

// ---------------------------------------------------------------
// Comments
// ---------------------------------------------------------------

SL_COMMENT
    :  '--' (~'\n')* '\n' { $channel=HIDDEN;  }
    ;

ML_COMMENT
    : '(*' (options {greedy=false;} : .)* '*)' {$channel=HIDDEN;}
    ;

fragment ALPHABETIC 
    : LETTER | '_' | DIGIT 
    ;

fragment LETTER
    : ('a'..'z'|'A'..'Z')
    ;

fragment DIGIT
    : '0'..'9'
    ;

fragment DIGITS
    : ('0'..'9')+
    ;

fragment REAL
    : DIGITS DOT DIGITS
    ;

NUMERIC_LITERAL
  /*@init { paraphrase.push("a numeric literal"); }
    options {
        paraphrase = "a numeric literal";
    }*/
    : ( DIGITS '..' ) => DIGITS
    | ( DIGITS '.' ~'.' ) => REAL
    | DIGITS
    ;

CHARACTER_LITERAL
  /*@init { paraphrase.push("a character"); }
    options {
        paraphrase = "a character";
    }*/
    : '\'' (ESC | ~'\'') '\''
    ;

// ---------------------------------------------------------------
// Punctuation Tokens
// ---------------------------------------------------------------

DOT        : '.' ;
COMMA      : ',' ;
LPAREN     : '(' ;
RPAREN     : ')' ;
LBRACE     : '{' ;
RBRACE     : '}' ;
DBL_LBRACE : '{{' ;
DBL_RBRACE : '}}' ;
LSQBRACK   : '[' ;
RSQBRACK   : ']' ;
HASH       : '#' ;
CARAT      : '^' ;
               
PLUS      : '+' ;
MINUS     : '-' ;
AMPERSAND : '&' ;
MULTIPLY  : '*' ;
DIVIDE    : '/' ;
               
EXP       : '**' ;
RANGE     : '..' ;
               
NOT_EQL   : '/=' ;
GT_EQL    : '>=' ;
LT_EQL    : '<=' ;
EQL       : '='  ;
LT        : '<'  ;
GT        : '>'  ;
LL        : '<<' ;
GG        : '>>' ;
FUNCARROW : '->' ;
               
COLON     : ':'   ;
SEMICOLON : ';'   ;
SWAP_OP   : ':=:' ;
ASSIGN_OP : ':='  ;
               
BAR       : '|'  ;
DBL_BAR   : '||' ;
DQUOTE    : '"'  ;
TILDE     : '~'  ;


STRING_LITERAL
    : '"' (ESC|~('"'|'\\'))* '"'
    ;

FREE_OPERATOR
  //@init { paraphrase.push("a free operator (infix or prefix)"); }
    //options { paraphrase = "a free operator (infix or prefix)"; }
    : '@' (USABLE)+ (DOT (USABLE)+)?
    ;

fragment USABLE
    : (ALPHABETIC | REQUIRED_SYMBOLIC)
    ;

fragment REQUIRED_SYMBOLIC
    : '~' | '!' | '#' | '$' | 
      '%' | '^' | '&' |  
      '(' | ')' | '-' | '+' | 
      '*' | ',' | '/' | 
      ':' | ';' | '<' | '=' |
      '>' | '?' | '@' | '[' | 
      '\\' | ']' | '{' | '}' 
    ; 

fragment ESC
    : '\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\'' | '"' | '\\' )
    /* Note: '\'' is a quoted special quote and
     * '"' - a quoted double quote
     */
    ;
