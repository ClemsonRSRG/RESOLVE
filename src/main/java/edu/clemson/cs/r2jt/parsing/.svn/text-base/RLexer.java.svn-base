// $ANTLR 3.3 Nov 30, 2010 12:50:56 RLexer.g 2012-03-16 12:04:51

    package edu.clemson.cs.r2jt.parsing;
    //import org.antlr.*;
    

import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
public class RLexer extends Lexer {
    public static final int EOF=-1;
    public static final int ABS=4;
    public static final int AD=5;
    public static final int ABSURDUM=6;
    public static final int ALL=7;
    public static final int ALTERS=8;
    public static final int ALTERNATIVE=9;
    public static final int AND=10;
    public static final int ARRAY=11;
    public static final int ASSUME=12;
    public static final int AUX_CODE=13;
    public static final int AUX_VAR=14;
    public static final int AUX_VARS=15;
    public static final int AUXILIARY=16;
    public static final int AXIOM=17;
    public static final int BOOLEAN=18;
    public static final int BASECASE=19;
    public static final int BY=20;
    public static final int CARTPROD=21;
    public static final int CATEGORICAL=22;
    public static final int CASE=23;
    public static final int CHANGING=24;
    public static final int CLEARS=25;
    public static final int COMMON=26;
    public static final int CONCLUSION=27;
    public static final int COMMUTATIVITY=28;
    public static final int COMPLEMENT=29;
    public static final int CONCEPT=30;
    public static final int MODULE_CONCEPT=31;
    public static final int CONFIRM=32;
    public static final int CONJUNCT=33;
    public static final int CONSTRAINT=34;
    public static final int CONTRADICTION=35;
    public static final int CONVENTION=36;
    public static final int COROLLARY=37;
    public static final int CORR=38;
    public static final int DECREASING=39;
    public static final int DEDUCTION=40;
    public static final int DEFINES=41;
    public static final int DEFINITION=42;
    public static final int DISTRIBUTION=43;
    public static final int DIV=44;
    public static final int DO=45;
    public static final int DURATION=46;
    public static final int ELAPSED_TIME=47;
    public static final int ELSE=48;
    public static final int ELIMINATION=49;
    public static final int END=50;
    public static final int ENHANCED=51;
    public static final int ENHANCEMENT=52;
    public static final int MODULE_ENHANCEMENT=53;
    public static final int ENSURES=54;
    public static final int EQUALITY=55;
    public static final int EVALUATES=56;
    public static final int EXCLUDED=57;
    public static final int EXEMPLAR=58;
    public static final int EXISTENTIAL=59;
    public static final int EXISTS=60;
    public static final int EXIT=61;
    public static final int FACILITY=62;
    public static final int FAC_FINAL=63;
    public static final int FAC_INIT=64;
    public static final int FAMILY=65;
    public static final int FINALIZATION=66;
    public static final int FROM=67;
    public static final int FOR=68;
    public static final int FORGET=69;
    public static final int GENERALIZATION=70;
    public static final int IF=71;
    public static final int IFF=72;
    public static final int IMPLICIT=73;
    public static final int IMPLIES=74;
    public static final int INDUCTIVE=75;
    public static final int INDUCTIVECASE=76;
    public static final int INITIALIZATION=77;
    public static final int INSTANTIATION=78;
    public static final int INTERSECT=79;
    public static final int INTRODUCES=80;
    public static final int IS=81;
    public static final int IN=82;
    public static final int NOT_IN=83;
    public static final int NOT_PROP_SUBSET=84;
    public static final int NOT_SUBSET=85;
    public static final int NOT_SUBSTR=86;
    public static final int PROP_SUBSET=87;
    public static final int SUBSET=88;
    public static final int SUBSTR=89;
    public static final int ITERATE=90;
    public static final int LAMBDA=91;
    public static final int LEMMA=92;
    public static final int LOCAL=93;
    public static final int MAINP_DISP=94;
    public static final int MAINTAINING=95;
    public static final int MATH=96;
    public static final int MIDDLE=97;
    public static final int MOD=98;
    public static final int MODELED=99;
    public static final int MODUS=100;
    public static final int NOT=101;
    public static final int CAT=102;
    public static final int OF=103;
    public static final int OPERATION=104;
    public static final int OR=105;
    public static final int OTHERWISE=106;
    public static final int PERF_FINAL=107;
    public static final int PERF_INIT=108;
    public static final int PONENS=109;
    public static final int PRESERVES=110;
    public static final int PROCEDURE=111;
    public static final int MODULE_PROFILE=112;
    public static final int PROOF=113;
    public static final int PROOFS_FOR=114;
    public static final int PROPERTY=115;
    public static final int QED=116;
    public static final int QUANTIFIER=117;
    public static final int REALIZATION=118;
    public static final int MODULE_REALIZATION=119;
    public static final int REALIZED=120;
    public static final int REASSIGNS=121;
    public static final int RECORD=122;
    public static final int RECURSIVE=123;
    public static final int REDUCTIO=124;
    public static final int RELATED=125;
    public static final int REM=126;
    public static final int REMEMBER=127;
    public static final int REPEAT=128;
    public static final int REPLACES=129;
    public static final int REPRESENTED=130;
    public static final int REQUIRES=131;
    public static final int RESPECTS=132;
    public static final int RESTORES=133;
    public static final int RULE=134;
    public static final int SELF=135;
    public static final int SHORT_FOR=136;
    public static final int STATIC=137;
    public static final int SUBTYPE=138;
    public static final int SUCH=139;
    public static final int SUPPOSITION=140;
    public static final int THAT=141;
    public static final int THEN=142;
    public static final int THEOREM=143;
    public static final int THEORY=144;
    public static final int THERE=145;
    public static final int TIMES=146;
    public static final int TYPE=147;
    public static final int TYPE_FAMILY=148;
    public static final int UNION=149;
    public static final int UNIQUE=150;
    public static final int UNIT=151;
    public static final int UNIVERSAL=152;
    public static final int UPDATES=153;
    public static final int USES=154;
    public static final int VAR=155;
    public static final int VARIABLES=156;
    public static final int WHEN=157;
    public static final int WHERE=158;
    public static final int WHILE=159;
    public static final int WITHOUT=160;
    public static final int WITH_PROFILE=161;
    public static final int LETTER=162;
    public static final int ALPHABETIC=163;
    public static final int IDENTIFIER=164;
    public static final int WS=165;
    public static final int SL_COMMENT=166;
    public static final int ML_COMMENT=167;
    public static final int DIGIT=168;
    public static final int DIGITS=169;
    public static final int DOT=170;
    public static final int REAL=171;
    public static final int NUMERIC_LITERAL=172;
    public static final int ESC=173;
    public static final int CHARACTER_LITERAL=174;
    public static final int COMMA=175;
    public static final int LPAREN=176;
    public static final int RPAREN=177;
    public static final int LBRACE=178;
    public static final int RBRACE=179;
    public static final int DBL_LBRACE=180;
    public static final int DBL_RBRACE=181;
    public static final int LSQBRACK=182;
    public static final int RSQBRACK=183;
    public static final int HASH=184;
    public static final int CARAT=185;
    public static final int PLUS=186;
    public static final int MINUS=187;
    public static final int AMPERSAND=188;
    public static final int MULTIPLY=189;
    public static final int DIVIDE=190;
    public static final int EXP=191;
    public static final int RANGE=192;
    public static final int NOT_EQL=193;
    public static final int GT_EQL=194;
    public static final int LT_EQL=195;
    public static final int EQL=196;
    public static final int LT=197;
    public static final int GT=198;
    public static final int LL=199;
    public static final int GG=200;
    public static final int FUNCARROW=201;
    public static final int COLON=202;
    public static final int SEMICOLON=203;
    public static final int SWAP_OP=204;
    public static final int ASSIGN_OP=205;
    public static final int BAR=206;
    public static final int DBL_BAR=207;
    public static final int DQUOTE=208;
    public static final int TILDE=209;
    public static final int STRING_LITERAL=210;
    public static final int USABLE=211;
    public static final int FREE_OPERATOR=212;
    public static final int REQUIRED_SYMBOLIC=213;

    // delegates
    // delegators

    public RLexer() {;} 
    public RLexer(CharStream input) {
        this(input, new RecognizerSharedState());
    }
    public RLexer(CharStream input, RecognizerSharedState state) {
        super(input,state);

    }
    public String getGrammarFileName() { return "RLexer.g"; }

    // $ANTLR start "ABS"
    public final void mABS() throws RecognitionException {
        try {
            int _type = ABS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:13:3: ( 'abs' )
            // RLexer.g:13:5: 'abs'
            {
            match("abs"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ABS"

    // $ANTLR start "AD"
    public final void mAD() throws RecognitionException {
        try {
            int _type = AD;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:17:3: ( 'ad' )
            // RLexer.g:17:5: 'ad'
            {
            match("ad"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "AD"

    // $ANTLR start "ABSURDUM"
    public final void mABSURDUM() throws RecognitionException {
        try {
            int _type = ABSURDUM;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:21:3: ( 'absurdum' )
            // RLexer.g:21:5: 'absurdum'
            {
            match("absurdum"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ABSURDUM"

    // $ANTLR start "ALL"
    public final void mALL() throws RecognitionException {
        try {
            int _type = ALL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:25:3: ( 'all' )
            // RLexer.g:25:5: 'all'
            {
            match("all"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ALL"

    // $ANTLR start "ALTERS"
    public final void mALTERS() throws RecognitionException {
        try {
            int _type = ALTERS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:29:3: ( 'alt' | 'alters' )
            int alt1=2;
            int LA1_0 = input.LA(1);

            if ( (LA1_0=='a') ) {
                int LA1_1 = input.LA(2);

                if ( (LA1_1=='l') ) {
                    int LA1_2 = input.LA(3);

                    if ( (LA1_2=='t') ) {
                        int LA1_3 = input.LA(4);

                        if ( (LA1_3=='e') ) {
                            alt1=2;
                        }
                        else {
                            alt1=1;}
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 1, 2, input);

                        throw nvae;
                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 1, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 1, 0, input);

                throw nvae;
            }
            switch (alt1) {
                case 1 :
                    // RLexer.g:29:5: 'alt'
                    {
                    match("alt"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:29:13: 'alters'
                    {
                    match("alters"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ALTERS"

    // $ANTLR start "ALTERNATIVE"
    public final void mALTERNATIVE() throws RecognitionException {
        try {
            int _type = ALTERNATIVE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:33:3: ( 'alternative' )
            // RLexer.g:33:5: 'alternative'
            {
            match("alternative"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ALTERNATIVE"

    // $ANTLR start "AND"
    public final void mAND() throws RecognitionException {
        try {
            int _type = AND;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:37:3: ( 'and' )
            // RLexer.g:37:5: 'and'
            {
            match("and"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "AND"

    // $ANTLR start "ARRAY"
    public final void mARRAY() throws RecognitionException {
        try {
            int _type = ARRAY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:41:3: ( 'Array' )
            // RLexer.g:41:5: 'Array'
            {
            match("Array"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ARRAY"

    // $ANTLR start "ASSUME"
    public final void mASSUME() throws RecognitionException {
        try {
            int _type = ASSUME;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:45:3: ( 'assume' )
            // RLexer.g:45:5: 'assume'
            {
            match("assume"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ASSUME"

    // $ANTLR start "AUX_CODE"
    public final void mAUX_CODE() throws RecognitionException {
        try {
            int _type = AUX_CODE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:49:3: ( 'Aux_Code' )
            // RLexer.g:49:5: 'Aux_Code'
            {
            match("Aux_Code"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "AUX_CODE"

    // $ANTLR start "AUX_VAR"
    public final void mAUX_VAR() throws RecognitionException {
        try {
            int _type = AUX_VAR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:53:3: ( 'Aux_Var' )
            // RLexer.g:53:5: 'Aux_Var'
            {
            match("Aux_Var"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "AUX_VAR"

    // $ANTLR start "AUX_VARS"
    public final void mAUX_VARS() throws RecognitionException {
        try {
            int _type = AUX_VARS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:57:3: ( 'Aux_Vars' )
            // RLexer.g:57:5: 'Aux_Vars'
            {
            match("Aux_Vars"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "AUX_VARS"

    // $ANTLR start "AUXILIARY"
    public final void mAUXILIARY() throws RecognitionException {
        try {
            int _type = AUXILIARY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:61:3: ( 'Aux' | 'Auxiliary' )
            int alt2=2;
            int LA2_0 = input.LA(1);

            if ( (LA2_0=='A') ) {
                int LA2_1 = input.LA(2);

                if ( (LA2_1=='u') ) {
                    int LA2_2 = input.LA(3);

                    if ( (LA2_2=='x') ) {
                        int LA2_3 = input.LA(4);

                        if ( (LA2_3=='i') ) {
                            alt2=2;
                        }
                        else {
                            alt2=1;}
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 2, 2, input);

                        throw nvae;
                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 2, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 2, 0, input);

                throw nvae;
            }
            switch (alt2) {
                case 1 :
                    // RLexer.g:61:5: 'Aux'
                    {
                    match("Aux"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:61:13: 'Auxiliary'
                    {
                    match("Auxiliary"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "AUXILIARY"

    // $ANTLR start "AXIOM"
    public final void mAXIOM() throws RecognitionException {
        try {
            int _type = AXIOM;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:65:3: ( 'Axiom' )
            // RLexer.g:65:5: 'Axiom'
            {
            match("Axiom"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "AXIOM"

    // $ANTLR start "BOOLEAN"
    public final void mBOOLEAN() throws RecognitionException {
        try {
            int _type = BOOLEAN;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:69:3: ( 'B' | 'false' | 'true' )
            int alt3=3;
            switch ( input.LA(1) ) {
            case 'B':
                {
                alt3=1;
                }
                break;
            case 'f':
                {
                alt3=2;
                }
                break;
            case 't':
                {
                alt3=3;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 3, 0, input);

                throw nvae;
            }

            switch (alt3) {
                case 1 :
                    // RLexer.g:69:5: 'B'
                    {
                    match('B'); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // RLexer.g:69:11: 'false'
                    {
                    match("false"); if (state.failed) return ;


                    }
                    break;
                case 3 :
                    // RLexer.g:69:21: 'true'
                    {
                    match("true"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "BOOLEAN"

    // $ANTLR start "BASECASE"
    public final void mBASECASE() throws RecognitionException {
        try {
            int _type = BASECASE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:73:3: ( 'Base_Case' )
            // RLexer.g:73:5: 'Base_Case'
            {
            match("Base_Case"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "BASECASE"

    // $ANTLR start "BY"
    public final void mBY() throws RecognitionException {
        try {
            int _type = BY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:77:3: ( 'By' | 'by' )
            int alt4=2;
            int LA4_0 = input.LA(1);

            if ( (LA4_0=='B') ) {
                alt4=1;
            }
            else if ( (LA4_0=='b') ) {
                alt4=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 4, 0, input);

                throw nvae;
            }
            switch (alt4) {
                case 1 :
                    // RLexer.g:77:5: 'By'
                    {
                    match("By"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:77:12: 'by'
                    {
                    match("by"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "BY"

    // $ANTLR start "CARTPROD"
    public final void mCARTPROD() throws RecognitionException {
        try {
            int _type = CARTPROD;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:81:3: ( 'Cart_Prod' )
            // RLexer.g:81:5: 'Cart_Prod'
            {
            match("Cart_Prod"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CARTPROD"

    // $ANTLR start "CATEGORICAL"
    public final void mCATEGORICAL() throws RecognitionException {
        try {
            int _type = CATEGORICAL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:85:3: ( 'Categorical' )
            // RLexer.g:85:5: 'Categorical'
            {
            match("Categorical"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CATEGORICAL"

    // $ANTLR start "CASE"
    public final void mCASE() throws RecognitionException {
        try {
            int _type = CASE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:89:3: ( 'Case' )
            // RLexer.g:89:5: 'Case'
            {
            match("Case"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CASE"

    // $ANTLR start "CHANGING"
    public final void mCHANGING() throws RecognitionException {
        try {
            int _type = CHANGING;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:93:3: ( 'changing' )
            // RLexer.g:93:5: 'changing'
            {
            match("changing"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CHANGING"

    // $ANTLR start "CLEARS"
    public final void mCLEARS() throws RecognitionException {
        try {
            int _type = CLEARS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:97:3: ( 'clr' | 'clears' )
            int alt5=2;
            int LA5_0 = input.LA(1);

            if ( (LA5_0=='c') ) {
                int LA5_1 = input.LA(2);

                if ( (LA5_1=='l') ) {
                    int LA5_2 = input.LA(3);

                    if ( (LA5_2=='r') ) {
                        alt5=1;
                    }
                    else if ( (LA5_2=='e') ) {
                        alt5=2;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 5, 2, input);

                        throw nvae;
                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 5, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 5, 0, input);

                throw nvae;
            }
            switch (alt5) {
                case 1 :
                    // RLexer.g:97:5: 'clr'
                    {
                    match("clr"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:97:13: 'clears'
                    {
                    match("clears"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CLEARS"

    // $ANTLR start "COMMON"
    public final void mCOMMON() throws RecognitionException {
        try {
            int _type = COMMON;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:101:3: ( 'common' )
            // RLexer.g:101:5: 'common'
            {
            match("common"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "COMMON"

    // $ANTLR start "CONCLUSION"
    public final void mCONCLUSION() throws RecognitionException {
        try {
            int _type = CONCLUSION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:105:3: ( 'conclusion' )
            // RLexer.g:105:5: 'conclusion'
            {
            match("conclusion"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CONCLUSION"

    // $ANTLR start "COMMUTATIVITY"
    public final void mCOMMUTATIVITY() throws RecognitionException {
        try {
            int _type = COMMUTATIVITY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:109:3: ( 'Commutativity' )
            // RLexer.g:109:5: 'Commutativity'
            {
            match("Commutativity"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "COMMUTATIVITY"

    // $ANTLR start "COMPLEMENT"
    public final void mCOMPLEMENT() throws RecognitionException {
        try {
            int _type = COMPLEMENT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:113:3: ( 'complement' )
            // RLexer.g:113:5: 'complement'
            {
            match("complement"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "COMPLEMENT"

    // $ANTLR start "CONCEPT"
    public final void mCONCEPT() throws RecognitionException {
        try {
            int _type = CONCEPT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:117:3: ( 'concept' )
            // RLexer.g:117:5: 'concept'
            {
            match("concept"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CONCEPT"

    // $ANTLR start "MODULE_CONCEPT"
    public final void mMODULE_CONCEPT() throws RecognitionException {
        try {
            int _type = MODULE_CONCEPT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:121:3: ( 'Concept' )
            // RLexer.g:121:5: 'Concept'
            {
            match("Concept"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MODULE_CONCEPT"

    // $ANTLR start "CONFIRM"
    public final void mCONFIRM() throws RecognitionException {
        try {
            int _type = CONFIRM;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:125:3: ( 'Confirm' )
            // RLexer.g:125:5: 'Confirm'
            {
            match("Confirm"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CONFIRM"

    // $ANTLR start "CONJUNCT"
    public final void mCONJUNCT() throws RecognitionException {
        try {
            int _type = CONJUNCT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:129:3: ( 'conjunct' )
            // RLexer.g:129:5: 'conjunct'
            {
            match("conjunct"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CONJUNCT"

    // $ANTLR start "CONSTRAINT"
    public final void mCONSTRAINT() throws RecognitionException {
        try {
            int _type = CONSTRAINT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:133:3: ( 'Constraint' | 'Constraints' | 'constraint' | 'constraints' )
            int alt6=4;
            alt6 = dfa6.predict(input);
            switch (alt6) {
                case 1 :
                    // RLexer.g:133:5: 'Constraint'
                    {
                    match("Constraint"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:133:20: 'Constraints'
                    {
                    match("Constraints"); if (state.failed) return ;


                    }
                    break;
                case 3 :
                    // RLexer.g:133:36: 'constraint'
                    {
                    match("constraint"); if (state.failed) return ;


                    }
                    break;
                case 4 :
                    // RLexer.g:133:51: 'constraints'
                    {
                    match("constraints"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CONSTRAINT"

    // $ANTLR start "CONTRADICTION"
    public final void mCONTRADICTION() throws RecognitionException {
        try {
            int _type = CONTRADICTION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:137:3: ( 'contradiction' )
            // RLexer.g:137:5: 'contradiction'
            {
            match("contradiction"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CONTRADICTION"

    // $ANTLR start "CONVENTION"
    public final void mCONVENTION() throws RecognitionException {
        try {
            int _type = CONVENTION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:141:3: ( 'Convention' | 'Conventions' | 'convention' | 'conventions' )
            int alt7=4;
            alt7 = dfa7.predict(input);
            switch (alt7) {
                case 1 :
                    // RLexer.g:141:5: 'Convention'
                    {
                    match("Convention"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:141:20: 'Conventions'
                    {
                    match("Conventions"); if (state.failed) return ;


                    }
                    break;
                case 3 :
                    // RLexer.g:141:36: 'convention'
                    {
                    match("convention"); if (state.failed) return ;


                    }
                    break;
                case 4 :
                    // RLexer.g:141:51: 'conventions'
                    {
                    match("conventions"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CONVENTION"

    // $ANTLR start "COROLLARY"
    public final void mCOROLLARY() throws RecognitionException {
        try {
            int _type = COROLLARY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:145:3: ( 'Corollary' )
            // RLexer.g:145:5: 'Corollary'
            {
            match("Corollary"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "COROLLARY"

    // $ANTLR start "CORR"
    public final void mCORR() throws RecognitionException {
        try {
            int _type = CORR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:149:3: ( 'Correspondence' | 'correspondence' )
            int alt8=2;
            int LA8_0 = input.LA(1);

            if ( (LA8_0=='C') ) {
                alt8=1;
            }
            else if ( (LA8_0=='c') ) {
                alt8=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 8, 0, input);

                throw nvae;
            }
            switch (alt8) {
                case 1 :
                    // RLexer.g:149:5: 'Correspondence'
                    {
                    match("Correspondence"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:149:24: 'correspondence'
                    {
                    match("correspondence"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CORR"

    // $ANTLR start "DECREASING"
    public final void mDECREASING() throws RecognitionException {
        try {
            int _type = DECREASING;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:153:3: ( 'decreasing' )
            // RLexer.g:153:5: 'decreasing'
            {
            match("decreasing"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DECREASING"

    // $ANTLR start "DEDUCTION"
    public final void mDEDUCTION() throws RecognitionException {
        try {
            int _type = DEDUCTION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:157:3: ( 'Deduction' )
            // RLexer.g:157:5: 'Deduction'
            {
            match("Deduction"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DEDUCTION"

    // $ANTLR start "DEFINES"
    public final void mDEFINES() throws RecognitionException {
        try {
            int _type = DEFINES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:161:3: ( 'Defines' | 'defines' )
            int alt9=2;
            int LA9_0 = input.LA(1);

            if ( (LA9_0=='D') ) {
                alt9=1;
            }
            else if ( (LA9_0=='d') ) {
                alt9=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 9, 0, input);

                throw nvae;
            }
            switch (alt9) {
                case 1 :
                    // RLexer.g:161:5: 'Defines'
                    {
                    match("Defines"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:161:17: 'defines'
                    {
                    match("defines"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DEFINES"

    // $ANTLR start "DEFINITION"
    public final void mDEFINITION() throws RecognitionException {
        try {
            int _type = DEFINITION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:165:3: ( 'Def' | 'def' | 'Definition' | 'definition' )
            int alt10=4;
            alt10 = dfa10.predict(input);
            switch (alt10) {
                case 1 :
                    // RLexer.g:165:5: 'Def'
                    {
                    match("Def"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:165:13: 'def'
                    {
                    match("def"); if (state.failed) return ;


                    }
                    break;
                case 3 :
                    // RLexer.g:165:21: 'Definition'
                    {
                    match("Definition"); if (state.failed) return ;


                    }
                    break;
                case 4 :
                    // RLexer.g:165:36: 'definition'
                    {
                    match("definition"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DEFINITION"

    // $ANTLR start "DISTRIBUTION"
    public final void mDISTRIBUTION() throws RecognitionException {
        try {
            int _type = DISTRIBUTION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:169:3: ( 'distribution' )
            // RLexer.g:169:5: 'distribution'
            {
            match("distribution"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DISTRIBUTION"

    // $ANTLR start "DIV"
    public final void mDIV() throws RecognitionException {
        try {
            int _type = DIV;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:173:3: ( 'div' )
            // RLexer.g:173:5: 'div'
            {
            match("div"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DIV"

    // $ANTLR start "DO"
    public final void mDO() throws RecognitionException {
        try {
            int _type = DO;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:177:3: ( 'do' )
            // RLexer.g:177:5: 'do'
            {
            match("do"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DO"

    // $ANTLR start "DURATION"
    public final void mDURATION() throws RecognitionException {
        try {
            int _type = DURATION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:181:3: ( 'duration' )
            // RLexer.g:181:5: 'duration'
            {
            match("duration"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DURATION"

    // $ANTLR start "ELAPSED_TIME"
    public final void mELAPSED_TIME() throws RecognitionException {
        try {
            int _type = ELAPSED_TIME;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:185:3: ( 'elapsed_time' )
            // RLexer.g:185:5: 'elapsed_time'
            {
            match("elapsed_time"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ELAPSED_TIME"

    // $ANTLR start "ELSE"
    public final void mELSE() throws RecognitionException {
        try {
            int _type = ELSE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:189:3: ( 'else' )
            // RLexer.g:189:5: 'else'
            {
            match("else"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ELSE"

    // $ANTLR start "ELIMINATION"
    public final void mELIMINATION() throws RecognitionException {
        try {
            int _type = ELIMINATION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:193:3: ( 'elimination' )
            // RLexer.g:193:5: 'elimination'
            {
            match("elimination"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ELIMINATION"

    // $ANTLR start "END"
    public final void mEND() throws RecognitionException {
        try {
            int _type = END;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:197:3: ( 'end' )
            // RLexer.g:197:5: 'end'
            {
            match("end"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "END"

    // $ANTLR start "ENHANCED"
    public final void mENHANCED() throws RecognitionException {
        try {
            int _type = ENHANCED;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:201:3: ( 'enhanced' )
            // RLexer.g:201:5: 'enhanced'
            {
            match("enhanced"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ENHANCED"

    // $ANTLR start "ENHANCEMENT"
    public final void mENHANCEMENT() throws RecognitionException {
        try {
            int _type = ENHANCEMENT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:205:3: ( 'enhancement' )
            // RLexer.g:205:5: 'enhancement'
            {
            match("enhancement"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ENHANCEMENT"

    // $ANTLR start "MODULE_ENHANCEMENT"
    public final void mMODULE_ENHANCEMENT() throws RecognitionException {
        try {
            int _type = MODULE_ENHANCEMENT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:209:3: ( 'Enhancement' )
            // RLexer.g:209:5: 'Enhancement'
            {
            match("Enhancement"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MODULE_ENHANCEMENT"

    // $ANTLR start "ENSURES"
    public final void mENSURES() throws RecognitionException {
        try {
            int _type = ENSURES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:213:3: ( 'ensures' )
            // RLexer.g:213:5: 'ensures'
            {
            match("ensures"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ENSURES"

    // $ANTLR start "EQUALITY"
    public final void mEQUALITY() throws RecognitionException {
        try {
            int _type = EQUALITY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:217:3: ( 'equality' )
            // RLexer.g:217:5: 'equality'
            {
            match("equality"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "EQUALITY"

    // $ANTLR start "EVALUATES"
    public final void mEVALUATES() throws RecognitionException {
        try {
            int _type = EVALUATES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:221:3: ( 'eval' | 'evaluates' )
            int alt11=2;
            int LA11_0 = input.LA(1);

            if ( (LA11_0=='e') ) {
                int LA11_1 = input.LA(2);

                if ( (LA11_1=='v') ) {
                    int LA11_2 = input.LA(3);

                    if ( (LA11_2=='a') ) {
                        int LA11_3 = input.LA(4);

                        if ( (LA11_3=='l') ) {
                            int LA11_4 = input.LA(5);

                            if ( (LA11_4=='u') ) {
                                alt11=2;
                            }
                            else {
                                alt11=1;}
                        }
                        else {
                            if (state.backtracking>0) {state.failed=true; return ;}
                            NoViableAltException nvae =
                                new NoViableAltException("", 11, 3, input);

                            throw nvae;
                        }
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 11, 2, input);

                        throw nvae;
                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 11, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 11, 0, input);

                throw nvae;
            }
            switch (alt11) {
                case 1 :
                    // RLexer.g:221:5: 'eval'
                    {
                    match("eval"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:221:14: 'evaluates'
                    {
                    match("evaluates"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "EVALUATES"

    // $ANTLR start "EXCLUDED"
    public final void mEXCLUDED() throws RecognitionException {
        try {
            int _type = EXCLUDED;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:225:3: ( 'excluded' )
            // RLexer.g:225:5: 'excluded'
            {
            match("excluded"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "EXCLUDED"

    // $ANTLR start "EXEMPLAR"
    public final void mEXEMPLAR() throws RecognitionException {
        try {
            int _type = EXEMPLAR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:229:3: ( 'exemplar' )
            // RLexer.g:229:5: 'exemplar'
            {
            match("exemplar"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "EXEMPLAR"

    // $ANTLR start "EXISTENTIAL"
    public final void mEXISTENTIAL() throws RecognitionException {
        try {
            int _type = EXISTENTIAL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:233:3: ( 'existantial' )
            // RLexer.g:233:5: 'existantial'
            {
            match("existantial"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "EXISTENTIAL"

    // $ANTLR start "EXISTS"
    public final void mEXISTS() throws RecognitionException {
        try {
            int _type = EXISTS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:237:3: ( 'exists' )
            // RLexer.g:237:5: 'exists'
            {
            match("exists"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "EXISTS"

    // $ANTLR start "EXIT"
    public final void mEXIT() throws RecognitionException {
        try {
            int _type = EXIT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:241:3: ( 'exit' )
            // RLexer.g:241:5: 'exit'
            {
            match("exit"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "EXIT"

    // $ANTLR start "FACILITY"
    public final void mFACILITY() throws RecognitionException {
        try {
            int _type = FACILITY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:245:3: ( 'Facility' )
            // RLexer.g:245:5: 'Facility'
            {
            match("Facility"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "FACILITY"

    // $ANTLR start "FAC_FINAL"
    public final void mFAC_FINAL() throws RecognitionException {
        try {
            int _type = FAC_FINAL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:249:3: ( 'Facility_Finalization' )
            // RLexer.g:249:5: 'Facility_Finalization'
            {
            match("Facility_Finalization"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "FAC_FINAL"

    // $ANTLR start "FAC_INIT"
    public final void mFAC_INIT() throws RecognitionException {
        try {
            int _type = FAC_INIT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:253:3: ( 'Facility_Initialization' )
            // RLexer.g:253:5: 'Facility_Initialization'
            {
            match("Facility_Initialization"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "FAC_INIT"

    // $ANTLR start "FAMILY"
    public final void mFAMILY() throws RecognitionException {
        try {
            int _type = FAMILY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:257:3: ( 'Family' )
            // RLexer.g:257:5: 'Family'
            {
            match("Family"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "FAMILY"

    // $ANTLR start "FINALIZATION"
    public final void mFINALIZATION() throws RecognitionException {
        try {
            int _type = FINALIZATION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:261:3: ( 'finalization' )
            // RLexer.g:261:5: 'finalization'
            {
            match("finalization"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "FINALIZATION"

    // $ANTLR start "FROM"
    public final void mFROM() throws RecognitionException {
        try {
            int _type = FROM;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:265:3: ( 'from' )
            // RLexer.g:265:5: 'from'
            {
            match("from"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "FROM"

    // $ANTLR start "FOR"
    public final void mFOR() throws RecognitionException {
        try {
            int _type = FOR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:269:3: ( 'For' | 'for' )
            int alt12=2;
            int LA12_0 = input.LA(1);

            if ( (LA12_0=='F') ) {
                alt12=1;
            }
            else if ( (LA12_0=='f') ) {
                alt12=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 12, 0, input);

                throw nvae;
            }
            switch (alt12) {
                case 1 :
                    // RLexer.g:269:5: 'For'
                    {
                    match("For"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:269:13: 'for'
                    {
                    match("for"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "FOR"

    // $ANTLR start "FORGET"
    public final void mFORGET() throws RecognitionException {
        try {
            int _type = FORGET;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:273:3: ( 'Forget' )
            // RLexer.g:273:5: 'Forget'
            {
            match("Forget"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "FORGET"

    // $ANTLR start "GENERALIZATION"
    public final void mGENERALIZATION() throws RecognitionException {
        try {
            int _type = GENERALIZATION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:277:3: ( 'generalization' )
            // RLexer.g:277:5: 'generalization'
            {
            match("generalization"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "GENERALIZATION"

    // $ANTLR start "IF"
    public final void mIF() throws RecognitionException {
        try {
            int _type = IF;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:281:3: ( 'If' | 'if' )
            int alt13=2;
            int LA13_0 = input.LA(1);

            if ( (LA13_0=='I') ) {
                alt13=1;
            }
            else if ( (LA13_0=='i') ) {
                alt13=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 13, 0, input);

                throw nvae;
            }
            switch (alt13) {
                case 1 :
                    // RLexer.g:281:5: 'If'
                    {
                    match("If"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:281:12: 'if'
                    {
                    match("if"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "IF"

    // $ANTLR start "IFF"
    public final void mIFF() throws RecognitionException {
        try {
            int _type = IFF;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:285:3: ( 'iff' )
            // RLexer.g:285:5: 'iff'
            {
            match("iff"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "IFF"

    // $ANTLR start "IMPLICIT"
    public final void mIMPLICIT() throws RecognitionException {
        try {
            int _type = IMPLICIT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:289:3: ( 'Inplicit' )
            // RLexer.g:289:5: 'Inplicit'
            {
            match("Inplicit"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "IMPLICIT"

    // $ANTLR start "IMPLIES"
    public final void mIMPLIES() throws RecognitionException {
        try {
            int _type = IMPLIES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:293:3: ( 'implies' )
            // RLexer.g:293:5: 'implies'
            {
            match("implies"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "IMPLIES"

    // $ANTLR start "INDUCTIVE"
    public final void mINDUCTIVE() throws RecognitionException {
        try {
            int _type = INDUCTIVE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:297:3: ( 'Inductive' )
            // RLexer.g:297:5: 'Inductive'
            {
            match("Inductive"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "INDUCTIVE"

    // $ANTLR start "INDUCTIVECASE"
    public final void mINDUCTIVECASE() throws RecognitionException {
        try {
            int _type = INDUCTIVECASE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:301:3: ( 'Inductive_case' )
            // RLexer.g:301:5: 'Inductive_case'
            {
            match("Inductive_case"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "INDUCTIVECASE"

    // $ANTLR start "INITIALIZATION"
    public final void mINITIALIZATION() throws RecognitionException {
        try {
            int _type = INITIALIZATION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:305:3: ( 'initialization' )
            // RLexer.g:305:5: 'initialization'
            {
            match("initialization"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "INITIALIZATION"

    // $ANTLR start "INSTANTIATION"
    public final void mINSTANTIATION() throws RecognitionException {
        try {
            int _type = INSTANTIATION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:309:3: ( 'instantiation' )
            // RLexer.g:309:5: 'instantiation'
            {
            match("instantiation"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "INSTANTIATION"

    // $ANTLR start "INTERSECT"
    public final void mINTERSECT() throws RecognitionException {
        try {
            int _type = INTERSECT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:313:3: ( 'intersect' )
            // RLexer.g:313:5: 'intersect'
            {
            match("intersect"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "INTERSECT"

    // $ANTLR start "INTRODUCES"
    public final void mINTRODUCES() throws RecognitionException {
        try {
            int _type = INTRODUCES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:317:3: ( 'introduces' )
            // RLexer.g:317:5: 'introduces'
            {
            match("introduces"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "INTRODUCES"

    // $ANTLR start "IS"
    public final void mIS() throws RecognitionException {
        try {
            int _type = IS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:321:3: ( 'is' )
            // RLexer.g:321:5: 'is'
            {
            match("is"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "IS"

    // $ANTLR start "IN"
    public final void mIN() throws RecognitionException {
        try {
            int _type = IN;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:325:3: ( 'is_in' )
            // RLexer.g:325:5: 'is_in'
            {
            match("is_in"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "IN"

    // $ANTLR start "NOT_IN"
    public final void mNOT_IN() throws RecognitionException {
        try {
            int _type = NOT_IN;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:329:3: ( 'is_not_in' )
            // RLexer.g:329:5: 'is_not_in'
            {
            match("is_not_in"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "NOT_IN"

    // $ANTLR start "NOT_PROP_SUBSET"
    public final void mNOT_PROP_SUBSET() throws RecognitionException {
        try {
            int _type = NOT_PROP_SUBSET;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:333:3: ( 'is_not_proper_subset_of' )
            // RLexer.g:333:5: 'is_not_proper_subset_of'
            {
            match("is_not_proper_subset_of"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "NOT_PROP_SUBSET"

    // $ANTLR start "NOT_SUBSET"
    public final void mNOT_SUBSET() throws RecognitionException {
        try {
            int _type = NOT_SUBSET;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:337:3: ( 'is_not_subset_of' )
            // RLexer.g:337:5: 'is_not_subset_of'
            {
            match("is_not_subset_of"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "NOT_SUBSET"

    // $ANTLR start "NOT_SUBSTR"
    public final void mNOT_SUBSTR() throws RecognitionException {
        try {
            int _type = NOT_SUBSTR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:341:3: ( 'is_not_substring_of' )
            // RLexer.g:341:5: 'is_not_substring_of'
            {
            match("is_not_substring_of"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "NOT_SUBSTR"

    // $ANTLR start "PROP_SUBSET"
    public final void mPROP_SUBSET() throws RecognitionException {
        try {
            int _type = PROP_SUBSET;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:345:3: ( 'is_proper_subset_of' )
            // RLexer.g:345:5: 'is_proper_subset_of'
            {
            match("is_proper_subset_of"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "PROP_SUBSET"

    // $ANTLR start "SUBSET"
    public final void mSUBSET() throws RecognitionException {
        try {
            int _type = SUBSET;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:349:3: ( 'is_subset_of' )
            // RLexer.g:349:5: 'is_subset_of'
            {
            match("is_subset_of"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "SUBSET"

    // $ANTLR start "SUBSTR"
    public final void mSUBSTR() throws RecognitionException {
        try {
            int _type = SUBSTR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:353:3: ( 'is_substring_of' )
            // RLexer.g:353:5: 'is_substring_of'
            {
            match("is_substring_of"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "SUBSTR"

    // $ANTLR start "ITERATE"
    public final void mITERATE() throws RecognitionException {
        try {
            int _type = ITERATE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:357:3: ( 'Iterate' )
            // RLexer.g:357:5: 'Iterate'
            {
            match("Iterate"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ITERATE"

    // $ANTLR start "LAMBDA"
    public final void mLAMBDA() throws RecognitionException {
        try {
            int _type = LAMBDA;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:361:3: ( 'lambda' )
            // RLexer.g:361:5: 'lambda'
            {
            match("lambda"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "LAMBDA"

    // $ANTLR start "LEMMA"
    public final void mLEMMA() throws RecognitionException {
        try {
            int _type = LEMMA;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:365:3: ( 'Lemma' )
            // RLexer.g:365:5: 'Lemma'
            {
            match("Lemma"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "LEMMA"

    // $ANTLR start "LOCAL"
    public final void mLOCAL() throws RecognitionException {
        try {
            int _type = LOCAL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:369:3: ( 'Local' )
            // RLexer.g:369:5: 'Local'
            {
            match("Local"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "LOCAL"

    // $ANTLR start "MAINP_DISP"
    public final void mMAINP_DISP() throws RecognitionException {
        try {
            int _type = MAINP_DISP;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:373:3: ( 'mainp_disp' )
            // RLexer.g:373:5: 'mainp_disp'
            {
            match("mainp_disp"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MAINP_DISP"

    // $ANTLR start "MAINTAINING"
    public final void mMAINTAINING() throws RecognitionException {
        try {
            int _type = MAINTAINING;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:377:3: ( 'maintaining' )
            // RLexer.g:377:5: 'maintaining'
            {
            match("maintaining"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MAINTAINING"

    // $ANTLR start "MATH"
    public final void mMATH() throws RecognitionException {
        try {
            int _type = MATH;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:381:3: ( 'Math' )
            // RLexer.g:381:5: 'Math'
            {
            match("Math"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MATH"

    // $ANTLR start "MIDDLE"
    public final void mMIDDLE() throws RecognitionException {
        try {
            int _type = MIDDLE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:385:3: ( 'middle' )
            // RLexer.g:385:5: 'middle'
            {
            match("middle"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MIDDLE"

    // $ANTLR start "MOD"
    public final void mMOD() throws RecognitionException {
        try {
            int _type = MOD;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:389:3: ( 'mod' )
            // RLexer.g:389:5: 'mod'
            {
            match("mod"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MOD"

    // $ANTLR start "MODELED"
    public final void mMODELED() throws RecognitionException {
        try {
            int _type = MODELED;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:393:3: ( 'modeled' )
            // RLexer.g:393:5: 'modeled'
            {
            match("modeled"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MODELED"

    // $ANTLR start "MODUS"
    public final void mMODUS() throws RecognitionException {
        try {
            int _type = MODUS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:397:3: ( 'modus' )
            // RLexer.g:397:5: 'modus'
            {
            match("modus"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MODUS"

    // $ANTLR start "NOT"
    public final void mNOT() throws RecognitionException {
        try {
            int _type = NOT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:401:3: ( 'not' )
            // RLexer.g:401:5: 'not'
            {
            match("not"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "NOT"

    // $ANTLR start "CAT"
    public final void mCAT() throws RecognitionException {
        try {
            int _type = CAT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:405:3: ( 'o' )
            // RLexer.g:405:5: 'o'
            {
            match('o'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CAT"

    // $ANTLR start "OF"
    public final void mOF() throws RecognitionException {
        try {
            int _type = OF;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:409:3: ( 'of' )
            // RLexer.g:409:5: 'of'
            {
            match("of"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "OF"

    // $ANTLR start "OPERATION"
    public final void mOPERATION() throws RecognitionException {
        try {
            int _type = OPERATION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:413:3: ( 'oper' | 'operation' | 'Oper' | 'Operation' )
            int alt14=4;
            alt14 = dfa14.predict(input);
            switch (alt14) {
                case 1 :
                    // RLexer.g:413:5: 'oper'
                    {
                    match("oper"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:413:14: 'operation'
                    {
                    match("operation"); if (state.failed) return ;


                    }
                    break;
                case 3 :
                    // RLexer.g:413:28: 'Oper'
                    {
                    match("Oper"); if (state.failed) return ;


                    }
                    break;
                case 4 :
                    // RLexer.g:413:37: 'Operation'
                    {
                    match("Operation"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "OPERATION"

    // $ANTLR start "OR"
    public final void mOR() throws RecognitionException {
        try {
            int _type = OR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:417:3: ( 'or' )
            // RLexer.g:417:5: 'or'
            {
            match("or"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "OR"

    // $ANTLR start "OTHERWISE"
    public final void mOTHERWISE() throws RecognitionException {
        try {
            int _type = OTHERWISE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:421:3: ( 'otherwise' )
            // RLexer.g:421:5: 'otherwise'
            {
            match("otherwise"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "OTHERWISE"

    // $ANTLR start "PERF_FINAL"
    public final void mPERF_FINAL() throws RecognitionException {
        try {
            int _type = PERF_FINAL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:425:3: ( 'perf_finalization' )
            // RLexer.g:425:5: 'perf_finalization'
            {
            match("perf_finalization"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "PERF_FINAL"

    // $ANTLR start "PERF_INIT"
    public final void mPERF_INIT() throws RecognitionException {
        try {
            int _type = PERF_INIT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:429:3: ( 'perf_initialization' )
            // RLexer.g:429:5: 'perf_initialization'
            {
            match("perf_initialization"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "PERF_INIT"

    // $ANTLR start "PONENS"
    public final void mPONENS() throws RecognitionException {
        try {
            int _type = PONENS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:433:3: ( 'ponens' )
            // RLexer.g:433:5: 'ponens'
            {
            match("ponens"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "PONENS"

    // $ANTLR start "PRESERVES"
    public final void mPRESERVES() throws RecognitionException {
        try {
            int _type = PRESERVES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:441:3: ( 'preserves' | 'pres' )
            int alt15=2;
            int LA15_0 = input.LA(1);

            if ( (LA15_0=='p') ) {
                int LA15_1 = input.LA(2);

                if ( (LA15_1=='r') ) {
                    int LA15_2 = input.LA(3);

                    if ( (LA15_2=='e') ) {
                        int LA15_3 = input.LA(4);

                        if ( (LA15_3=='s') ) {
                            int LA15_4 = input.LA(5);

                            if ( (LA15_4=='e') ) {
                                alt15=1;
                            }
                            else {
                                alt15=2;}
                        }
                        else {
                            if (state.backtracking>0) {state.failed=true; return ;}
                            NoViableAltException nvae =
                                new NoViableAltException("", 15, 3, input);

                            throw nvae;
                        }
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 15, 2, input);

                        throw nvae;
                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 15, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 15, 0, input);

                throw nvae;
            }
            switch (alt15) {
                case 1 :
                    // RLexer.g:441:5: 'preserves'
                    {
                    match("preserves"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:441:19: 'pres'
                    {
                    match("pres"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "PRESERVES"

    // $ANTLR start "PROCEDURE"
    public final void mPROCEDURE() throws RecognitionException {
        try {
            int _type = PROCEDURE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:445:3: ( 'Procedure' | 'Proc' )
            int alt16=2;
            int LA16_0 = input.LA(1);

            if ( (LA16_0=='P') ) {
                int LA16_1 = input.LA(2);

                if ( (LA16_1=='r') ) {
                    int LA16_2 = input.LA(3);

                    if ( (LA16_2=='o') ) {
                        int LA16_3 = input.LA(4);

                        if ( (LA16_3=='c') ) {
                            int LA16_4 = input.LA(5);

                            if ( (LA16_4=='e') ) {
                                alt16=1;
                            }
                            else {
                                alt16=2;}
                        }
                        else {
                            if (state.backtracking>0) {state.failed=true; return ;}
                            NoViableAltException nvae =
                                new NoViableAltException("", 16, 3, input);

                            throw nvae;
                        }
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 16, 2, input);

                        throw nvae;
                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 16, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 16, 0, input);

                throw nvae;
            }
            switch (alt16) {
                case 1 :
                    // RLexer.g:445:5: 'Procedure'
                    {
                    match("Procedure"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:445:19: 'Proc'
                    {
                    match("Proc"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "PROCEDURE"

    // $ANTLR start "MODULE_PROFILE"
    public final void mMODULE_PROFILE() throws RecognitionException {
        try {
            int _type = MODULE_PROFILE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:449:3: ( 'Profile' | 'profile' )
            int alt17=2;
            int LA17_0 = input.LA(1);

            if ( (LA17_0=='P') ) {
                alt17=1;
            }
            else if ( (LA17_0=='p') ) {
                alt17=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 17, 0, input);

                throw nvae;
            }
            switch (alt17) {
                case 1 :
                    // RLexer.g:449:5: 'Profile'
                    {
                    match("Profile"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:449:17: 'profile'
                    {
                    match("profile"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MODULE_PROFILE"

    // $ANTLR start "PROOF"
    public final void mPROOF() throws RecognitionException {
        try {
            int _type = PROOF;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:453:3: ( 'Proof' | 'proof' )
            int alt18=2;
            int LA18_0 = input.LA(1);

            if ( (LA18_0=='P') ) {
                alt18=1;
            }
            else if ( (LA18_0=='p') ) {
                alt18=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 18, 0, input);

                throw nvae;
            }
            switch (alt18) {
                case 1 :
                    // RLexer.g:453:5: 'Proof'
                    {
                    match("Proof"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:453:15: 'proof'
                    {
                    match("proof"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "PROOF"

    // $ANTLR start "PROOFS_FOR"
    public final void mPROOFS_FOR() throws RecognitionException {
        try {
            int _type = PROOFS_FOR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:457:3: ( 'Proofs_for' )
            // RLexer.g:457:5: 'Proofs_for'
            {
            match("Proofs_for"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "PROOFS_FOR"

    // $ANTLR start "PROPERTY"
    public final void mPROPERTY() throws RecognitionException {
        try {
            int _type = PROPERTY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:461:3: ( 'Property' | 'Pty' )
            int alt19=2;
            int LA19_0 = input.LA(1);

            if ( (LA19_0=='P') ) {
                int LA19_1 = input.LA(2);

                if ( (LA19_1=='r') ) {
                    alt19=1;
                }
                else if ( (LA19_1=='t') ) {
                    alt19=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 19, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 19, 0, input);

                throw nvae;
            }
            switch (alt19) {
                case 1 :
                    // RLexer.g:461:5: 'Property'
                    {
                    match("Property"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:461:18: 'Pty'
                    {
                    match("Pty"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "PROPERTY"

    // $ANTLR start "QED"
    public final void mQED() throws RecognitionException {
        try {
            int _type = QED;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:465:3: ( 'QED' )
            // RLexer.g:465:5: 'QED'
            {
            match("QED"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "QED"

    // $ANTLR start "QUANTIFIER"
    public final void mQUANTIFIER() throws RecognitionException {
        try {
            int _type = QUANTIFIER;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:469:3: ( 'quantifier' )
            // RLexer.g:469:5: 'quantifier'
            {
            match("quantifier"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "QUANTIFIER"

    // $ANTLR start "REALIZATION"
    public final void mREALIZATION() throws RecognitionException {
        try {
            int _type = REALIZATION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:473:3: ( 'realization' )
            // RLexer.g:473:5: 'realization'
            {
            match("realization"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "REALIZATION"

    // $ANTLR start "MODULE_REALIZATION"
    public final void mMODULE_REALIZATION() throws RecognitionException {
        try {
            int _type = MODULE_REALIZATION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:477:3: ( 'Realization' )
            // RLexer.g:477:5: 'Realization'
            {
            match("Realization"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MODULE_REALIZATION"

    // $ANTLR start "REALIZED"
    public final void mREALIZED() throws RecognitionException {
        try {
            int _type = REALIZED;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:481:3: ( 'realized' )
            // RLexer.g:481:5: 'realized'
            {
            match("realized"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "REALIZED"

    // $ANTLR start "REASSIGNS"
    public final void mREASSIGNS() throws RecognitionException {
        try {
            int _type = REASSIGNS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:485:3: ( 'reassigns' | 'res' )
            int alt20=2;
            int LA20_0 = input.LA(1);

            if ( (LA20_0=='r') ) {
                int LA20_1 = input.LA(2);

                if ( (LA20_1=='e') ) {
                    int LA20_2 = input.LA(3);

                    if ( (LA20_2=='a') ) {
                        alt20=1;
                    }
                    else if ( (LA20_2=='s') ) {
                        alt20=2;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 20, 2, input);

                        throw nvae;
                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 20, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 20, 0, input);

                throw nvae;
            }
            switch (alt20) {
                case 1 :
                    // RLexer.g:485:5: 'reassigns'
                    {
                    match("reassigns"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:485:19: 'res'
                    {
                    match("res"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "REASSIGNS"

    // $ANTLR start "RECORD"
    public final void mRECORD() throws RecognitionException {
        try {
            int _type = RECORD;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:489:3: ( 'Record' )
            // RLexer.g:489:5: 'Record'
            {
            match("Record"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "RECORD"

    // $ANTLR start "RECURSIVE"
    public final void mRECURSIVE() throws RecognitionException {
        try {
            int _type = RECURSIVE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:493:3: ( 'Recursive' | 'recursive' )
            int alt21=2;
            int LA21_0 = input.LA(1);

            if ( (LA21_0=='R') ) {
                alt21=1;
            }
            else if ( (LA21_0=='r') ) {
                alt21=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 21, 0, input);

                throw nvae;
            }
            switch (alt21) {
                case 1 :
                    // RLexer.g:493:5: 'Recursive'
                    {
                    match("Recursive"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:493:19: 'recursive'
                    {
                    match("recursive"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "RECURSIVE"

    // $ANTLR start "REDUCTIO"
    public final void mREDUCTIO() throws RecognitionException {
        try {
            int _type = REDUCTIO;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:497:3: ( 'reductio' )
            // RLexer.g:497:5: 'reductio'
            {
            match("reductio"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "REDUCTIO"

    // $ANTLR start "RELATED"
    public final void mRELATED() throws RecognitionException {
        try {
            int _type = RELATED;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:501:3: ( 'related' )
            // RLexer.g:501:5: 'related'
            {
            match("related"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "RELATED"

    // $ANTLR start "REM"
    public final void mREM() throws RecognitionException {
        try {
            int _type = REM;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:505:3: ( 'rem' )
            // RLexer.g:505:5: 'rem'
            {
            match("rem"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "REM"

    // $ANTLR start "REMEMBER"
    public final void mREMEMBER() throws RecognitionException {
        try {
            int _type = REMEMBER;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:509:3: ( 'Remember' )
            // RLexer.g:509:5: 'Remember'
            {
            match("Remember"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "REMEMBER"

    // $ANTLR start "REPEAT"
    public final void mREPEAT() throws RecognitionException {
        try {
            int _type = REPEAT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:513:3: ( 'repeat' )
            // RLexer.g:513:5: 'repeat'
            {
            match("repeat"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "REPEAT"

    // $ANTLR start "REPLACES"
    public final void mREPLACES() throws RecognitionException {
        try {
            int _type = REPLACES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:517:3: ( 'replaces' | 'rpl' )
            int alt22=2;
            int LA22_0 = input.LA(1);

            if ( (LA22_0=='r') ) {
                int LA22_1 = input.LA(2);

                if ( (LA22_1=='e') ) {
                    alt22=1;
                }
                else if ( (LA22_1=='p') ) {
                    alt22=2;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 22, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 22, 0, input);

                throw nvae;
            }
            switch (alt22) {
                case 1 :
                    // RLexer.g:517:5: 'replaces'
                    {
                    match("replaces"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:517:18: 'rpl'
                    {
                    match("rpl"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "REPLACES"

    // $ANTLR start "REPRESENTED"
    public final void mREPRESENTED() throws RecognitionException {
        try {
            int _type = REPRESENTED;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:521:3: ( 'represented' )
            // RLexer.g:521:5: 'represented'
            {
            match("represented"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "REPRESENTED"

    // $ANTLR start "REQUIRES"
    public final void mREQUIRES() throws RecognitionException {
        try {
            int _type = REQUIRES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:525:3: ( 'requires' )
            // RLexer.g:525:5: 'requires'
            {
            match("requires"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "REQUIRES"

    // $ANTLR start "RESPECTS"
    public final void mRESPECTS() throws RecognitionException {
        try {
            int _type = RESPECTS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:529:3: ( 'respects' )
            // RLexer.g:529:5: 'respects'
            {
            match("respects"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "RESPECTS"

    // $ANTLR start "RESTORES"
    public final void mRESTORES() throws RecognitionException {
        try {
            int _type = RESTORES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:533:3: ( 'restores' | 'rest' )
            int alt23=2;
            int LA23_0 = input.LA(1);

            if ( (LA23_0=='r') ) {
                int LA23_1 = input.LA(2);

                if ( (LA23_1=='e') ) {
                    int LA23_2 = input.LA(3);

                    if ( (LA23_2=='s') ) {
                        int LA23_3 = input.LA(4);

                        if ( (LA23_3=='t') ) {
                            int LA23_4 = input.LA(5);

                            if ( (LA23_4=='o') ) {
                                alt23=1;
                            }
                            else {
                                alt23=2;}
                        }
                        else {
                            if (state.backtracking>0) {state.failed=true; return ;}
                            NoViableAltException nvae =
                                new NoViableAltException("", 23, 3, input);

                            throw nvae;
                        }
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 23, 2, input);

                        throw nvae;
                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 23, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 23, 0, input);

                throw nvae;
            }
            switch (alt23) {
                case 1 :
                    // RLexer.g:533:5: 'restores'
                    {
                    match("restores"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:533:18: 'rest'
                    {
                    match("rest"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "RESTORES"

    // $ANTLR start "RULE"
    public final void mRULE() throws RecognitionException {
        try {
            int _type = RULE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:537:3: ( 'rule' )
            // RLexer.g:537:5: 'rule'
            {
            match("rule"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "RULE"

    // $ANTLR start "SELF"
    public final void mSELF() throws RecognitionException {
        try {
            int _type = SELF;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:541:3: ( 'self' )
            // RLexer.g:541:5: 'self'
            {
            match("self"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "SELF"

    // $ANTLR start "SHORT_FOR"
    public final void mSHORT_FOR() throws RecognitionException {
        try {
            int _type = SHORT_FOR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:545:3: ( 'short_for' )
            // RLexer.g:545:5: 'short_for'
            {
            match("short_for"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "SHORT_FOR"

    // $ANTLR start "STATIC"
    public final void mSTATIC() throws RecognitionException {
        try {
            int _type = STATIC;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:549:3: ( 'Static' )
            // RLexer.g:549:5: 'Static'
            {
            match("Static"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "STATIC"

    // $ANTLR start "SUBTYPE"
    public final void mSUBTYPE() throws RecognitionException {
        try {
            int _type = SUBTYPE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:553:3: ( 'Subtype' )
            // RLexer.g:553:5: 'Subtype'
            {
            match("Subtype"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "SUBTYPE"

    // $ANTLR start "SUCH"
    public final void mSUCH() throws RecognitionException {
        try {
            int _type = SUCH;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:557:3: ( 'such' )
            // RLexer.g:557:5: 'such'
            {
            match("such"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "SUCH"

    // $ANTLR start "SUPPOSITION"
    public final void mSUPPOSITION() throws RecognitionException {
        try {
            int _type = SUPPOSITION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:561:3: ( 'Supposition' )
            // RLexer.g:561:5: 'Supposition'
            {
            match("Supposition"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "SUPPOSITION"

    // $ANTLR start "THAT"
    public final void mTHAT() throws RecognitionException {
        try {
            int _type = THAT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:565:3: ( 'that' )
            // RLexer.g:565:5: 'that'
            {
            match("that"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "THAT"

    // $ANTLR start "THEN"
    public final void mTHEN() throws RecognitionException {
        try {
            int _type = THEN;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:569:3: ( 'then' )
            // RLexer.g:569:5: 'then'
            {
            match("then"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "THEN"

    // $ANTLR start "THEOREM"
    public final void mTHEOREM() throws RecognitionException {
        try {
            int _type = THEOREM;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:573:3: ( 'Theorem' )
            // RLexer.g:573:5: 'Theorem'
            {
            match("Theorem"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "THEOREM"

    // $ANTLR start "THEORY"
    public final void mTHEORY() throws RecognitionException {
        try {
            int _type = THEORY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:577:3: ( 'Theory' | 'Precis' )
            int alt24=2;
            int LA24_0 = input.LA(1);

            if ( (LA24_0=='T') ) {
                alt24=1;
            }
            else if ( (LA24_0=='P') ) {
                alt24=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 24, 0, input);

                throw nvae;
            }
            switch (alt24) {
                case 1 :
                    // RLexer.g:577:5: 'Theory'
                    {
                    match("Theory"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:577:16: 'Precis'
                    {
                    match("Precis"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "THEORY"

    // $ANTLR start "THERE"
    public final void mTHERE() throws RecognitionException {
        try {
            int _type = THERE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:581:3: ( 'There' | 'there' )
            int alt25=2;
            int LA25_0 = input.LA(1);

            if ( (LA25_0=='T') ) {
                alt25=1;
            }
            else if ( (LA25_0=='t') ) {
                alt25=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 25, 0, input);

                throw nvae;
            }
            switch (alt25) {
                case 1 :
                    // RLexer.g:581:5: 'There'
                    {
                    match("There"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:581:15: 'there'
                    {
                    match("there"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "THERE"

    // $ANTLR start "TIMES"
    public final void mTIMES() throws RecognitionException {
        try {
            int _type = TIMES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:585:3: ( 'times' )
            // RLexer.g:585:5: 'times'
            {
            match("times"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "TIMES"

    // $ANTLR start "TYPE"
    public final void mTYPE() throws RecognitionException {
        try {
            int _type = TYPE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:589:3: ( 'Type' | 'type' )
            int alt26=2;
            int LA26_0 = input.LA(1);

            if ( (LA26_0=='T') ) {
                alt26=1;
            }
            else if ( (LA26_0=='t') ) {
                alt26=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 26, 0, input);

                throw nvae;
            }
            switch (alt26) {
                case 1 :
                    // RLexer.g:589:5: 'Type'
                    {
                    match("Type"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:589:14: 'type'
                    {
                    match("type"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "TYPE"

    // $ANTLR start "TYPE_FAMILY"
    public final void mTYPE_FAMILY() throws RecognitionException {
        try {
            int _type = TYPE_FAMILY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:593:3: ( 'Type_Family' )
            // RLexer.g:593:5: 'Type_Family'
            {
            match("Type_Family"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "TYPE_FAMILY"

    // $ANTLR start "UNION"
    public final void mUNION() throws RecognitionException {
        try {
            int _type = UNION;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:597:3: ( 'union' )
            // RLexer.g:597:5: 'union'
            {
            match("union"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "UNION"

    // $ANTLR start "UNIQUE"
    public final void mUNIQUE() throws RecognitionException {
        try {
            int _type = UNIQUE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:601:3: ( 'Unique' | 'unique' )
            int alt27=2;
            int LA27_0 = input.LA(1);

            if ( (LA27_0=='U') ) {
                alt27=1;
            }
            else if ( (LA27_0=='u') ) {
                alt27=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 27, 0, input);

                throw nvae;
            }
            switch (alt27) {
                case 1 :
                    // RLexer.g:601:5: 'Unique'
                    {
                    match("Unique"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:601:16: 'unique'
                    {
                    match("unique"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "UNIQUE"

    // $ANTLR start "UNIT"
    public final void mUNIT() throws RecognitionException {
        try {
            int _type = UNIT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:605:3: ( 'Unit' | 'unit' )
            int alt28=2;
            int LA28_0 = input.LA(1);

            if ( (LA28_0=='U') ) {
                alt28=1;
            }
            else if ( (LA28_0=='u') ) {
                alt28=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 28, 0, input);

                throw nvae;
            }
            switch (alt28) {
                case 1 :
                    // RLexer.g:605:5: 'Unit'
                    {
                    match("Unit"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:605:14: 'unit'
                    {
                    match("unit"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "UNIT"

    // $ANTLR start "UNIVERSAL"
    public final void mUNIVERSAL() throws RecognitionException {
        try {
            int _type = UNIVERSAL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:609:3: ( 'universal' )
            // RLexer.g:609:5: 'universal'
            {
            match("universal"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "UNIVERSAL"

    // $ANTLR start "UPDATES"
    public final void mUPDATES() throws RecognitionException {
        try {
            int _type = UPDATES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:613:3: ( 'updates' | 'upd' )
            int alt29=2;
            int LA29_0 = input.LA(1);

            if ( (LA29_0=='u') ) {
                int LA29_1 = input.LA(2);

                if ( (LA29_1=='p') ) {
                    int LA29_2 = input.LA(3);

                    if ( (LA29_2=='d') ) {
                        int LA29_3 = input.LA(4);

                        if ( (LA29_3=='a') ) {
                            alt29=1;
                        }
                        else {
                            alt29=2;}
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 29, 2, input);

                        throw nvae;
                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 29, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 29, 0, input);

                throw nvae;
            }
            switch (alt29) {
                case 1 :
                    // RLexer.g:613:5: 'updates'
                    {
                    match("updates"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:613:17: 'upd'
                    {
                    match("upd"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "UPDATES"

    // $ANTLR start "USES"
    public final void mUSES() throws RecognitionException {
        try {
            int _type = USES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:617:3: ( 'uses' )
            // RLexer.g:617:5: 'uses'
            {
            match("uses"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "USES"

    // $ANTLR start "VAR"
    public final void mVAR() throws RecognitionException {
        try {
            int _type = VAR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:621:3: ( 'Variable' | 'Var' )
            int alt30=2;
            int LA30_0 = input.LA(1);

            if ( (LA30_0=='V') ) {
                int LA30_1 = input.LA(2);

                if ( (LA30_1=='a') ) {
                    int LA30_2 = input.LA(3);

                    if ( (LA30_2=='r') ) {
                        int LA30_3 = input.LA(4);

                        if ( (LA30_3=='i') ) {
                            alt30=1;
                        }
                        else {
                            alt30=2;}
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 30, 2, input);

                        throw nvae;
                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 30, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 30, 0, input);

                throw nvae;
            }
            switch (alt30) {
                case 1 :
                    // RLexer.g:621:5: 'Variable'
                    {
                    match("Variable"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:621:18: 'Var'
                    {
                    match("Var"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "VAR"

    // $ANTLR start "VARIABLES"
    public final void mVARIABLES() throws RecognitionException {
        try {
            int _type = VARIABLES;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:625:3: ( 'Variables' | 'Vars' )
            int alt31=2;
            int LA31_0 = input.LA(1);

            if ( (LA31_0=='V') ) {
                int LA31_1 = input.LA(2);

                if ( (LA31_1=='a') ) {
                    int LA31_2 = input.LA(3);

                    if ( (LA31_2=='r') ) {
                        int LA31_3 = input.LA(4);

                        if ( (LA31_3=='i') ) {
                            alt31=1;
                        }
                        else if ( (LA31_3=='s') ) {
                            alt31=2;
                        }
                        else {
                            if (state.backtracking>0) {state.failed=true; return ;}
                            NoViableAltException nvae =
                                new NoViableAltException("", 31, 3, input);

                            throw nvae;
                        }
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 31, 2, input);

                        throw nvae;
                    }
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 31, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 31, 0, input);

                throw nvae;
            }
            switch (alt31) {
                case 1 :
                    // RLexer.g:625:5: 'Variables'
                    {
                    match("Variables"); if (state.failed) return ;


                    }
                    break;
                case 2 :
                    // RLexer.g:625:19: 'Vars'
                    {
                    match("Vars"); if (state.failed) return ;


                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "VARIABLES"

    // $ANTLR start "WHEN"
    public final void mWHEN() throws RecognitionException {
        try {
            int _type = WHEN;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:629:3: ( 'when' )
            // RLexer.g:629:5: 'when'
            {
            match("when"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "WHEN"

    // $ANTLR start "WHERE"
    public final void mWHERE() throws RecognitionException {
        try {
            int _type = WHERE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:633:3: ( 'where' )
            // RLexer.g:633:5: 'where'
            {
            match("where"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "WHERE"

    // $ANTLR start "WHILE"
    public final void mWHILE() throws RecognitionException {
        try {
            int _type = WHILE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:637:3: ( 'While' )
            // RLexer.g:637:5: 'While'
            {
            match("While"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "WHILE"

    // $ANTLR start "WITHOUT"
    public final void mWITHOUT() throws RecognitionException {
        try {
            int _type = WITHOUT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:641:3: ( 'without' )
            // RLexer.g:641:5: 'without'
            {
            match("without"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "WITHOUT"

    // $ANTLR start "WITH_PROFILE"
    public final void mWITH_PROFILE() throws RecognitionException {
        try {
            int _type = WITH_PROFILE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:645:3: ( 'with_profile' )
            // RLexer.g:645:5: 'with_profile'
            {
            match("with_profile"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "WITH_PROFILE"

    // $ANTLR start "IDENTIFIER"
    public final void mIDENTIFIER() throws RecognitionException {
        try {
            int _type = IDENTIFIER;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:649:3: ( LETTER ( ALPHABETIC )* )
            // RLexer.g:649:5: LETTER ( ALPHABETIC )*
            {
            mLETTER(); if (state.failed) return ;
            // RLexer.g:649:12: ( ALPHABETIC )*
            loop32:
            do {
                int alt32=2;
                int LA32_0 = input.LA(1);

                if ( ((LA32_0>='0' && LA32_0<='9')||(LA32_0>='A' && LA32_0<='Z')||LA32_0=='_'||(LA32_0>='a' && LA32_0<='z')) ) {
                    alt32=1;
                }


                switch (alt32) {
            	case 1 :
            	    // RLexer.g:649:13: ALPHABETIC
            	    {
            	    mALPHABETIC(); if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop32;
                }
            } while (true);


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "IDENTIFIER"

    // $ANTLR start "WS"
    public final void mWS() throws RecognitionException {
        try {
            int _type = WS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:658:5: ( ( ' ' | '\\t' | '\\f' | ( ( '\\r\\n' )=> '\\r\\n' | '\\r' | '\\n' ) ) )
            // RLexer.g:658:7: ( ' ' | '\\t' | '\\f' | ( ( '\\r\\n' )=> '\\r\\n' | '\\r' | '\\n' ) )
            {
            // RLexer.g:658:7: ( ' ' | '\\t' | '\\f' | ( ( '\\r\\n' )=> '\\r\\n' | '\\r' | '\\n' ) )
            int alt34=4;
            switch ( input.LA(1) ) {
            case ' ':
                {
                alt34=1;
                }
                break;
            case '\t':
                {
                alt34=2;
                }
                break;
            case '\f':
                {
                alt34=3;
                }
                break;
            case '\n':
            case '\r':
                {
                alt34=4;
                }
                break;
            default:
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 34, 0, input);

                throw nvae;
            }

            switch (alt34) {
                case 1 :
                    // RLexer.g:658:9: ' '
                    {
                    match(' '); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // RLexer.g:658:15: '\\t'
                    {
                    match('\t'); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // RLexer.g:658:22: '\\f'
                    {
                    match('\f'); if (state.failed) return ;

                    }
                    break;
                case 4 :
                    // RLexer.g:659:11: ( ( '\\r\\n' )=> '\\r\\n' | '\\r' | '\\n' )
                    {
                    // RLexer.g:659:11: ( ( '\\r\\n' )=> '\\r\\n' | '\\r' | '\\n' )
                    int alt33=3;
                    int LA33_0 = input.LA(1);

                    if ( (LA33_0=='\r') ) {
                        int LA33_1 = input.LA(2);

                        if ( (LA33_1=='\n') && (synpred1_RLexer())) {
                            alt33=1;
                        }
                        else {
                            alt33=2;}
                    }
                    else if ( (LA33_0=='\n') ) {
                        alt33=3;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        NoViableAltException nvae =
                            new NoViableAltException("", 33, 0, input);

                        throw nvae;
                    }
                    switch (alt33) {
                        case 1 :
                            // RLexer.g:659:13: ( '\\r\\n' )=> '\\r\\n'
                            {
                            match("\r\n"); if (state.failed) return ;


                            }
                            break;
                        case 2 :
                            // RLexer.g:659:34: '\\r'
                            {
                            match('\r'); if (state.failed) return ;

                            }
                            break;
                        case 3 :
                            // RLexer.g:659:41: '\\n'
                            {
                            match('\n'); if (state.failed) return ;

                            }
                            break;

                    }

                    if ( state.backtracking==0 ) {
                        
                    }

                    }
                    break;

            }

            if ( state.backtracking==0 ) {
               _channel=HIDDEN; 
            }

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "WS"

    // $ANTLR start "SL_COMMENT"
    public final void mSL_COMMENT() throws RecognitionException {
        try {
            int _type = SL_COMMENT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:668:5: ( '--' (~ '\\n' )* '\\n' )
            // RLexer.g:668:8: '--' (~ '\\n' )* '\\n'
            {
            match("--"); if (state.failed) return ;

            // RLexer.g:668:13: (~ '\\n' )*
            loop35:
            do {
                int alt35=2;
                int LA35_0 = input.LA(1);

                if ( ((LA35_0>='\u0000' && LA35_0<='\t')||(LA35_0>='\u000B' && LA35_0<='\uFFFF')) ) {
                    alt35=1;
                }


                switch (alt35) {
            	case 1 :
            	    // RLexer.g:668:14: ~ '\\n'
            	    {
            	    if ( (input.LA(1)>='\u0000' && input.LA(1)<='\t')||(input.LA(1)>='\u000B' && input.LA(1)<='\uFFFF') ) {
            	        input.consume();
            	    state.failed=false;
            	    }
            	    else {
            	        if (state.backtracking>0) {state.failed=true; return ;}
            	        MismatchedSetException mse = new MismatchedSetException(null,input);
            	        recover(mse);
            	        throw mse;}


            	    }
            	    break;

            	default :
            	    break loop35;
                }
            } while (true);

            match('\n'); if (state.failed) return ;
            if ( state.backtracking==0 ) {
               _channel=HIDDEN;  
            }

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "SL_COMMENT"

    // $ANTLR start "ML_COMMENT"
    public final void mML_COMMENT() throws RecognitionException {
        try {
            int _type = ML_COMMENT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:672:5: ( '(*' ( options {greedy=false; } : . )* '*)' )
            // RLexer.g:672:7: '(*' ( options {greedy=false; } : . )* '*)'
            {
            match("(*"); if (state.failed) return ;

            // RLexer.g:672:12: ( options {greedy=false; } : . )*
            loop36:
            do {
                int alt36=2;
                int LA36_0 = input.LA(1);

                if ( (LA36_0=='*') ) {
                    int LA36_1 = input.LA(2);

                    if ( (LA36_1==')') ) {
                        alt36=2;
                    }
                    else if ( ((LA36_1>='\u0000' && LA36_1<='(')||(LA36_1>='*' && LA36_1<='\uFFFF')) ) {
                        alt36=1;
                    }


                }
                else if ( ((LA36_0>='\u0000' && LA36_0<=')')||(LA36_0>='+' && LA36_0<='\uFFFF')) ) {
                    alt36=1;
                }


                switch (alt36) {
            	case 1 :
            	    // RLexer.g:672:39: .
            	    {
            	    matchAny(); if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    break loop36;
                }
            } while (true);

            match("*)"); if (state.failed) return ;

            if ( state.backtracking==0 ) {
              _channel=HIDDEN;
            }

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ML_COMMENT"

    // $ANTLR start "ALPHABETIC"
    public final void mALPHABETIC() throws RecognitionException {
        try {
            // RLexer.g:676:5: ( LETTER | '_' | DIGIT )
            // RLexer.g:
            {
            if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') ) {
                input.consume();
            state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                recover(mse);
                throw mse;}


            }

        }
        finally {
        }
    }
    // $ANTLR end "ALPHABETIC"

    // $ANTLR start "LETTER"
    public final void mLETTER() throws RecognitionException {
        try {
            // RLexer.g:680:5: ( ( 'a' .. 'z' | 'A' .. 'Z' ) )
            // RLexer.g:680:7: ( 'a' .. 'z' | 'A' .. 'Z' )
            {
            if ( (input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z') ) {
                input.consume();
            state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                recover(mse);
                throw mse;}


            }

        }
        finally {
        }
    }
    // $ANTLR end "LETTER"

    // $ANTLR start "DIGIT"
    public final void mDIGIT() throws RecognitionException {
        try {
            // RLexer.g:684:5: ( '0' .. '9' )
            // RLexer.g:684:7: '0' .. '9'
            {
            matchRange('0','9'); if (state.failed) return ;

            }

        }
        finally {
        }
    }
    // $ANTLR end "DIGIT"

    // $ANTLR start "DIGITS"
    public final void mDIGITS() throws RecognitionException {
        try {
            // RLexer.g:688:5: ( ( '0' .. '9' )+ )
            // RLexer.g:688:7: ( '0' .. '9' )+
            {
            // RLexer.g:688:7: ( '0' .. '9' )+
            int cnt37=0;
            loop37:
            do {
                int alt37=2;
                int LA37_0 = input.LA(1);

                if ( ((LA37_0>='0' && LA37_0<='9')) ) {
                    alt37=1;
                }


                switch (alt37) {
            	case 1 :
            	    // RLexer.g:688:8: '0' .. '9'
            	    {
            	    matchRange('0','9'); if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt37 >= 1 ) break loop37;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(37, input);
                        throw eee;
                }
                cnt37++;
            } while (true);


            }

        }
        finally {
        }
    }
    // $ANTLR end "DIGITS"

    // $ANTLR start "REAL"
    public final void mREAL() throws RecognitionException {
        try {
            // RLexer.g:692:5: ( DIGITS DOT DIGITS )
            // RLexer.g:692:7: DIGITS DOT DIGITS
            {
            mDIGITS(); if (state.failed) return ;
            mDOT(); if (state.failed) return ;
            mDIGITS(); if (state.failed) return ;

            }

        }
        finally {
        }
    }
    // $ANTLR end "REAL"

    // $ANTLR start "NUMERIC_LITERAL"
    public final void mNUMERIC_LITERAL() throws RecognitionException {
        try {
            int _type = NUMERIC_LITERAL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:700:5: ( ( DIGITS '..' )=> DIGITS | ( DIGITS '.' ~ '.' )=> REAL | DIGITS )
            int alt38=3;
            int LA38_0 = input.LA(1);

            if ( ((LA38_0>='0' && LA38_0<='9')) ) {
                int LA38_1 = input.LA(2);

                if ( ((LA38_1>='0' && LA38_1<='9')) && (synpred3_RLexer())) {
                    alt38=2;
                }
                else if ( (LA38_1=='.') && (synpred3_RLexer())) {
                    alt38=2;
                }
                else if ( (synpred2_RLexer()) ) {
                    alt38=1;
                }
                else if ( (true) ) {
                    alt38=3;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 38, 1, input);

                    throw nvae;
                }
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 38, 0, input);

                throw nvae;
            }
            switch (alt38) {
                case 1 :
                    // RLexer.g:700:7: ( DIGITS '..' )=> DIGITS
                    {
                    mDIGITS(); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // RLexer.g:701:7: ( DIGITS '.' ~ '.' )=> REAL
                    {
                    mREAL(); if (state.failed) return ;

                    }
                    break;
                case 3 :
                    // RLexer.g:702:7: DIGITS
                    {
                    mDIGITS(); if (state.failed) return ;

                    }
                    break;

            }
            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "NUMERIC_LITERAL"

    // $ANTLR start "CHARACTER_LITERAL"
    public final void mCHARACTER_LITERAL() throws RecognitionException {
        try {
            int _type = CHARACTER_LITERAL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:710:5: ( '\\'' ( ESC | ~ '\\'' ) '\\'' )
            // RLexer.g:710:7: '\\'' ( ESC | ~ '\\'' ) '\\''
            {
            match('\''); if (state.failed) return ;
            // RLexer.g:710:12: ( ESC | ~ '\\'' )
            int alt39=2;
            int LA39_0 = input.LA(1);

            if ( (LA39_0=='\\') ) {
                int LA39_1 = input.LA(2);

                if ( (LA39_1=='\'') ) {
                    int LA39_3 = input.LA(3);

                    if ( (LA39_3=='\'') ) {
                        alt39=1;
                    }
                    else {
                        alt39=2;}
                }
                else if ( (LA39_1=='\"'||LA39_1=='\\'||LA39_1=='b'||LA39_1=='f'||LA39_1=='n'||LA39_1=='r'||LA39_1=='t') ) {
                    alt39=1;
                }
                else {
                    if (state.backtracking>0) {state.failed=true; return ;}
                    NoViableAltException nvae =
                        new NoViableAltException("", 39, 1, input);

                    throw nvae;
                }
            }
            else if ( ((LA39_0>='\u0000' && LA39_0<='&')||(LA39_0>='(' && LA39_0<='[')||(LA39_0>=']' && LA39_0<='\uFFFF')) ) {
                alt39=2;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                NoViableAltException nvae =
                    new NoViableAltException("", 39, 0, input);

                throw nvae;
            }
            switch (alt39) {
                case 1 :
                    // RLexer.g:710:13: ESC
                    {
                    mESC(); if (state.failed) return ;

                    }
                    break;
                case 2 :
                    // RLexer.g:710:19: ~ '\\''
                    {
                    if ( (input.LA(1)>='\u0000' && input.LA(1)<='&')||(input.LA(1)>='(' && input.LA(1)<='\uFFFF') ) {
                        input.consume();
                    state.failed=false;
                    }
                    else {
                        if (state.backtracking>0) {state.failed=true; return ;}
                        MismatchedSetException mse = new MismatchedSetException(null,input);
                        recover(mse);
                        throw mse;}


                    }
                    break;

            }

            match('\''); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CHARACTER_LITERAL"

    // $ANTLR start "DOT"
    public final void mDOT() throws RecognitionException {
        try {
            int _type = DOT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:717:12: ( '.' )
            // RLexer.g:717:14: '.'
            {
            match('.'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DOT"

    // $ANTLR start "COMMA"
    public final void mCOMMA() throws RecognitionException {
        try {
            int _type = COMMA;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:718:12: ( ',' )
            // RLexer.g:718:14: ','
            {
            match(','); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "COMMA"

    // $ANTLR start "LPAREN"
    public final void mLPAREN() throws RecognitionException {
        try {
            int _type = LPAREN;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:719:12: ( '(' )
            // RLexer.g:719:14: '('
            {
            match('('); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "LPAREN"

    // $ANTLR start "RPAREN"
    public final void mRPAREN() throws RecognitionException {
        try {
            int _type = RPAREN;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:720:12: ( ')' )
            // RLexer.g:720:14: ')'
            {
            match(')'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "RPAREN"

    // $ANTLR start "LBRACE"
    public final void mLBRACE() throws RecognitionException {
        try {
            int _type = LBRACE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:721:12: ( '{' )
            // RLexer.g:721:14: '{'
            {
            match('{'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "LBRACE"

    // $ANTLR start "RBRACE"
    public final void mRBRACE() throws RecognitionException {
        try {
            int _type = RBRACE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:722:12: ( '}' )
            // RLexer.g:722:14: '}'
            {
            match('}'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "RBRACE"

    // $ANTLR start "DBL_LBRACE"
    public final void mDBL_LBRACE() throws RecognitionException {
        try {
            int _type = DBL_LBRACE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:723:12: ( '{{' )
            // RLexer.g:723:14: '{{'
            {
            match("{{"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DBL_LBRACE"

    // $ANTLR start "DBL_RBRACE"
    public final void mDBL_RBRACE() throws RecognitionException {
        try {
            int _type = DBL_RBRACE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:724:12: ( '}}' )
            // RLexer.g:724:14: '}}'
            {
            match("}}"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DBL_RBRACE"

    // $ANTLR start "LSQBRACK"
    public final void mLSQBRACK() throws RecognitionException {
        try {
            int _type = LSQBRACK;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:725:12: ( '[' )
            // RLexer.g:725:14: '['
            {
            match('['); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "LSQBRACK"

    // $ANTLR start "RSQBRACK"
    public final void mRSQBRACK() throws RecognitionException {
        try {
            int _type = RSQBRACK;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:726:12: ( ']' )
            // RLexer.g:726:14: ']'
            {
            match(']'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "RSQBRACK"

    // $ANTLR start "HASH"
    public final void mHASH() throws RecognitionException {
        try {
            int _type = HASH;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:727:12: ( '#' )
            // RLexer.g:727:14: '#'
            {
            match('#'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "HASH"

    // $ANTLR start "CARAT"
    public final void mCARAT() throws RecognitionException {
        try {
            int _type = CARAT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:728:12: ( '^' )
            // RLexer.g:728:14: '^'
            {
            match('^'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "CARAT"

    // $ANTLR start "PLUS"
    public final void mPLUS() throws RecognitionException {
        try {
            int _type = PLUS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:730:11: ( '+' )
            // RLexer.g:730:13: '+'
            {
            match('+'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "PLUS"

    // $ANTLR start "MINUS"
    public final void mMINUS() throws RecognitionException {
        try {
            int _type = MINUS;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:731:11: ( '-' )
            // RLexer.g:731:13: '-'
            {
            match('-'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MINUS"

    // $ANTLR start "AMPERSAND"
    public final void mAMPERSAND() throws RecognitionException {
        try {
            int _type = AMPERSAND;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:732:11: ( '&' )
            // RLexer.g:732:13: '&'
            {
            match('&'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "AMPERSAND"

    // $ANTLR start "MULTIPLY"
    public final void mMULTIPLY() throws RecognitionException {
        try {
            int _type = MULTIPLY;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:733:11: ( '*' )
            // RLexer.g:733:13: '*'
            {
            match('*'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "MULTIPLY"

    // $ANTLR start "DIVIDE"
    public final void mDIVIDE() throws RecognitionException {
        try {
            int _type = DIVIDE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:734:11: ( '/' )
            // RLexer.g:734:13: '/'
            {
            match('/'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DIVIDE"

    // $ANTLR start "EXP"
    public final void mEXP() throws RecognitionException {
        try {
            int _type = EXP;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:736:11: ( '**' )
            // RLexer.g:736:13: '**'
            {
            match("**"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "EXP"

    // $ANTLR start "RANGE"
    public final void mRANGE() throws RecognitionException {
        try {
            int _type = RANGE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:737:11: ( '..' )
            // RLexer.g:737:13: '..'
            {
            match(".."); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "RANGE"

    // $ANTLR start "NOT_EQL"
    public final void mNOT_EQL() throws RecognitionException {
        try {
            int _type = NOT_EQL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:739:11: ( '/=' )
            // RLexer.g:739:13: '/='
            {
            match("/="); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "NOT_EQL"

    // $ANTLR start "GT_EQL"
    public final void mGT_EQL() throws RecognitionException {
        try {
            int _type = GT_EQL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:740:11: ( '>=' )
            // RLexer.g:740:13: '>='
            {
            match(">="); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "GT_EQL"

    // $ANTLR start "LT_EQL"
    public final void mLT_EQL() throws RecognitionException {
        try {
            int _type = LT_EQL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:741:11: ( '<=' )
            // RLexer.g:741:13: '<='
            {
            match("<="); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "LT_EQL"

    // $ANTLR start "EQL"
    public final void mEQL() throws RecognitionException {
        try {
            int _type = EQL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:742:11: ( '=' )
            // RLexer.g:742:13: '='
            {
            match('='); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "EQL"

    // $ANTLR start "LT"
    public final void mLT() throws RecognitionException {
        try {
            int _type = LT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:743:11: ( '<' )
            // RLexer.g:743:13: '<'
            {
            match('<'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "LT"

    // $ANTLR start "GT"
    public final void mGT() throws RecognitionException {
        try {
            int _type = GT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:744:11: ( '>' )
            // RLexer.g:744:13: '>'
            {
            match('>'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "GT"

    // $ANTLR start "LL"
    public final void mLL() throws RecognitionException {
        try {
            int _type = LL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:745:11: ( '<<' )
            // RLexer.g:745:13: '<<'
            {
            match("<<"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "LL"

    // $ANTLR start "GG"
    public final void mGG() throws RecognitionException {
        try {
            int _type = GG;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:746:11: ( '>>' )
            // RLexer.g:746:13: '>>'
            {
            match(">>"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "GG"

    // $ANTLR start "FUNCARROW"
    public final void mFUNCARROW() throws RecognitionException {
        try {
            int _type = FUNCARROW;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:747:11: ( '->' )
            // RLexer.g:747:13: '->'
            {
            match("->"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "FUNCARROW"

    // $ANTLR start "COLON"
    public final void mCOLON() throws RecognitionException {
        try {
            int _type = COLON;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:749:11: ( ':' )
            // RLexer.g:749:13: ':'
            {
            match(':'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "COLON"

    // $ANTLR start "SEMICOLON"
    public final void mSEMICOLON() throws RecognitionException {
        try {
            int _type = SEMICOLON;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:750:11: ( ';' )
            // RLexer.g:750:13: ';'
            {
            match(';'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "SEMICOLON"

    // $ANTLR start "SWAP_OP"
    public final void mSWAP_OP() throws RecognitionException {
        try {
            int _type = SWAP_OP;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:751:11: ( ':=:' )
            // RLexer.g:751:13: ':=:'
            {
            match(":=:"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "SWAP_OP"

    // $ANTLR start "ASSIGN_OP"
    public final void mASSIGN_OP() throws RecognitionException {
        try {
            int _type = ASSIGN_OP;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:752:11: ( ':=' )
            // RLexer.g:752:13: ':='
            {
            match(":="); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "ASSIGN_OP"

    // $ANTLR start "BAR"
    public final void mBAR() throws RecognitionException {
        try {
            int _type = BAR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:754:11: ( '|' )
            // RLexer.g:754:13: '|'
            {
            match('|'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "BAR"

    // $ANTLR start "DBL_BAR"
    public final void mDBL_BAR() throws RecognitionException {
        try {
            int _type = DBL_BAR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:755:11: ( '||' )
            // RLexer.g:755:13: '||'
            {
            match("||"); if (state.failed) return ;


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DBL_BAR"

    // $ANTLR start "DQUOTE"
    public final void mDQUOTE() throws RecognitionException {
        try {
            int _type = DQUOTE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:756:11: ( '\"' )
            // RLexer.g:756:13: '\"'
            {
            match('\"'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "DQUOTE"

    // $ANTLR start "TILDE"
    public final void mTILDE() throws RecognitionException {
        try {
            int _type = TILDE;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:757:11: ( '~' )
            // RLexer.g:757:13: '~'
            {
            match('~'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "TILDE"

    // $ANTLR start "STRING_LITERAL"
    public final void mSTRING_LITERAL() throws RecognitionException {
        try {
            int _type = STRING_LITERAL;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:761:5: ( '\"' ( ESC | ~ ( '\"' | '\\\\' ) )* '\"' )
            // RLexer.g:761:7: '\"' ( ESC | ~ ( '\"' | '\\\\' ) )* '\"'
            {
            match('\"'); if (state.failed) return ;
            // RLexer.g:761:11: ( ESC | ~ ( '\"' | '\\\\' ) )*
            loop40:
            do {
                int alt40=3;
                int LA40_0 = input.LA(1);

                if ( (LA40_0=='\\') ) {
                    alt40=1;
                }
                else if ( ((LA40_0>='\u0000' && LA40_0<='!')||(LA40_0>='#' && LA40_0<='[')||(LA40_0>=']' && LA40_0<='\uFFFF')) ) {
                    alt40=2;
                }


                switch (alt40) {
            	case 1 :
            	    // RLexer.g:761:12: ESC
            	    {
            	    mESC(); if (state.failed) return ;

            	    }
            	    break;
            	case 2 :
            	    // RLexer.g:761:16: ~ ( '\"' | '\\\\' )
            	    {
            	    if ( (input.LA(1)>='\u0000' && input.LA(1)<='!')||(input.LA(1)>='#' && input.LA(1)<='[')||(input.LA(1)>=']' && input.LA(1)<='\uFFFF') ) {
            	        input.consume();
            	    state.failed=false;
            	    }
            	    else {
            	        if (state.backtracking>0) {state.failed=true; return ;}
            	        MismatchedSetException mse = new MismatchedSetException(null,input);
            	        recover(mse);
            	        throw mse;}


            	    }
            	    break;

            	default :
            	    break loop40;
                }
            } while (true);

            match('\"'); if (state.failed) return ;

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "STRING_LITERAL"

    // $ANTLR start "FREE_OPERATOR"
    public final void mFREE_OPERATOR() throws RecognitionException {
        try {
            int _type = FREE_OPERATOR;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // RLexer.g:767:5: ( '@' ( USABLE )+ ( DOT ( USABLE )+ )? )
            // RLexer.g:767:7: '@' ( USABLE )+ ( DOT ( USABLE )+ )?
            {
            match('@'); if (state.failed) return ;
            // RLexer.g:767:11: ( USABLE )+
            int cnt41=0;
            loop41:
            do {
                int alt41=2;
                int LA41_0 = input.LA(1);

                if ( (LA41_0=='!'||(LA41_0>='#' && LA41_0<='&')||(LA41_0>='(' && LA41_0<='-')||(LA41_0>='/' && LA41_0<='_')||(LA41_0>='a' && LA41_0<='{')||(LA41_0>='}' && LA41_0<='~')) ) {
                    alt41=1;
                }


                switch (alt41) {
            	case 1 :
            	    // RLexer.g:767:12: USABLE
            	    {
            	    mUSABLE(); if (state.failed) return ;

            	    }
            	    break;

            	default :
            	    if ( cnt41 >= 1 ) break loop41;
            	    if (state.backtracking>0) {state.failed=true; return ;}
                        EarlyExitException eee =
                            new EarlyExitException(41, input);
                        throw eee;
                }
                cnt41++;
            } while (true);

            // RLexer.g:767:21: ( DOT ( USABLE )+ )?
            int alt43=2;
            int LA43_0 = input.LA(1);

            if ( (LA43_0=='.') ) {
                alt43=1;
            }
            switch (alt43) {
                case 1 :
                    // RLexer.g:767:22: DOT ( USABLE )+
                    {
                    mDOT(); if (state.failed) return ;
                    // RLexer.g:767:26: ( USABLE )+
                    int cnt42=0;
                    loop42:
                    do {
                        int alt42=2;
                        int LA42_0 = input.LA(1);

                        if ( (LA42_0=='!'||(LA42_0>='#' && LA42_0<='&')||(LA42_0>='(' && LA42_0<='-')||(LA42_0>='/' && LA42_0<='_')||(LA42_0>='a' && LA42_0<='{')||(LA42_0>='}' && LA42_0<='~')) ) {
                            alt42=1;
                        }


                        switch (alt42) {
                    	case 1 :
                    	    // RLexer.g:767:27: USABLE
                    	    {
                    	    mUSABLE(); if (state.failed) return ;

                    	    }
                    	    break;

                    	default :
                    	    if ( cnt42 >= 1 ) break loop42;
                    	    if (state.backtracking>0) {state.failed=true; return ;}
                                EarlyExitException eee =
                                    new EarlyExitException(42, input);
                                throw eee;
                        }
                        cnt42++;
                    } while (true);


                    }
                    break;

            }


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }
    // $ANTLR end "FREE_OPERATOR"

    // $ANTLR start "USABLE"
    public final void mUSABLE() throws RecognitionException {
        try {
            // RLexer.g:771:5: ( ( ALPHABETIC | REQUIRED_SYMBOLIC ) )
            // RLexer.g:771:7: ( ALPHABETIC | REQUIRED_SYMBOLIC )
            {
            if ( input.LA(1)=='!'||(input.LA(1)>='#' && input.LA(1)<='&')||(input.LA(1)>='(' && input.LA(1)<='-')||(input.LA(1)>='/' && input.LA(1)<='_')||(input.LA(1)>='a' && input.LA(1)<='{')||(input.LA(1)>='}' && input.LA(1)<='~') ) {
                input.consume();
            state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                recover(mse);
                throw mse;}


            }

        }
        finally {
        }
    }
    // $ANTLR end "USABLE"

    // $ANTLR start "REQUIRED_SYMBOLIC"
    public final void mREQUIRED_SYMBOLIC() throws RecognitionException {
        try {
            // RLexer.g:775:5: ( '~' | '!' | '#' | '$' | '%' | '^' | '&' | '(' | ')' | '-' | '+' | '*' | ',' | '/' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | '[' | '\\\\' | ']' | '{' | '}' )
            // RLexer.g:
            {
            if ( input.LA(1)=='!'||(input.LA(1)>='#' && input.LA(1)<='&')||(input.LA(1)>='(' && input.LA(1)<='-')||input.LA(1)=='/'||(input.LA(1)>=':' && input.LA(1)<='@')||(input.LA(1)>='[' && input.LA(1)<='^')||input.LA(1)=='{'||(input.LA(1)>='}' && input.LA(1)<='~') ) {
                input.consume();
            state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                recover(mse);
                throw mse;}


            }

        }
        finally {
        }
    }
    // $ANTLR end "REQUIRED_SYMBOLIC"

    // $ANTLR start "ESC"
    public final void mESC() throws RecognitionException {
        try {
            // RLexer.g:785:5: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\\'' | '\"' | '\\\\' ) )
            // RLexer.g:785:7: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\\'' | '\"' | '\\\\' )
            {
            match('\\'); if (state.failed) return ;
            if ( input.LA(1)=='\"'||input.LA(1)=='\''||input.LA(1)=='\\'||input.LA(1)=='b'||input.LA(1)=='f'||input.LA(1)=='n'||input.LA(1)=='r'||input.LA(1)=='t' ) {
                input.consume();
            state.failed=false;
            }
            else {
                if (state.backtracking>0) {state.failed=true; return ;}
                MismatchedSetException mse = new MismatchedSetException(null,input);
                recover(mse);
                throw mse;}


            }

        }
        finally {
        }
    }
    // $ANTLR end "ESC"

    public void mTokens() throws RecognitionException {
        // RLexer.g:1:8: ( ABS | AD | ABSURDUM | ALL | ALTERS | ALTERNATIVE | AND | ARRAY | ASSUME | AUX_CODE | AUX_VAR | AUX_VARS | AUXILIARY | AXIOM | BOOLEAN | BASECASE | BY | CARTPROD | CATEGORICAL | CASE | CHANGING | CLEARS | COMMON | CONCLUSION | COMMUTATIVITY | COMPLEMENT | CONCEPT | MODULE_CONCEPT | CONFIRM | CONJUNCT | CONSTRAINT | CONTRADICTION | CONVENTION | COROLLARY | CORR | DECREASING | DEDUCTION | DEFINES | DEFINITION | DISTRIBUTION | DIV | DO | DURATION | ELAPSED_TIME | ELSE | ELIMINATION | END | ENHANCED | ENHANCEMENT | MODULE_ENHANCEMENT | ENSURES | EQUALITY | EVALUATES | EXCLUDED | EXEMPLAR | EXISTENTIAL | EXISTS | EXIT | FACILITY | FAC_FINAL | FAC_INIT | FAMILY | FINALIZATION | FROM | FOR | FORGET | GENERALIZATION | IF | IFF | IMPLICIT | IMPLIES | INDUCTIVE | INDUCTIVECASE | INITIALIZATION | INSTANTIATION | INTERSECT | INTRODUCES | IS | IN | NOT_IN | NOT_PROP_SUBSET | NOT_SUBSET | NOT_SUBSTR | PROP_SUBSET | SUBSET | SUBSTR | ITERATE | LAMBDA | LEMMA | LOCAL | MAINP_DISP | MAINTAINING | MATH | MIDDLE | MOD | MODELED | MODUS | NOT | CAT | OF | OPERATION | OR | OTHERWISE | PERF_FINAL | PERF_INIT | PONENS | PRESERVES | PROCEDURE | MODULE_PROFILE | PROOF | PROOFS_FOR | PROPERTY | QED | QUANTIFIER | REALIZATION | MODULE_REALIZATION | REALIZED | REASSIGNS | RECORD | RECURSIVE | REDUCTIO | RELATED | REM | REMEMBER | REPEAT | REPLACES | REPRESENTED | REQUIRES | RESPECTS | RESTORES | RULE | SELF | SHORT_FOR | STATIC | SUBTYPE | SUCH | SUPPOSITION | THAT | THEN | THEOREM | THEORY | THERE | TIMES | TYPE | TYPE_FAMILY | UNION | UNIQUE | UNIT | UNIVERSAL | UPDATES | USES | VAR | VARIABLES | WHEN | WHERE | WHILE | WITHOUT | WITH_PROFILE | IDENTIFIER | WS | SL_COMMENT | ML_COMMENT | NUMERIC_LITERAL | CHARACTER_LITERAL | DOT | COMMA | LPAREN | RPAREN | LBRACE | RBRACE | DBL_LBRACE | DBL_RBRACE | LSQBRACK | RSQBRACK | HASH | CARAT | PLUS | MINUS | AMPERSAND | MULTIPLY | DIVIDE | EXP | RANGE | NOT_EQL | GT_EQL | LT_EQL | EQL | LT | GT | LL | GG | FUNCARROW | COLON | SEMICOLON | SWAP_OP | ASSIGN_OP | BAR | DBL_BAR | DQUOTE | TILDE | STRING_LITERAL | FREE_OPERATOR )
        int alt44=202;
        alt44 = dfa44.predict(input);
        switch (alt44) {
            case 1 :
                // RLexer.g:1:10: ABS
                {
                mABS(); if (state.failed) return ;

                }
                break;
            case 2 :
                // RLexer.g:1:14: AD
                {
                mAD(); if (state.failed) return ;

                }
                break;
            case 3 :
                // RLexer.g:1:17: ABSURDUM
                {
                mABSURDUM(); if (state.failed) return ;

                }
                break;
            case 4 :
                // RLexer.g:1:26: ALL
                {
                mALL(); if (state.failed) return ;

                }
                break;
            case 5 :
                // RLexer.g:1:30: ALTERS
                {
                mALTERS(); if (state.failed) return ;

                }
                break;
            case 6 :
                // RLexer.g:1:37: ALTERNATIVE
                {
                mALTERNATIVE(); if (state.failed) return ;

                }
                break;
            case 7 :
                // RLexer.g:1:49: AND
                {
                mAND(); if (state.failed) return ;

                }
                break;
            case 8 :
                // RLexer.g:1:53: ARRAY
                {
                mARRAY(); if (state.failed) return ;

                }
                break;
            case 9 :
                // RLexer.g:1:59: ASSUME
                {
                mASSUME(); if (state.failed) return ;

                }
                break;
            case 10 :
                // RLexer.g:1:66: AUX_CODE
                {
                mAUX_CODE(); if (state.failed) return ;

                }
                break;
            case 11 :
                // RLexer.g:1:75: AUX_VAR
                {
                mAUX_VAR(); if (state.failed) return ;

                }
                break;
            case 12 :
                // RLexer.g:1:83: AUX_VARS
                {
                mAUX_VARS(); if (state.failed) return ;

                }
                break;
            case 13 :
                // RLexer.g:1:92: AUXILIARY
                {
                mAUXILIARY(); if (state.failed) return ;

                }
                break;
            case 14 :
                // RLexer.g:1:102: AXIOM
                {
                mAXIOM(); if (state.failed) return ;

                }
                break;
            case 15 :
                // RLexer.g:1:108: BOOLEAN
                {
                mBOOLEAN(); if (state.failed) return ;

                }
                break;
            case 16 :
                // RLexer.g:1:116: BASECASE
                {
                mBASECASE(); if (state.failed) return ;

                }
                break;
            case 17 :
                // RLexer.g:1:125: BY
                {
                mBY(); if (state.failed) return ;

                }
                break;
            case 18 :
                // RLexer.g:1:128: CARTPROD
                {
                mCARTPROD(); if (state.failed) return ;

                }
                break;
            case 19 :
                // RLexer.g:1:137: CATEGORICAL
                {
                mCATEGORICAL(); if (state.failed) return ;

                }
                break;
            case 20 :
                // RLexer.g:1:149: CASE
                {
                mCASE(); if (state.failed) return ;

                }
                break;
            case 21 :
                // RLexer.g:1:154: CHANGING
                {
                mCHANGING(); if (state.failed) return ;

                }
                break;
            case 22 :
                // RLexer.g:1:163: CLEARS
                {
                mCLEARS(); if (state.failed) return ;

                }
                break;
            case 23 :
                // RLexer.g:1:170: COMMON
                {
                mCOMMON(); if (state.failed) return ;

                }
                break;
            case 24 :
                // RLexer.g:1:177: CONCLUSION
                {
                mCONCLUSION(); if (state.failed) return ;

                }
                break;
            case 25 :
                // RLexer.g:1:188: COMMUTATIVITY
                {
                mCOMMUTATIVITY(); if (state.failed) return ;

                }
                break;
            case 26 :
                // RLexer.g:1:202: COMPLEMENT
                {
                mCOMPLEMENT(); if (state.failed) return ;

                }
                break;
            case 27 :
                // RLexer.g:1:213: CONCEPT
                {
                mCONCEPT(); if (state.failed) return ;

                }
                break;
            case 28 :
                // RLexer.g:1:221: MODULE_CONCEPT
                {
                mMODULE_CONCEPT(); if (state.failed) return ;

                }
                break;
            case 29 :
                // RLexer.g:1:236: CONFIRM
                {
                mCONFIRM(); if (state.failed) return ;

                }
                break;
            case 30 :
                // RLexer.g:1:244: CONJUNCT
                {
                mCONJUNCT(); if (state.failed) return ;

                }
                break;
            case 31 :
                // RLexer.g:1:253: CONSTRAINT
                {
                mCONSTRAINT(); if (state.failed) return ;

                }
                break;
            case 32 :
                // RLexer.g:1:264: CONTRADICTION
                {
                mCONTRADICTION(); if (state.failed) return ;

                }
                break;
            case 33 :
                // RLexer.g:1:278: CONVENTION
                {
                mCONVENTION(); if (state.failed) return ;

                }
                break;
            case 34 :
                // RLexer.g:1:289: COROLLARY
                {
                mCOROLLARY(); if (state.failed) return ;

                }
                break;
            case 35 :
                // RLexer.g:1:299: CORR
                {
                mCORR(); if (state.failed) return ;

                }
                break;
            case 36 :
                // RLexer.g:1:304: DECREASING
                {
                mDECREASING(); if (state.failed) return ;

                }
                break;
            case 37 :
                // RLexer.g:1:315: DEDUCTION
                {
                mDEDUCTION(); if (state.failed) return ;

                }
                break;
            case 38 :
                // RLexer.g:1:325: DEFINES
                {
                mDEFINES(); if (state.failed) return ;

                }
                break;
            case 39 :
                // RLexer.g:1:333: DEFINITION
                {
                mDEFINITION(); if (state.failed) return ;

                }
                break;
            case 40 :
                // RLexer.g:1:344: DISTRIBUTION
                {
                mDISTRIBUTION(); if (state.failed) return ;

                }
                break;
            case 41 :
                // RLexer.g:1:357: DIV
                {
                mDIV(); if (state.failed) return ;

                }
                break;
            case 42 :
                // RLexer.g:1:361: DO
                {
                mDO(); if (state.failed) return ;

                }
                break;
            case 43 :
                // RLexer.g:1:364: DURATION
                {
                mDURATION(); if (state.failed) return ;

                }
                break;
            case 44 :
                // RLexer.g:1:373: ELAPSED_TIME
                {
                mELAPSED_TIME(); if (state.failed) return ;

                }
                break;
            case 45 :
                // RLexer.g:1:386: ELSE
                {
                mELSE(); if (state.failed) return ;

                }
                break;
            case 46 :
                // RLexer.g:1:391: ELIMINATION
                {
                mELIMINATION(); if (state.failed) return ;

                }
                break;
            case 47 :
                // RLexer.g:1:403: END
                {
                mEND(); if (state.failed) return ;

                }
                break;
            case 48 :
                // RLexer.g:1:407: ENHANCED
                {
                mENHANCED(); if (state.failed) return ;

                }
                break;
            case 49 :
                // RLexer.g:1:416: ENHANCEMENT
                {
                mENHANCEMENT(); if (state.failed) return ;

                }
                break;
            case 50 :
                // RLexer.g:1:428: MODULE_ENHANCEMENT
                {
                mMODULE_ENHANCEMENT(); if (state.failed) return ;

                }
                break;
            case 51 :
                // RLexer.g:1:447: ENSURES
                {
                mENSURES(); if (state.failed) return ;

                }
                break;
            case 52 :
                // RLexer.g:1:455: EQUALITY
                {
                mEQUALITY(); if (state.failed) return ;

                }
                break;
            case 53 :
                // RLexer.g:1:464: EVALUATES
                {
                mEVALUATES(); if (state.failed) return ;

                }
                break;
            case 54 :
                // RLexer.g:1:474: EXCLUDED
                {
                mEXCLUDED(); if (state.failed) return ;

                }
                break;
            case 55 :
                // RLexer.g:1:483: EXEMPLAR
                {
                mEXEMPLAR(); if (state.failed) return ;

                }
                break;
            case 56 :
                // RLexer.g:1:492: EXISTENTIAL
                {
                mEXISTENTIAL(); if (state.failed) return ;

                }
                break;
            case 57 :
                // RLexer.g:1:504: EXISTS
                {
                mEXISTS(); if (state.failed) return ;

                }
                break;
            case 58 :
                // RLexer.g:1:511: EXIT
                {
                mEXIT(); if (state.failed) return ;

                }
                break;
            case 59 :
                // RLexer.g:1:516: FACILITY
                {
                mFACILITY(); if (state.failed) return ;

                }
                break;
            case 60 :
                // RLexer.g:1:525: FAC_FINAL
                {
                mFAC_FINAL(); if (state.failed) return ;

                }
                break;
            case 61 :
                // RLexer.g:1:535: FAC_INIT
                {
                mFAC_INIT(); if (state.failed) return ;

                }
                break;
            case 62 :
                // RLexer.g:1:544: FAMILY
                {
                mFAMILY(); if (state.failed) return ;

                }
                break;
            case 63 :
                // RLexer.g:1:551: FINALIZATION
                {
                mFINALIZATION(); if (state.failed) return ;

                }
                break;
            case 64 :
                // RLexer.g:1:564: FROM
                {
                mFROM(); if (state.failed) return ;

                }
                break;
            case 65 :
                // RLexer.g:1:569: FOR
                {
                mFOR(); if (state.failed) return ;

                }
                break;
            case 66 :
                // RLexer.g:1:573: FORGET
                {
                mFORGET(); if (state.failed) return ;

                }
                break;
            case 67 :
                // RLexer.g:1:580: GENERALIZATION
                {
                mGENERALIZATION(); if (state.failed) return ;

                }
                break;
            case 68 :
                // RLexer.g:1:595: IF
                {
                mIF(); if (state.failed) return ;

                }
                break;
            case 69 :
                // RLexer.g:1:598: IFF
                {
                mIFF(); if (state.failed) return ;

                }
                break;
            case 70 :
                // RLexer.g:1:602: IMPLICIT
                {
                mIMPLICIT(); if (state.failed) return ;

                }
                break;
            case 71 :
                // RLexer.g:1:611: IMPLIES
                {
                mIMPLIES(); if (state.failed) return ;

                }
                break;
            case 72 :
                // RLexer.g:1:619: INDUCTIVE
                {
                mINDUCTIVE(); if (state.failed) return ;

                }
                break;
            case 73 :
                // RLexer.g:1:629: INDUCTIVECASE
                {
                mINDUCTIVECASE(); if (state.failed) return ;

                }
                break;
            case 74 :
                // RLexer.g:1:643: INITIALIZATION
                {
                mINITIALIZATION(); if (state.failed) return ;

                }
                break;
            case 75 :
                // RLexer.g:1:658: INSTANTIATION
                {
                mINSTANTIATION(); if (state.failed) return ;

                }
                break;
            case 76 :
                // RLexer.g:1:672: INTERSECT
                {
                mINTERSECT(); if (state.failed) return ;

                }
                break;
            case 77 :
                // RLexer.g:1:682: INTRODUCES
                {
                mINTRODUCES(); if (state.failed) return ;

                }
                break;
            case 78 :
                // RLexer.g:1:693: IS
                {
                mIS(); if (state.failed) return ;

                }
                break;
            case 79 :
                // RLexer.g:1:696: IN
                {
                mIN(); if (state.failed) return ;

                }
                break;
            case 80 :
                // RLexer.g:1:699: NOT_IN
                {
                mNOT_IN(); if (state.failed) return ;

                }
                break;
            case 81 :
                // RLexer.g:1:706: NOT_PROP_SUBSET
                {
                mNOT_PROP_SUBSET(); if (state.failed) return ;

                }
                break;
            case 82 :
                // RLexer.g:1:722: NOT_SUBSET
                {
                mNOT_SUBSET(); if (state.failed) return ;

                }
                break;
            case 83 :
                // RLexer.g:1:733: NOT_SUBSTR
                {
                mNOT_SUBSTR(); if (state.failed) return ;

                }
                break;
            case 84 :
                // RLexer.g:1:744: PROP_SUBSET
                {
                mPROP_SUBSET(); if (state.failed) return ;

                }
                break;
            case 85 :
                // RLexer.g:1:756: SUBSET
                {
                mSUBSET(); if (state.failed) return ;

                }
                break;
            case 86 :
                // RLexer.g:1:763: SUBSTR
                {
                mSUBSTR(); if (state.failed) return ;

                }
                break;
            case 87 :
                // RLexer.g:1:770: ITERATE
                {
                mITERATE(); if (state.failed) return ;

                }
                break;
            case 88 :
                // RLexer.g:1:778: LAMBDA
                {
                mLAMBDA(); if (state.failed) return ;

                }
                break;
            case 89 :
                // RLexer.g:1:785: LEMMA
                {
                mLEMMA(); if (state.failed) return ;

                }
                break;
            case 90 :
                // RLexer.g:1:791: LOCAL
                {
                mLOCAL(); if (state.failed) return ;

                }
                break;
            case 91 :
                // RLexer.g:1:797: MAINP_DISP
                {
                mMAINP_DISP(); if (state.failed) return ;

                }
                break;
            case 92 :
                // RLexer.g:1:808: MAINTAINING
                {
                mMAINTAINING(); if (state.failed) return ;

                }
                break;
            case 93 :
                // RLexer.g:1:820: MATH
                {
                mMATH(); if (state.failed) return ;

                }
                break;
            case 94 :
                // RLexer.g:1:825: MIDDLE
                {
                mMIDDLE(); if (state.failed) return ;

                }
                break;
            case 95 :
                // RLexer.g:1:832: MOD
                {
                mMOD(); if (state.failed) return ;

                }
                break;
            case 96 :
                // RLexer.g:1:836: MODELED
                {
                mMODELED(); if (state.failed) return ;

                }
                break;
            case 97 :
                // RLexer.g:1:844: MODUS
                {
                mMODUS(); if (state.failed) return ;

                }
                break;
            case 98 :
                // RLexer.g:1:850: NOT
                {
                mNOT(); if (state.failed) return ;

                }
                break;
            case 99 :
                // RLexer.g:1:854: CAT
                {
                mCAT(); if (state.failed) return ;

                }
                break;
            case 100 :
                // RLexer.g:1:858: OF
                {
                mOF(); if (state.failed) return ;

                }
                break;
            case 101 :
                // RLexer.g:1:861: OPERATION
                {
                mOPERATION(); if (state.failed) return ;

                }
                break;
            case 102 :
                // RLexer.g:1:871: OR
                {
                mOR(); if (state.failed) return ;

                }
                break;
            case 103 :
                // RLexer.g:1:874: OTHERWISE
                {
                mOTHERWISE(); if (state.failed) return ;

                }
                break;
            case 104 :
                // RLexer.g:1:884: PERF_FINAL
                {
                mPERF_FINAL(); if (state.failed) return ;

                }
                break;
            case 105 :
                // RLexer.g:1:895: PERF_INIT
                {
                mPERF_INIT(); if (state.failed) return ;

                }
                break;
            case 106 :
                // RLexer.g:1:905: PONENS
                {
                mPONENS(); if (state.failed) return ;

                }
                break;
            case 107 :
                // RLexer.g:1:912: PRESERVES
                {
                mPRESERVES(); if (state.failed) return ;

                }
                break;
            case 108 :
                // RLexer.g:1:922: PROCEDURE
                {
                mPROCEDURE(); if (state.failed) return ;

                }
                break;
            case 109 :
                // RLexer.g:1:932: MODULE_PROFILE
                {
                mMODULE_PROFILE(); if (state.failed) return ;

                }
                break;
            case 110 :
                // RLexer.g:1:947: PROOF
                {
                mPROOF(); if (state.failed) return ;

                }
                break;
            case 111 :
                // RLexer.g:1:953: PROOFS_FOR
                {
                mPROOFS_FOR(); if (state.failed) return ;

                }
                break;
            case 112 :
                // RLexer.g:1:964: PROPERTY
                {
                mPROPERTY(); if (state.failed) return ;

                }
                break;
            case 113 :
                // RLexer.g:1:973: QED
                {
                mQED(); if (state.failed) return ;

                }
                break;
            case 114 :
                // RLexer.g:1:977: QUANTIFIER
                {
                mQUANTIFIER(); if (state.failed) return ;

                }
                break;
            case 115 :
                // RLexer.g:1:988: REALIZATION
                {
                mREALIZATION(); if (state.failed) return ;

                }
                break;
            case 116 :
                // RLexer.g:1:1000: MODULE_REALIZATION
                {
                mMODULE_REALIZATION(); if (state.failed) return ;

                }
                break;
            case 117 :
                // RLexer.g:1:1019: REALIZED
                {
                mREALIZED(); if (state.failed) return ;

                }
                break;
            case 118 :
                // RLexer.g:1:1028: REASSIGNS
                {
                mREASSIGNS(); if (state.failed) return ;

                }
                break;
            case 119 :
                // RLexer.g:1:1038: RECORD
                {
                mRECORD(); if (state.failed) return ;

                }
                break;
            case 120 :
                // RLexer.g:1:1045: RECURSIVE
                {
                mRECURSIVE(); if (state.failed) return ;

                }
                break;
            case 121 :
                // RLexer.g:1:1055: REDUCTIO
                {
                mREDUCTIO(); if (state.failed) return ;

                }
                break;
            case 122 :
                // RLexer.g:1:1064: RELATED
                {
                mRELATED(); if (state.failed) return ;

                }
                break;
            case 123 :
                // RLexer.g:1:1072: REM
                {
                mREM(); if (state.failed) return ;

                }
                break;
            case 124 :
                // RLexer.g:1:1076: REMEMBER
                {
                mREMEMBER(); if (state.failed) return ;

                }
                break;
            case 125 :
                // RLexer.g:1:1085: REPEAT
                {
                mREPEAT(); if (state.failed) return ;

                }
                break;
            case 126 :
                // RLexer.g:1:1092: REPLACES
                {
                mREPLACES(); if (state.failed) return ;

                }
                break;
            case 127 :
                // RLexer.g:1:1101: REPRESENTED
                {
                mREPRESENTED(); if (state.failed) return ;

                }
                break;
            case 128 :
                // RLexer.g:1:1113: REQUIRES
                {
                mREQUIRES(); if (state.failed) return ;

                }
                break;
            case 129 :
                // RLexer.g:1:1122: RESPECTS
                {
                mRESPECTS(); if (state.failed) return ;

                }
                break;
            case 130 :
                // RLexer.g:1:1131: RESTORES
                {
                mRESTORES(); if (state.failed) return ;

                }
                break;
            case 131 :
                // RLexer.g:1:1140: RULE
                {
                mRULE(); if (state.failed) return ;

                }
                break;
            case 132 :
                // RLexer.g:1:1145: SELF
                {
                mSELF(); if (state.failed) return ;

                }
                break;
            case 133 :
                // RLexer.g:1:1150: SHORT_FOR
                {
                mSHORT_FOR(); if (state.failed) return ;

                }
                break;
            case 134 :
                // RLexer.g:1:1160: STATIC
                {
                mSTATIC(); if (state.failed) return ;

                }
                break;
            case 135 :
                // RLexer.g:1:1167: SUBTYPE
                {
                mSUBTYPE(); if (state.failed) return ;

                }
                break;
            case 136 :
                // RLexer.g:1:1175: SUCH
                {
                mSUCH(); if (state.failed) return ;

                }
                break;
            case 137 :
                // RLexer.g:1:1180: SUPPOSITION
                {
                mSUPPOSITION(); if (state.failed) return ;

                }
                break;
            case 138 :
                // RLexer.g:1:1192: THAT
                {
                mTHAT(); if (state.failed) return ;

                }
                break;
            case 139 :
                // RLexer.g:1:1197: THEN
                {
                mTHEN(); if (state.failed) return ;

                }
                break;
            case 140 :
                // RLexer.g:1:1202: THEOREM
                {
                mTHEOREM(); if (state.failed) return ;

                }
                break;
            case 141 :
                // RLexer.g:1:1210: THEORY
                {
                mTHEORY(); if (state.failed) return ;

                }
                break;
            case 142 :
                // RLexer.g:1:1217: THERE
                {
                mTHERE(); if (state.failed) return ;

                }
                break;
            case 143 :
                // RLexer.g:1:1223: TIMES
                {
                mTIMES(); if (state.failed) return ;

                }
                break;
            case 144 :
                // RLexer.g:1:1229: TYPE
                {
                mTYPE(); if (state.failed) return ;

                }
                break;
            case 145 :
                // RLexer.g:1:1234: TYPE_FAMILY
                {
                mTYPE_FAMILY(); if (state.failed) return ;

                }
                break;
            case 146 :
                // RLexer.g:1:1246: UNION
                {
                mUNION(); if (state.failed) return ;

                }
                break;
            case 147 :
                // RLexer.g:1:1252: UNIQUE
                {
                mUNIQUE(); if (state.failed) return ;

                }
                break;
            case 148 :
                // RLexer.g:1:1259: UNIT
                {
                mUNIT(); if (state.failed) return ;

                }
                break;
            case 149 :
                // RLexer.g:1:1264: UNIVERSAL
                {
                mUNIVERSAL(); if (state.failed) return ;

                }
                break;
            case 150 :
                // RLexer.g:1:1274: UPDATES
                {
                mUPDATES(); if (state.failed) return ;

                }
                break;
            case 151 :
                // RLexer.g:1:1282: USES
                {
                mUSES(); if (state.failed) return ;

                }
                break;
            case 152 :
                // RLexer.g:1:1287: VAR
                {
                mVAR(); if (state.failed) return ;

                }
                break;
            case 153 :
                // RLexer.g:1:1291: VARIABLES
                {
                mVARIABLES(); if (state.failed) return ;

                }
                break;
            case 154 :
                // RLexer.g:1:1301: WHEN
                {
                mWHEN(); if (state.failed) return ;

                }
                break;
            case 155 :
                // RLexer.g:1:1306: WHERE
                {
                mWHERE(); if (state.failed) return ;

                }
                break;
            case 156 :
                // RLexer.g:1:1312: WHILE
                {
                mWHILE(); if (state.failed) return ;

                }
                break;
            case 157 :
                // RLexer.g:1:1318: WITHOUT
                {
                mWITHOUT(); if (state.failed) return ;

                }
                break;
            case 158 :
                // RLexer.g:1:1326: WITH_PROFILE
                {
                mWITH_PROFILE(); if (state.failed) return ;

                }
                break;
            case 159 :
                // RLexer.g:1:1339: IDENTIFIER
                {
                mIDENTIFIER(); if (state.failed) return ;

                }
                break;
            case 160 :
                // RLexer.g:1:1350: WS
                {
                mWS(); if (state.failed) return ;

                }
                break;
            case 161 :
                // RLexer.g:1:1353: SL_COMMENT
                {
                mSL_COMMENT(); if (state.failed) return ;

                }
                break;
            case 162 :
                // RLexer.g:1:1364: ML_COMMENT
                {
                mML_COMMENT(); if (state.failed) return ;

                }
                break;
            case 163 :
                // RLexer.g:1:1375: NUMERIC_LITERAL
                {
                mNUMERIC_LITERAL(); if (state.failed) return ;

                }
                break;
            case 164 :
                // RLexer.g:1:1391: CHARACTER_LITERAL
                {
                mCHARACTER_LITERAL(); if (state.failed) return ;

                }
                break;
            case 165 :
                // RLexer.g:1:1409: DOT
                {
                mDOT(); if (state.failed) return ;

                }
                break;
            case 166 :
                // RLexer.g:1:1413: COMMA
                {
                mCOMMA(); if (state.failed) return ;

                }
                break;
            case 167 :
                // RLexer.g:1:1419: LPAREN
                {
                mLPAREN(); if (state.failed) return ;

                }
                break;
            case 168 :
                // RLexer.g:1:1426: RPAREN
                {
                mRPAREN(); if (state.failed) return ;

                }
                break;
            case 169 :
                // RLexer.g:1:1433: LBRACE
                {
                mLBRACE(); if (state.failed) return ;

                }
                break;
            case 170 :
                // RLexer.g:1:1440: RBRACE
                {
                mRBRACE(); if (state.failed) return ;

                }
                break;
            case 171 :
                // RLexer.g:1:1447: DBL_LBRACE
                {
                mDBL_LBRACE(); if (state.failed) return ;

                }
                break;
            case 172 :
                // RLexer.g:1:1458: DBL_RBRACE
                {
                mDBL_RBRACE(); if (state.failed) return ;

                }
                break;
            case 173 :
                // RLexer.g:1:1469: LSQBRACK
                {
                mLSQBRACK(); if (state.failed) return ;

                }
                break;
            case 174 :
                // RLexer.g:1:1478: RSQBRACK
                {
                mRSQBRACK(); if (state.failed) return ;

                }
                break;
            case 175 :
                // RLexer.g:1:1487: HASH
                {
                mHASH(); if (state.failed) return ;

                }
                break;
            case 176 :
                // RLexer.g:1:1492: CARAT
                {
                mCARAT(); if (state.failed) return ;

                }
                break;
            case 177 :
                // RLexer.g:1:1498: PLUS
                {
                mPLUS(); if (state.failed) return ;

                }
                break;
            case 178 :
                // RLexer.g:1:1503: MINUS
                {
                mMINUS(); if (state.failed) return ;

                }
                break;
            case 179 :
                // RLexer.g:1:1509: AMPERSAND
                {
                mAMPERSAND(); if (state.failed) return ;

                }
                break;
            case 180 :
                // RLexer.g:1:1519: MULTIPLY
                {
                mMULTIPLY(); if (state.failed) return ;

                }
                break;
            case 181 :
                // RLexer.g:1:1528: DIVIDE
                {
                mDIVIDE(); if (state.failed) return ;

                }
                break;
            case 182 :
                // RLexer.g:1:1535: EXP
                {
                mEXP(); if (state.failed) return ;

                }
                break;
            case 183 :
                // RLexer.g:1:1539: RANGE
                {
                mRANGE(); if (state.failed) return ;

                }
                break;
            case 184 :
                // RLexer.g:1:1545: NOT_EQL
                {
                mNOT_EQL(); if (state.failed) return ;

                }
                break;
            case 185 :
                // RLexer.g:1:1553: GT_EQL
                {
                mGT_EQL(); if (state.failed) return ;

                }
                break;
            case 186 :
                // RLexer.g:1:1560: LT_EQL
                {
                mLT_EQL(); if (state.failed) return ;

                }
                break;
            case 187 :
                // RLexer.g:1:1567: EQL
                {
                mEQL(); if (state.failed) return ;

                }
                break;
            case 188 :
                // RLexer.g:1:1571: LT
                {
                mLT(); if (state.failed) return ;

                }
                break;
            case 189 :
                // RLexer.g:1:1574: GT
                {
                mGT(); if (state.failed) return ;

                }
                break;
            case 190 :
                // RLexer.g:1:1577: LL
                {
                mLL(); if (state.failed) return ;

                }
                break;
            case 191 :
                // RLexer.g:1:1580: GG
                {
                mGG(); if (state.failed) return ;

                }
                break;
            case 192 :
                // RLexer.g:1:1583: FUNCARROW
                {
                mFUNCARROW(); if (state.failed) return ;

                }
                break;
            case 193 :
                // RLexer.g:1:1593: COLON
                {
                mCOLON(); if (state.failed) return ;

                }
                break;
            case 194 :
                // RLexer.g:1:1599: SEMICOLON
                {
                mSEMICOLON(); if (state.failed) return ;

                }
                break;
            case 195 :
                // RLexer.g:1:1609: SWAP_OP
                {
                mSWAP_OP(); if (state.failed) return ;

                }
                break;
            case 196 :
                // RLexer.g:1:1617: ASSIGN_OP
                {
                mASSIGN_OP(); if (state.failed) return ;

                }
                break;
            case 197 :
                // RLexer.g:1:1627: BAR
                {
                mBAR(); if (state.failed) return ;

                }
                break;
            case 198 :
                // RLexer.g:1:1631: DBL_BAR
                {
                mDBL_BAR(); if (state.failed) return ;

                }
                break;
            case 199 :
                // RLexer.g:1:1639: DQUOTE
                {
                mDQUOTE(); if (state.failed) return ;

                }
                break;
            case 200 :
                // RLexer.g:1:1646: TILDE
                {
                mTILDE(); if (state.failed) return ;

                }
                break;
            case 201 :
                // RLexer.g:1:1652: STRING_LITERAL
                {
                mSTRING_LITERAL(); if (state.failed) return ;

                }
                break;
            case 202 :
                // RLexer.g:1:1667: FREE_OPERATOR
                {
                mFREE_OPERATOR(); if (state.failed) return ;

                }
                break;

        }

    }

    // $ANTLR start synpred1_RLexer
    public final void synpred1_RLexer_fragment() throws RecognitionException {   
        // RLexer.g:659:13: ( '\\r\\n' )
        // RLexer.g:659:14: '\\r\\n'
        {
        match("\r\n"); if (state.failed) return ;


        }
    }
    // $ANTLR end synpred1_RLexer

    // $ANTLR start synpred2_RLexer
    public final void synpred2_RLexer_fragment() throws RecognitionException {   
        // RLexer.g:700:7: ( DIGITS '..' )
        // RLexer.g:700:9: DIGITS '..'
        {
        mDIGITS(); if (state.failed) return ;
        match(".."); if (state.failed) return ;


        }
    }
    // $ANTLR end synpred2_RLexer

    // $ANTLR start synpred3_RLexer
    public final void synpred3_RLexer_fragment() throws RecognitionException {   
        // RLexer.g:701:7: ( DIGITS '.' ~ '.' )
        // RLexer.g:701:9: DIGITS '.' ~ '.'
        {
        mDIGITS(); if (state.failed) return ;
        match('.'); if (state.failed) return ;
        if ( (input.LA(1)>='\u0000' && input.LA(1)<='-')||(input.LA(1)>='/' && input.LA(1)<='\uFFFF') ) {
            input.consume();
        state.failed=false;
        }
        else {
            if (state.backtracking>0) {state.failed=true; return ;}
            MismatchedSetException mse = new MismatchedSetException(null,input);
            recover(mse);
            throw mse;}


        }
    }
    // $ANTLR end synpred3_RLexer

    public final boolean synpred3_RLexer() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred3_RLexer_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred2_RLexer() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred2_RLexer_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }
    public final boolean synpred1_RLexer() {
        state.backtracking++;
        int start = input.mark();
        try {
            synpred1_RLexer_fragment(); // can never throw exception
        } catch (RecognitionException re) {
            System.err.println("impossible: "+re);
        }
        boolean success = !state.failed;
        input.rewind(start);
        state.backtracking--;
        state.failed=false;
        return success;
    }


    protected DFA6 dfa6 = new DFA6(this);
    protected DFA7 dfa7 = new DFA7(this);
    protected DFA10 dfa10 = new DFA10(this);
    protected DFA14 dfa14 = new DFA14(this);
    protected DFA44 dfa44 = new DFA44(this);
    static final String DFA6_eotS =
        "\23\uffff\1\26\1\30\4\uffff";
    static final String DFA6_eofS =
        "\31\uffff";
    static final String DFA6_minS =
        "\1\103\2\157\2\156\2\163\2\164\2\162\2\141\2\151\2\156\2\164\2\163"+
        "\4\uffff";
    static final String DFA6_maxS =
        "\1\143\2\157\2\156\2\163\2\164\2\162\2\141\2\151\2\156\2\164\2\163"+
        "\4\uffff";
    static final String DFA6_acceptS =
        "\25\uffff\1\2\1\1\1\4\1\3";
    static final String DFA6_specialS =
        "\31\uffff}>";
    static final String[] DFA6_transitionS = {
            "\1\1\37\uffff\1\2",
            "\1\3",
            "\1\4",
            "\1\5",
            "\1\6",
            "\1\7",
            "\1\10",
            "\1\11",
            "\1\12",
            "\1\13",
            "\1\14",
            "\1\15",
            "\1\16",
            "\1\17",
            "\1\20",
            "\1\21",
            "\1\22",
            "\1\23",
            "\1\24",
            "\1\25",
            "\1\27",
            "",
            "",
            "",
            ""
    };

    static final short[] DFA6_eot = DFA.unpackEncodedString(DFA6_eotS);
    static final short[] DFA6_eof = DFA.unpackEncodedString(DFA6_eofS);
    static final char[] DFA6_min = DFA.unpackEncodedStringToUnsignedChars(DFA6_minS);
    static final char[] DFA6_max = DFA.unpackEncodedStringToUnsignedChars(DFA6_maxS);
    static final short[] DFA6_accept = DFA.unpackEncodedString(DFA6_acceptS);
    static final short[] DFA6_special = DFA.unpackEncodedString(DFA6_specialS);
    static final short[][] DFA6_transition;

    static {
        int numStates = DFA6_transitionS.length;
        DFA6_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA6_transition[i] = DFA.unpackEncodedString(DFA6_transitionS[i]);
        }
    }

    class DFA6 extends DFA {

        public DFA6(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 6;
            this.eot = DFA6_eot;
            this.eof = DFA6_eof;
            this.min = DFA6_min;
            this.max = DFA6_max;
            this.accept = DFA6_accept;
            this.special = DFA6_special;
            this.transition = DFA6_transition;
        }
        public String getDescription() {
            return "132:1: CONSTRAINT : ( 'Constraint' | 'Constraints' | 'constraint' | 'constraints' );";
        }
    }
    static final String DFA7_eotS =
        "\23\uffff\1\26\1\30\4\uffff";
    static final String DFA7_eofS =
        "\31\uffff";
    static final String DFA7_minS =
        "\1\103\2\157\2\156\2\166\2\145\2\156\2\164\2\151\2\157\2\156\2\163"+
        "\4\uffff";
    static final String DFA7_maxS =
        "\1\143\2\157\2\156\2\166\2\145\2\156\2\164\2\151\2\157\2\156\2\163"+
        "\4\uffff";
    static final String DFA7_acceptS =
        "\25\uffff\1\2\1\1\1\4\1\3";
    static final String DFA7_specialS =
        "\31\uffff}>";
    static final String[] DFA7_transitionS = {
            "\1\1\37\uffff\1\2",
            "\1\3",
            "\1\4",
            "\1\5",
            "\1\6",
            "\1\7",
            "\1\10",
            "\1\11",
            "\1\12",
            "\1\13",
            "\1\14",
            "\1\15",
            "\1\16",
            "\1\17",
            "\1\20",
            "\1\21",
            "\1\22",
            "\1\23",
            "\1\24",
            "\1\25",
            "\1\27",
            "",
            "",
            "",
            ""
    };

    static final short[] DFA7_eot = DFA.unpackEncodedString(DFA7_eotS);
    static final short[] DFA7_eof = DFA.unpackEncodedString(DFA7_eofS);
    static final char[] DFA7_min = DFA.unpackEncodedStringToUnsignedChars(DFA7_minS);
    static final char[] DFA7_max = DFA.unpackEncodedStringToUnsignedChars(DFA7_maxS);
    static final short[] DFA7_accept = DFA.unpackEncodedString(DFA7_acceptS);
    static final short[] DFA7_special = DFA.unpackEncodedString(DFA7_specialS);
    static final short[][] DFA7_transition;

    static {
        int numStates = DFA7_transitionS.length;
        DFA7_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA7_transition[i] = DFA.unpackEncodedString(DFA7_transitionS[i]);
        }
    }

    class DFA7 extends DFA {

        public DFA7(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 7;
            this.eot = DFA7_eot;
            this.eof = DFA7_eof;
            this.min = DFA7_min;
            this.max = DFA7_max;
            this.accept = DFA7_accept;
            this.special = DFA7_special;
            this.transition = DFA7_transition;
        }
        public String getDescription() {
            return "140:1: CONVENTION : ( 'Convention' | 'Conventions' | 'convention' | 'conventions' );";
        }
    }
    static final String DFA10_eotS =
        "\5\uffff\1\10\1\12\4\uffff";
    static final String DFA10_eofS =
        "\13\uffff";
    static final String DFA10_minS =
        "\1\104\2\145\2\146\2\151\4\uffff";
    static final String DFA10_maxS =
        "\1\144\2\145\2\146\2\151\4\uffff";
    static final String DFA10_acceptS =
        "\7\uffff\1\3\1\1\1\4\1\2";
    static final String DFA10_specialS =
        "\13\uffff}>";
    static final String[] DFA10_transitionS = {
            "\1\1\37\uffff\1\2",
            "\1\3",
            "\1\4",
            "\1\5",
            "\1\6",
            "\1\7",
            "\1\11",
            "",
            "",
            "",
            ""
    };

    static final short[] DFA10_eot = DFA.unpackEncodedString(DFA10_eotS);
    static final short[] DFA10_eof = DFA.unpackEncodedString(DFA10_eofS);
    static final char[] DFA10_min = DFA.unpackEncodedStringToUnsignedChars(DFA10_minS);
    static final char[] DFA10_max = DFA.unpackEncodedStringToUnsignedChars(DFA10_maxS);
    static final short[] DFA10_accept = DFA.unpackEncodedString(DFA10_acceptS);
    static final short[] DFA10_special = DFA.unpackEncodedString(DFA10_specialS);
    static final short[][] DFA10_transition;

    static {
        int numStates = DFA10_transitionS.length;
        DFA10_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA10_transition[i] = DFA.unpackEncodedString(DFA10_transitionS[i]);
        }
    }

    class DFA10 extends DFA {

        public DFA10(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 10;
            this.eot = DFA10_eot;
            this.eof = DFA10_eof;
            this.min = DFA10_min;
            this.max = DFA10_max;
            this.accept = DFA10_accept;
            this.special = DFA10_special;
            this.transition = DFA10_transition;
        }
        public String getDescription() {
            return "164:1: DEFINITION : ( 'Def' | 'def' | 'Definition' | 'definition' );";
        }
    }
    static final String DFA14_eotS =
        "\7\uffff\1\12\1\14\4\uffff";
    static final String DFA14_eofS =
        "\15\uffff";
    static final String DFA14_minS =
        "\1\117\2\160\2\145\2\162\2\141\4\uffff";
    static final String DFA14_maxS =
        "\1\157\2\160\2\145\2\162\2\141\4\uffff";
    static final String DFA14_acceptS =
        "\11\uffff\1\2\1\1\1\4\1\3";
    static final String DFA14_specialS =
        "\15\uffff}>";
    static final String[] DFA14_transitionS = {
            "\1\2\37\uffff\1\1",
            "\1\3",
            "\1\4",
            "\1\5",
            "\1\6",
            "\1\7",
            "\1\10",
            "\1\11",
            "\1\13",
            "",
            "",
            "",
            ""
    };

    static final short[] DFA14_eot = DFA.unpackEncodedString(DFA14_eotS);
    static final short[] DFA14_eof = DFA.unpackEncodedString(DFA14_eofS);
    static final char[] DFA14_min = DFA.unpackEncodedStringToUnsignedChars(DFA14_minS);
    static final char[] DFA14_max = DFA.unpackEncodedStringToUnsignedChars(DFA14_maxS);
    static final short[] DFA14_accept = DFA.unpackEncodedString(DFA14_acceptS);
    static final short[] DFA14_special = DFA.unpackEncodedString(DFA14_specialS);
    static final short[][] DFA14_transition;

    static {
        int numStates = DFA14_transitionS.length;
        DFA14_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA14_transition[i] = DFA.unpackEncodedString(DFA14_transitionS[i]);
        }
    }

    class DFA14 extends DFA {

        public DFA14(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 14;
            this.eot = DFA14_eot;
            this.eof = DFA14_eof;
            this.min = DFA14_min;
            this.max = DFA14_max;
            this.accept = DFA14_accept;
            this.special = DFA14_special;
            this.transition = DFA14_transition;
        }
        public String getDescription() {
            return "412:1: OPERATION : ( 'oper' | 'operation' | 'Oper' | 'Operation' );";
        }
    }
    static final String DFA44_eotS =
        "\1\uffff\2\46\1\114\22\46\1\174\17\46\2\uffff\1\u009a\1\u009c\2"+
        "\uffff\1\u009e\2\uffff\1\u00a0\1\u00a2\6\uffff\1\u00a4\1\u00a6\1"+
        "\u00a9\1\u00ac\1\uffff\1\u00ae\1\uffff\1\u00b0\1\u00b1\2\uffff\1"+
        "\46\1\u00b4\7\46\1\u00bd\1\uffff\10\46\1\u00bd\7\46\1\u00d7\13\46"+
        "\1\u00eb\2\46\1\u00eb\2\46\1\u00f5\10\46\1\u00fe\1\46\1\u0100\1"+
        "\46\1\uffff\33\46\25\uffff\1\u012a\5\uffff\1\u012c\1\uffff\1\u012d"+
        "\1\u012f\1\u0130\2\46\1\u0135\2\46\1\uffff\3\46\1\u013b\14\46\1"+
        "\u014d\5\46\1\u0159\1\46\1\u015b\1\uffff\2\46\1\u0159\3\46\1\u0162"+
        "\12\46\1\u013b\1\46\1\uffff\3\46\1\u0173\5\46\1\uffff\5\46\1\u0184"+
        "\1\46\1\u0186\1\uffff\1\46\1\uffff\10\46\1\u0194\1\u0195\2\46\1"+
        "\u019b\3\46\1\u019f\2\46\1\u01a4\15\46\1\u01b8\2\46\1\u01be\3\46"+
        "\2\uffff\1\46\2\uffff\1\46\2\uffff\4\46\1\uffff\4\46\1\u01ce\1\uffff"+
        "\1\114\1\u01cf\1\u01d0\2\46\1\u01d3\2\46\1\u01d6\10\46\1\uffff\13"+
        "\46\1\uffff\1\46\1\uffff\4\46\1\u01f0\1\46\1\uffff\3\46\1\u01f6"+
        "\3\46\1\u01fa\10\46\1\uffff\20\46\1\uffff\1\u0214\1\uffff\1\u0216"+
        "\1\46\1\u0216\2\46\1\u021c\2\46\1\u0220\4\46\2\uffff\4\46\1\u022a"+
        "\1\uffff\3\46\1\uffff\4\46\1\uffff\1\u0232\4\46\1\u0237\1\46\1\u0239"+
        "\5\46\1\u01d3\2\46\1\u0242\2\46\1\uffff\1\u0245\1\46\1\u0242\1\46"+
        "\1\u0248\1\uffff\1\u0249\6\46\1\u0252\3\46\1\u0256\1\46\1\114\1"+
        "\46\3\uffff\1\u0259\1\u025a\1\uffff\2\46\1\uffff\31\46\1\uffff\5"+
        "\46\1\uffff\3\46\1\uffff\15\46\1\u028e\4\46\1\u0293\1\u0294\4\46"+
        "\1\u0299\1\uffff\1\46\1\uffff\5\46\1\uffff\1\46\1\u02a2\1\46\1\uffff"+
        "\1\46\1\u02a2\7\46\1\uffff\7\46\1\uffff\4\46\1\uffff\1\46\1\uffff"+
        "\4\46\1\u0259\1\46\1\u02bf\1\46\1\uffff\2\46\1\uffff\2\46\2\uffff"+
        "\1\u02c5\2\46\1\u02c8\1\46\1\u012f\1\46\1\u02cb\1\uffff\3\46\1\uffff"+
        "\2\46\2\uffff\12\46\1\u014d\1\u02db\31\46\1\u02f5\2\46\1\u02f8\1"+
        "\u02f9\11\46\1\uffff\3\46\1\u0306\2\uffff\2\46\1\u0309\1\46\1\uffff"+
        "\5\46\1\u0310\2\46\1\uffff\4\46\1\u0317\10\46\1\u0321\4\46\1\u0326"+
        "\3\46\1\u032a\3\46\1\u0317\1\46\1\uffff\1\u032f\2\46\1\u032f\1\46"+
        "\1\uffff\2\46\1\uffff\2\46\1\uffff\1\46\1\u0339\6\46\1\u0340\1\u0341"+
        "\5\46\1\uffff\2\46\1\u0349\6\46\1\u0350\4\46\1\u0350\4\46\1\u035a"+
        "\5\46\1\uffff\2\46\2\uffff\3\46\1\u0365\1\u0366\7\46\1\uffff\2\46"+
        "\1\uffff\1\u0373\5\46\1\uffff\1\46\1\u037a\1\46\1\u037a\2\46\1\uffff"+
        "\10\46\1\u0386\1\uffff\4\46\1\uffff\3\46\1\uffff\1\u038e\1\46\1"+
        "\u0390\1\46\1\uffff\1\46\1\u01b8\1\46\1\u0394\1\46\1\u0396\1\46"+
        "\1\u0398\1\u0399\1\uffff\6\46\2\uffff\4\46\1\u03a4\2\46\1\uffff"+
        "\1\u03a7\5\46\1\uffff\2\46\1\u03af\4\46\1\u03b4\1\46\1\uffff\1\u03b6"+
        "\1\46\1\u03b8\1\u03b9\2\46\1\u03bd\1\46\1\u03bf\1\46\2\uffff\14"+
        "\46\1\uffff\6\46\1\uffff\2\46\1\u0194\2\46\1\u03d7\1\46\1\u03d9"+
        "\1\u022a\1\46\1\u03db\1\uffff\1\u01a4\1\46\1\u03dd\2\46\1\u03e0"+
        "\1\46\1\uffff\1\46\1\uffff\2\46\1\u01be\1\uffff\1\46\1\uffff\1\46"+
        "\2\uffff\1\u0135\1\u03e8\1\46\1\u03ea\4\46\1\u03ef\1\46\1\uffff"+
        "\2\46\1\uffff\7\46\1\uffff\1\u03fa\3\46\1\uffff\1\46\1\uffff\1\u01f6"+
        "\2\uffff\3\46\1\uffff\1\46\1\uffff\1\u0405\2\46\1\u0408\1\46\1\u040a"+
        "\7\46\1\u0216\1\u0412\1\u0216\2\46\1\u021c\1\u0220\3\46\1\uffff"+
        "\1\u019b\1\uffff\1\u0418\1\uffff\1\46\1\uffff\1\46\1\u0418\1\uffff"+
        "\1\u041b\2\46\1\u041e\1\u0248\2\46\1\uffff\1\46\1\uffff\2\46\1\u0425"+
        "\1\u0427\1\uffff\1\46\1\u0429\1\u042a\1\u0425\1\46\1\u0427\1\46"+
        "\1\u042f\1\u0159\1\46\1\uffff\1\u0159\11\46\1\uffff\2\46\1\uffff"+
        "\1\u043c\1\uffff\5\46\1\u0442\1\46\1\uffff\2\46\1\u0446\1\u0447"+
        "\1\46\1\uffff\2\46\1\uffff\2\46\1\uffff\1\46\1\u044e\1\46\1\u0450"+
        "\1\46\1\u0425\1\uffff\1\u0427\1\uffff\1\46\2\uffff\1\u0425\1\46"+
        "\1\u0427\1\46\1\uffff\2\46\1\u0457\1\u0458\1\u0459\1\u045a\6\46"+
        "\1\uffff\5\46\1\uffff\1\u0467\2\46\2\uffff\1\u046a\1\u046b\1\u046c"+
        "\1\u046d\1\u046e\1\46\1\uffff\1\u0470\1\uffff\4\46\1\u0475\1\u0476"+
        "\4\uffff\12\46\1\u0481\1\46\1\uffff\2\46\5\uffff\1\u0485\1\uffff"+
        "\1\u0486\1\46\1\u0488\1\46\2\uffff\5\46\1\u048f\4\46\1\uffff\3\46"+
        "\2\uffff\1\u0497\1\uffff\1\u0497\2\46\1\u049a\1\u049b\1\u049c\1"+
        "\uffff\7\46\1\uffff\2\46\3\uffff\4\46\1\u04aa\5\46\1\u04b0\2\46"+
        "\1\uffff\5\46\1\uffff\2\46\1\u04ba\6\46\1\uffff\4\46\1\u04c5\1\u04c6"+
        "\1\u04c7\3\46\3\uffff\1\u04cb\2\46\1\uffff\2\46\1\u04d0\1\u04d1"+
        "\2\uffff";
    static final String DFA44_eofS =
        "\u04d2\uffff";
    static final String DFA44_minS =
        "\1\11\1\142\1\162\1\60\1\141\1\150\1\171\1\141\1\150\2\145\1\154"+
        "\1\156\1\141\1\145\2\146\1\141\1\145\2\141\1\157\1\60\1\160\1\145"+
        "\1\162\1\105\1\165\3\145\1\164\1\150\2\156\1\141\2\150\2\uffff\1"+
        "\55\1\52\2\uffff\1\56\2\uffff\1\173\1\175\6\uffff\1\52\2\75\1\74"+
        "\1\uffff\1\75\1\uffff\1\174\1\0\2\uffff\1\163\1\60\1\154\1\144\1"+
        "\163\1\162\1\170\1\151\1\163\1\60\1\uffff\1\154\1\156\1\157\1\162"+
        "\1\165\1\141\1\155\1\160\1\60\1\162\1\155\1\141\1\145\1\155\1\143"+
        "\1\163\1\60\1\162\1\144\1\141\1\144\1\165\1\141\1\143\1\150\1\143"+
        "\1\162\1\156\1\60\1\144\1\145\1\60\1\160\1\151\1\60\2\155\1\143"+
        "\1\151\2\144\2\164\1\60\1\145\1\60\1\150\1\uffff\1\145\1\162\1\156"+
        "\2\145\1\171\1\104\2\141\2\154\1\141\1\154\1\157\1\143\1\141\1\142"+
        "\1\145\1\160\1\151\1\144\1\145\1\151\1\162\1\145\1\164\1\151\25"+
        "\uffff\1\72\5\uffff\1\60\1\uffff\3\60\1\165\1\141\1\60\1\157\1\145"+
        "\1\uffff\1\163\1\141\1\155\1\60\1\145\1\164\1\156\2\145\1\164\2"+
        "\145\1\155\1\143\1\157\1\156\1\60\1\141\1\155\1\143\2\162\1\60\1"+
        "\164\1\60\1\uffff\1\141\1\165\1\60\1\160\1\145\1\155\1\60\1\141"+
        "\1\165\1\141\2\154\1\155\1\163\1\141\2\151\1\60\1\145\1\uffff\1"+
        "\154\1\165\1\162\1\60\1\154\2\164\1\145\1\151\1\uffff\1\142\1\155"+
        "\1\141\1\156\1\144\1\60\1\150\1\60\1\uffff\1\162\1\uffff\1\145\1"+
        "\162\1\146\1\145\1\163\1\146\2\143\2\60\1\156\1\154\1\60\2\165\1"+
        "\141\1\60\1\145\1\165\1\60\1\145\1\154\1\157\1\145\1\146\1\162\1"+
        "\150\2\164\1\160\1\157\1\145\1\157\1\60\1\163\1\161\1\60\1\156\1"+
        "\150\1\154\2\uffff\1\162\2\uffff\1\162\2\uffff\1\155\1\171\1\103"+
        "\1\154\1\uffff\1\155\1\137\1\145\1\154\1\60\1\uffff\3\60\1\145\1"+
        "\163\1\60\1\137\1\147\1\60\1\165\1\145\1\151\1\164\1\145\1\154\1"+
        "\145\1\147\1\uffff\1\162\1\157\1\154\1\145\1\165\1\164\1\162\3\145"+
        "\1\156\1\uffff\1\162\1\uffff\1\164\1\143\1\156\1\163\1\60\1\151"+
        "\1\uffff\1\156\1\162\1\154\1\60\1\165\1\160\1\164\1\60\1\156\2\154"+
        "\1\145\1\162\1\151\1\143\1\141\1\uffff\2\151\1\141\1\162\1\157\1"+
        "\156\1\157\1\162\1\165\1\144\1\141\1\154\1\160\2\154\1\163\1\uffff"+
        "\1\60\1\uffff\1\60\1\162\1\60\1\137\1\156\1\60\1\151\1\146\1\60"+
        "\1\151\1\146\1\145\1\151\2\uffff\1\164\1\151\1\163\1\145\1\60\1"+
        "\uffff\1\162\1\143\1\164\1\uffff\2\141\1\145\1\151\1\uffff\1\60"+
        "\1\151\2\162\1\155\1\60\1\164\1\60\1\151\1\171\1\157\1\162\1\145"+
        "\1\60\1\156\1\165\1\60\1\145\1\164\1\uffff\1\60\1\165\1\60\1\141"+
        "\1\60\1\uffff\1\60\1\145\1\137\1\145\1\144\1\156\1\145\1\60\1\157"+
        "\1\141\1\151\1\60\1\103\1\60\1\151\3\uffff\2\60\1\uffff\1\120\1"+
        "\157\1\uffff\1\164\1\160\2\162\1\156\1\154\1\163\1\151\1\163\1\156"+
        "\1\145\1\165\1\160\1\156\1\162\1\141\1\156\1\163\1\141\1\145\2\151"+
        "\1\164\2\145\1\uffff\1\156\1\143\1\145\1\151\1\141\1\uffff\1\144"+
        "\1\154\1\141\1\uffff\1\143\1\151\1\171\1\164\1\141\1\143\2\164\1"+
        "\145\1\141\1\156\1\163\1\144\1\60\1\164\1\157\1\142\1\141\2\60\1"+
        "\137\1\141\2\145\1\60\1\uffff\1\164\1\uffff\1\167\1\164\1\146\1"+
        "\163\1\162\1\uffff\1\154\1\60\1\144\1\uffff\1\154\1\60\1\162\1\163"+
        "\1\151\1\172\1\151\1\143\1\162\1\uffff\1\163\1\164\1\145\1\164\1"+
        "\143\1\163\1\162\1\uffff\1\172\1\144\1\163\1\142\1\uffff\1\137\1"+
        "\uffff\1\143\1\160\1\163\1\145\1\60\1\106\1\60\1\145\1\uffff\1\162"+
        "\1\145\1\uffff\1\145\1\142\2\uffff\1\60\1\165\1\160\1\60\1\165\1"+
        "\60\1\141\1\60\1\uffff\1\144\1\162\1\141\1\uffff\1\141\1\172\2\uffff"+
        "\2\162\1\141\1\164\1\155\1\141\1\164\1\141\1\160\1\156\2\60\1\155"+
        "\1\163\1\164\1\143\1\141\1\144\1\164\1\160\2\163\1\164\1\142\1\157"+
        "\1\151\1\163\1\164\1\144\1\141\1\145\1\163\2\164\1\145\1\141\1\156"+
        "\1\60\1\145\1\164\2\60\1\154\2\151\1\145\1\163\1\154\1\164\1\145"+
        "\1\165\1\uffff\1\137\1\160\1\163\1\60\2\uffff\1\144\1\151\1\60\1"+
        "\144\1\uffff\4\151\1\156\1\60\1\166\1\145\1\uffff\1\165\1\145\1"+
        "\137\1\164\1\60\1\146\1\141\1\147\1\164\1\145\2\151\1\144\1\60\3"+
        "\145\1\141\1\60\1\151\1\145\1\146\1\60\1\145\1\151\1\155\1\60\1"+
        "\141\1\uffff\1\60\2\163\1\60\1\154\1\uffff\1\164\1\162\1\uffff\1"+
        "\155\1\164\1\uffff\1\145\1\60\1\162\1\163\1\141\1\157\1\151\1\164"+
        "\2\60\2\151\1\162\1\157\1\147\1\uffff\1\145\1\151\1\60\1\164\3\151"+
        "\1\157\1\151\1\60\1\151\1\165\1\156\1\157\1\60\1\151\1\137\1\164"+
        "\1\144\1\60\1\171\1\145\1\144\1\162\1\164\1\uffff\1\155\1\171\2"+
        "\uffff\1\151\1\164\1\166\2\60\2\151\2\143\1\151\2\145\1\uffff\1"+
        "\151\1\156\1\uffff\1\60\1\157\1\163\1\157\1\156\1\151\1\uffff\1"+
        "\145\1\60\1\162\1\60\1\146\1\171\1\uffff\1\151\1\164\1\144\1\156"+
        "\2\163\1\166\1\157\1\60\1\uffff\1\163\1\156\1\163\1\164\1\uffff"+
        "\1\166\1\162\1\157\1\uffff\1\60\1\164\1\60\1\155\1\uffff\1\141\1"+
        "\60\1\145\1\60\1\157\1\60\1\151\2\60\1\uffff\1\171\1\145\1\164\1"+
        "\144\1\143\1\151\2\uffff\1\156\1\157\1\171\1\156\1\60\1\156\1\157"+
        "\1\uffff\1\60\1\156\1\143\1\157\2\156\1\uffff\1\157\1\164\1\60\1"+
        "\156\1\157\1\164\1\151\1\60\1\145\1\uffff\1\60\1\163\2\60\1\151"+
        "\1\145\1\60\1\172\1\60\1\145\2\uffff\1\172\1\141\1\164\1\145\1\156"+
        "\1\162\1\165\1\162\1\164\1\162\1\163\1\151\1\uffff\1\156\1\145\1"+
        "\156\1\141\1\164\1\163\1\uffff\1\145\1\157\1\60\1\145\1\151\1\60"+
        "\1\163\2\60\1\145\1\60\1\uffff\1\60\1\164\1\60\1\151\1\145\1\60"+
        "\1\162\1\uffff\1\151\1\uffff\1\151\1\154\1\60\1\uffff\1\146\1\uffff"+
        "\1\166\2\uffff\2\60\1\151\1\60\1\141\1\166\1\164\1\156\1\60\1\144"+
        "\1\uffff\1\164\1\156\1\uffff\2\164\1\156\1\144\1\147\1\156\1\151"+
        "\1\uffff\1\60\1\156\1\151\1\157\1\uffff\1\156\1\uffff\1\60\2\uffff"+
        "\1\141\1\156\1\106\1\uffff\1\141\1\uffff\1\60\1\141\1\164\1\60\1"+
        "\163\1\60\1\157\1\142\2\137\1\151\1\160\1\156\3\60\1\154\1\151\2"+
        "\60\2\162\1\157\1\uffff\1\60\1\uffff\1\60\1\uffff\1\145\1\uffff"+
        "\1\157\1\60\1\uffff\1\60\1\157\1\154\2\60\1\151\1\145\1\uffff\1"+
        "\157\1\uffff\1\154\1\151\2\60\1\uffff\1\145\3\60\1\151\1\60\1\145"+
        "\2\60\1\157\1\uffff\1\60\1\155\1\156\1\164\1\154\1\164\1\151\1\156"+
        "\1\164\1\143\1\uffff\1\164\1\151\1\uffff\1\60\1\uffff\1\160\2\163"+
        "\1\157\1\156\1\60\1\147\1\uffff\1\151\1\141\2\60\1\156\1\uffff\1"+
        "\144\1\156\1\uffff\1\156\1\171\1\uffff\1\154\1\60\1\156\1\60\1\164"+
        "\1\60\1\uffff\1\60\1\uffff\1\156\2\uffff\1\60\1\157\1\60\1\156\1"+
        "\uffff\1\156\1\145\4\60\1\156\2\151\1\141\1\151\1\157\1\uffff\2"+
        "\145\1\165\1\146\1\147\1\uffff\1\60\1\172\1\154\2\uffff\5\60\1\145"+
        "\1\uffff\1\60\1\uffff\1\171\1\143\1\156\1\143\2\60\4\uffff\1\141"+
        "\1\164\1\157\1\163\1\157\1\156\1\162\1\164\1\162\1\142\1\60\1\137"+
        "\1\uffff\1\141\1\151\5\uffff\1\60\1\uffff\1\60\1\145\1\60\1\145"+
        "\2\uffff\1\154\1\151\1\156\1\145\1\156\1\60\2\137\1\151\1\163\1"+
        "\uffff\1\157\1\164\1\172\2\uffff\1\60\1\uffff\1\60\1\151\1\141\3"+
        "\60\1\uffff\1\163\1\157\1\156\1\145\1\146\1\151\1\141\1\uffff\1"+
        "\172\1\154\3\uffff\1\165\1\146\1\147\1\164\1\60\1\157\1\164\1\141"+
        "\1\151\1\142\1\60\2\137\1\uffff\1\156\1\151\1\164\1\172\1\163\1"+
        "\uffff\2\157\1\60\1\157\1\151\1\141\1\145\2\146\1\uffff\1\156\1"+
        "\157\2\164\3\60\1\156\1\151\1\137\3\uffff\1\60\2\157\1\uffff\1\156"+
        "\1\146\2\60\2\uffff";
    static final String DFA44_maxS =
        "\1\176\1\163\1\170\1\172\1\162\2\171\2\157\1\165\1\145\1\170\1\156"+
        "\1\157\1\145\1\164\1\163\1\141\2\157\1\141\1\157\1\172\1\160\1\162"+
        "\1\164\1\105\2\165\1\145\2\165\1\171\1\163\1\156\1\141\1\151\1\150"+
        "\2\uffff\1\76\1\52\2\uffff\1\56\2\uffff\1\173\1\175\6\uffff\1\52"+
        "\1\75\1\76\1\75\1\uffff\1\75\1\uffff\1\174\1\uffff\2\uffff\1\163"+
        "\1\172\1\164\1\144\1\163\1\162\1\170\1\151\1\163\1\172\1\uffff\1"+
        "\154\1\156\1\157\1\162\1\165\1\145\1\155\1\160\1\172\1\164\1\162"+
        "\1\141\2\162\1\146\1\166\1\172\1\162\1\146\2\163\1\165\1\141\1\151"+
        "\1\150\1\155\1\162\1\156\1\172\1\160\1\145\1\172\1\160\1\164\1\172"+
        "\2\155\1\143\1\151\2\144\2\164\1\172\1\145\1\172\1\150\1\uffff\1"+
        "\145\1\162\1\156\2\157\1\171\1\104\1\141\1\163\2\154\1\155\1\154"+
        "\1\157\1\143\1\141\1\160\1\145\1\160\1\151\1\144\1\145\1\151\1\162"+
        "\1\145\1\164\1\151\25\uffff\1\72\5\uffff\1\172\1\uffff\3\172\1\165"+
        "\1\141\1\172\1\157\1\145\1\uffff\1\163\1\141\1\155\1\172\1\145\1"+
        "\164\1\162\2\145\1\164\2\145\1\155\1\166\1\162\1\156\1\172\1\141"+
        "\1\160\1\166\2\162\1\172\1\164\1\172\1\uffff\1\141\1\165\1\172\1"+
        "\160\1\145\1\155\1\172\1\141\1\165\1\141\2\154\1\155\1\164\1\141"+
        "\2\151\1\172\1\145\1\uffff\1\154\1\165\1\162\1\172\1\154\2\164\1"+
        "\162\1\163\1\uffff\1\142\1\155\1\141\1\156\1\144\1\172\1\150\1\172"+
        "\1\uffff\1\162\1\uffff\1\145\1\162\1\146\1\145\1\163\1\157\1\160"+
        "\1\143\2\172\1\156\1\163\1\172\2\165\1\141\1\172\1\162\1\165\1\172"+
        "\1\145\1\154\1\165\1\145\1\146\1\162\1\150\2\164\1\160\1\162\1\145"+
        "\1\166\1\172\1\163\1\164\1\172\1\162\1\150\1\154\2\uffff\1\162\2"+
        "\uffff\1\162\2\uffff\1\155\1\171\1\126\1\154\1\uffff\1\155\1\137"+
        "\1\145\1\154\1\172\1\uffff\3\172\1\145\1\163\1\172\1\137\1\147\1"+
        "\172\1\165\1\145\1\151\1\164\1\145\1\154\1\145\1\147\1\uffff\1\162"+
        "\1\157\2\154\1\165\1\164\1\162\3\145\1\156\1\uffff\1\162\1\uffff"+
        "\1\164\1\143\1\156\1\163\1\172\1\151\1\uffff\1\156\1\162\1\154\1"+
        "\172\1\165\1\160\1\164\1\172\1\156\2\154\1\145\1\162\1\151\1\143"+
        "\1\141\1\uffff\2\151\1\141\1\162\1\157\1\156\1\157\1\162\1\165\1"+
        "\144\1\141\1\154\1\164\2\154\1\163\1\uffff\1\172\1\uffff\1\172\1"+
        "\162\1\172\1\137\1\156\1\172\1\151\1\146\1\172\1\151\1\146\1\145"+
        "\1\151\2\uffff\1\164\1\151\1\163\1\145\1\172\1\uffff\1\162\1\143"+
        "\1\164\1\uffff\2\141\1\145\1\151\1\uffff\1\172\1\151\2\162\1\155"+
        "\1\172\1\164\1\172\1\151\1\171\1\157\1\162\1\145\1\172\1\156\1\165"+
        "\1\172\1\145\1\164\1\uffff\1\172\1\165\1\172\1\141\1\172\1\uffff"+
        "\1\172\1\145\1\157\1\145\1\144\1\163\1\145\1\172\1\157\1\141\1\151"+
        "\1\172\1\103\1\172\1\151\3\uffff\2\172\1\uffff\1\120\1\157\1\uffff"+
        "\1\164\1\160\2\162\1\156\1\154\1\163\1\151\1\163\1\156\1\145\1\165"+
        "\1\160\1\156\1\162\1\141\1\156\1\163\1\141\3\151\1\164\1\151\1\145"+
        "\1\uffff\1\156\1\143\1\145\1\151\1\141\1\uffff\1\144\1\154\1\163"+
        "\1\uffff\1\143\1\151\1\171\1\164\1\141\1\143\2\164\1\145\1\141\1"+
        "\156\1\163\1\144\1\172\1\164\1\157\1\142\1\141\2\172\1\137\1\141"+
        "\2\145\1\172\1\uffff\1\164\1\uffff\1\167\1\164\1\151\1\163\1\162"+
        "\1\uffff\1\154\1\172\1\144\1\uffff\1\154\1\172\1\162\1\163\1\151"+
        "\1\172\1\151\1\143\1\162\1\uffff\1\163\1\164\1\145\1\164\1\143\1"+
        "\163\1\162\1\uffff\1\172\1\144\1\163\1\142\1\uffff\1\137\1\uffff"+
        "\1\143\1\160\1\163\1\171\1\172\1\106\1\172\1\145\1\uffff\1\162\1"+
        "\145\1\uffff\1\145\1\142\2\uffff\1\172\1\165\1\160\1\172\1\165\1"+
        "\172\1\141\1\172\1\uffff\1\144\1\162\1\141\1\uffff\1\141\1\172\2"+
        "\uffff\2\162\1\141\1\164\1\155\1\141\1\164\1\141\1\160\1\156\2\172"+
        "\1\155\1\163\1\164\1\143\1\141\1\144\1\164\1\160\2\163\1\164\1\142"+
        "\1\157\1\151\1\163\1\164\1\144\1\141\1\145\1\163\2\164\1\145\1\141"+
        "\1\156\1\172\1\145\1\164\2\172\1\154\2\151\1\145\1\163\1\154\1\164"+
        "\1\145\1\165\1\uffff\1\137\1\160\1\163\1\172\2\uffff\1\144\1\151"+
        "\1\172\1\144\1\uffff\4\151\1\156\1\172\1\166\1\145\1\uffff\1\165"+
        "\1\145\1\137\1\164\1\172\1\146\1\145\1\147\1\164\1\145\2\151\1\144"+
        "\1\172\3\145\1\141\1\172\1\151\1\145\1\146\1\172\1\145\1\151\1\155"+
        "\1\172\1\141\1\uffff\1\172\2\163\1\172\1\154\1\uffff\1\164\1\162"+
        "\1\uffff\1\155\1\164\1\uffff\1\145\1\172\1\162\1\163\1\141\1\157"+
        "\1\151\1\164\2\172\2\151\1\162\1\157\1\147\1\uffff\1\145\1\151\1"+
        "\172\1\164\3\151\1\157\1\151\1\172\1\151\1\165\1\156\1\157\1\172"+
        "\1\151\1\137\1\164\1\155\1\172\1\171\1\145\1\144\1\162\1\164\1\uffff"+
        "\1\155\1\171\2\uffff\1\151\1\164\1\166\2\172\2\151\2\143\1\163\1"+
        "\145\1\164\1\uffff\1\151\1\156\1\uffff\1\172\1\157\1\163\1\157\1"+
        "\156\1\151\1\uffff\1\145\1\172\1\162\1\172\1\146\1\171\1\uffff\1"+
        "\151\1\164\1\144\1\156\2\163\1\166\1\157\1\172\1\uffff\1\163\1\156"+
        "\1\163\1\164\1\uffff\1\166\1\162\1\157\1\uffff\1\172\1\164\1\172"+
        "\1\155\1\uffff\1\141\1\172\1\145\1\172\1\157\1\172\1\151\2\172\1"+
        "\uffff\1\171\1\145\1\164\1\144\1\143\1\151\2\uffff\1\156\1\157\1"+
        "\171\1\156\1\172\1\156\1\157\1\uffff\1\172\1\156\1\143\1\157\2\156"+
        "\1\uffff\1\157\1\164\1\172\1\156\1\157\1\164\1\151\1\172\1\145\1"+
        "\uffff\1\172\1\163\2\172\1\151\1\145\3\172\1\145\2\uffff\1\172\1"+
        "\141\1\164\1\145\1\156\1\162\1\165\1\162\1\164\1\162\1\163\1\151"+
        "\1\uffff\1\156\1\145\1\156\1\141\1\164\1\163\1\uffff\1\145\1\157"+
        "\1\172\1\145\1\151\1\172\1\163\2\172\1\145\1\172\1\uffff\1\172\1"+
        "\164\1\172\1\151\1\145\1\172\1\162\1\uffff\1\151\1\uffff\1\151\1"+
        "\154\1\172\1\uffff\1\146\1\uffff\1\166\2\uffff\2\172\1\151\1\172"+
        "\1\141\1\166\1\164\1\156\1\172\1\144\1\uffff\1\164\1\156\1\uffff"+
        "\2\164\1\156\1\144\1\147\1\156\1\151\1\uffff\1\172\1\156\1\151\1"+
        "\157\1\uffff\1\156\1\uffff\1\172\2\uffff\1\141\1\156\1\111\1\uffff"+
        "\1\141\1\uffff\1\172\1\141\1\164\1\172\1\163\1\172\1\157\1\142\2"+
        "\137\1\151\1\160\1\156\3\172\1\154\1\151\2\172\2\162\1\157\1\uffff"+
        "\1\172\1\uffff\1\172\1\uffff\1\145\1\uffff\1\157\1\172\1\uffff\1"+
        "\172\1\157\1\154\2\172\1\151\1\145\1\uffff\1\157\1\uffff\1\154\1"+
        "\151\2\172\1\uffff\1\145\3\172\1\151\1\172\1\145\2\172\1\157\1\uffff"+
        "\1\172\1\155\1\156\1\164\1\154\1\164\1\151\1\156\1\164\1\143\1\uffff"+
        "\1\164\1\151\1\uffff\1\172\1\uffff\1\160\2\163\1\157\1\156\1\172"+
        "\1\147\1\uffff\1\151\1\141\2\172\1\156\1\uffff\1\144\1\156\1\uffff"+
        "\1\156\1\171\1\uffff\1\154\1\172\1\156\1\172\1\164\1\172\1\uffff"+
        "\1\172\1\uffff\1\156\2\uffff\1\172\1\157\1\172\1\156\1\uffff\1\156"+
        "\1\145\4\172\1\156\2\151\1\141\1\151\1\157\1\uffff\1\145\1\164\1"+
        "\165\1\146\1\147\1\uffff\2\172\1\154\2\uffff\5\172\1\145\1\uffff"+
        "\1\172\1\uffff\1\171\1\143\1\156\1\143\2\172\4\uffff\1\141\1\164"+
        "\1\157\1\163\1\157\1\156\1\162\1\164\1\162\1\142\1\172\1\137\1\uffff"+
        "\1\141\1\151\5\uffff\1\172\1\uffff\1\172\1\145\1\172\1\145\2\uffff"+
        "\1\154\1\151\1\156\1\145\1\156\1\172\2\137\1\151\1\163\1\uffff\1"+
        "\157\1\164\1\172\2\uffff\1\172\1\uffff\1\172\1\151\1\141\3\172\1"+
        "\uffff\1\163\1\157\1\156\1\145\1\146\1\151\1\141\1\uffff\1\172\1"+
        "\154\3\uffff\1\165\1\146\1\147\1\164\1\172\1\157\1\164\1\141\1\151"+
        "\1\142\1\172\2\137\1\uffff\1\156\1\151\1\164\1\172\1\163\1\uffff"+
        "\2\157\1\172\1\157\1\151\1\141\1\145\2\146\1\uffff\1\156\1\157\2"+
        "\164\3\172\1\156\1\151\1\137\3\uffff\1\172\2\157\1\uffff\1\156\1"+
        "\146\2\172\2\uffff";
    static final String DFA44_acceptS =
        "\46\uffff\1\u009f\1\u00a0\2\uffff\1\u00a3\1\u00a4\1\uffff\1\u00a6"+
        "\1\u00a8\2\uffff\1\u00ad\1\u00ae\1\u00af\1\u00b0\1\u00b1\1\u00b3"+
        "\4\uffff\1\u00bb\1\uffff\1\u00c2\2\uffff\1\u00c8\1\u00ca\12\uffff"+
        "\1\17\57\uffff\1\143\33\uffff\1\u00a1\1\u00c0\1\u00b2\1\u00a2\1"+
        "\u00a7\1\u00b7\1\u00a5\1\u00ab\1\u00a9\1\u00ac\1\u00aa\1\u00b6\1"+
        "\u00b4\1\u00b8\1\u00b5\1\u00b9\1\u00bf\1\u00bd\1\u00ba\1\u00be\1"+
        "\u00bc\1\uffff\1\u00c1\1\u00c6\1\u00c5\1\u00c7\1\u00c9\1\uffff\1"+
        "\2\10\uffff\1\21\31\uffff\1\52\23\uffff\1\104\11\uffff\1\116\10"+
        "\uffff\1\144\1\uffff\1\146\50\uffff\1\u00c3\1\u00c4\1\uffff\1\1"+
        "\1\4\1\uffff\1\5\1\7\4\uffff\1\15\5\uffff\1\101\21\uffff\1\26\13"+
        "\uffff\1\47\1\uffff\1\51\6\uffff\1\57\20\uffff\1\105\20\uffff\1"+
        "\137\1\uffff\1\142\15\uffff\1\160\1\161\5\uffff\1\166\3\uffff\1"+
        "\173\4\uffff\1\176\23\uffff\1\u0096\5\uffff\1\u0098\17\uffff\1\100"+
        "\1\u008a\1\u008b\2\uffff\1\u0090\2\uffff\1\24\31\uffff\1\55\5\uffff"+
        "\1\65\3\uffff\1\72\31\uffff\1\135\1\uffff\1\145\5\uffff\1\153\3"+
        "\uffff\1\154\11\uffff\1\u0082\7\uffff\1\u0083\4\uffff\1\u0084\1"+
        "\uffff\1\u0088\10\uffff\1\u0094\2\uffff\1\u0097\2\uffff\1\u0099"+
        "\1\u009a\10\uffff\1\10\3\uffff\1\16\2\uffff\1\u008e\1\u008f\63\uffff"+
        "\1\117\4\uffff\1\131\1\132\4\uffff\1\141\10\uffff\1\156\34\uffff"+
        "\1\u0092\5\uffff\1\u009b\2\uffff\1\u009c\2\uffff\1\11\17\uffff\1"+
        "\27\31\uffff\1\71\2\uffff\1\76\1\102\14\uffff\1\130\2\uffff\1\136"+
        "\6\uffff\1\152\6\uffff\1\u008d\11\uffff\1\175\4\uffff\1\167\3\uffff"+
        "\1\u0086\4\uffff\1\u0093\11\uffff\1\13\6\uffff\1\34\1\35\7\uffff"+
        "\1\33\6\uffff\1\46\11\uffff\1\63\12\uffff\1\127\1\107\14\uffff\1"+
        "\140\6\uffff\1\155\13\uffff\1\172\7\uffff\1\u0087\1\uffff\1\u008c"+
        "\3\uffff\1\u009d\1\uffff\1\3\1\uffff\1\12\1\14\12\uffff\1\25\2\uffff"+
        "\1\36\7\uffff\1\53\4\uffff\1\60\1\uffff\1\64\1\uffff\1\66\1\67\3"+
        "\uffff\1\73\1\uffff\1\106\27\uffff\1\165\1\uffff\1\u0081\1\uffff"+
        "\1\171\1\uffff\1\u0080\2\uffff\1\174\7\uffff\1\20\1\uffff\1\22\4"+
        "\uffff\1\42\12\uffff\1\45\12\uffff\1\110\2\uffff\1\114\1\uffff\1"+
        "\120\7\uffff\1\147\5\uffff\1\170\2\uffff\1\u0085\2\uffff\1\u0095"+
        "\6\uffff\1\37\1\uffff\1\41\1\uffff\1\32\1\30\4\uffff\1\44\14\uffff"+
        "\1\115\5\uffff\1\133\3\uffff\1\157\1\162\6\uffff\1\6\1\uffff\1\23"+
        "\6\uffff\1\56\1\61\1\70\1\62\14\uffff\1\134\2\uffff\1\163\1\177"+
        "\1\164\1\u0089\1\u0091\1\uffff\1\77\4\uffff\1\50\1\54\12\uffff\1"+
        "\125\3\uffff\1\u009e\1\31\1\uffff\1\40\6\uffff\1\113\7\uffff\1\43"+
        "\2\uffff\1\103\1\111\1\112\15\uffff\1\126\5\uffff\1\122\11\uffff"+
        "\1\150\12\uffff\1\123\1\124\1\151\3\uffff\1\74\4\uffff\1\75\1\121";
    static final String DFA44_specialS =
        "\77\uffff\1\0\u0492\uffff}>";
    static final String[] DFA44_transitionS = {
            "\2\47\1\uffff\2\47\22\uffff\1\47\1\uffff\1\77\1\63\2\uffff\1"+
            "\66\1\53\1\51\1\56\1\67\1\65\1\55\1\50\1\54\1\70\12\52\1\74"+
            "\1\75\1\72\1\73\1\71\1\uffff\1\101\1\2\1\3\1\7\1\12\1\14\1\15"+
            "\2\46\1\17\2\46\1\22\1\24\1\46\1\27\1\31\1\32\1\35\1\37\1\40"+
            "\1\42\1\43\1\45\3\46\1\61\1\uffff\1\62\1\64\2\uffff\1\1\1\6"+
            "\1\10\1\11\1\13\1\4\1\16\1\46\1\20\2\46\1\21\1\23\1\25\1\26"+
            "\1\30\1\33\1\34\1\36\1\5\1\41\1\46\1\44\3\46\1\57\1\76\1\60"+
            "\1\100",
            "\1\102\1\uffff\1\103\7\uffff\1\104\1\uffff\1\105\4\uffff\1"+
            "\106",
            "\1\107\2\uffff\1\110\2\uffff\1\111",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\1\112\27\46\1\113"+
            "\1\46",
            "\1\115\7\uffff\1\116\5\uffff\1\120\2\uffff\1\117",
            "\1\122\1\123\10\uffff\1\121\6\uffff\1\124",
            "\1\125",
            "\1\126\15\uffff\1\127",
            "\1\130\3\uffff\1\131\2\uffff\1\132",
            "\1\133\3\uffff\1\134\5\uffff\1\135\5\uffff\1\136",
            "\1\137",
            "\1\140\1\uffff\1\141\2\uffff\1\142\4\uffff\1\143\1\uffff\1"+
            "\144",
            "\1\145",
            "\1\146\15\uffff\1\147",
            "\1\150",
            "\1\151\7\uffff\1\152\5\uffff\1\153",
            "\1\154\6\uffff\1\155\1\156\4\uffff\1\157",
            "\1\160",
            "\1\161\11\uffff\1\162",
            "\1\163\7\uffff\1\164\5\uffff\1\165",
            "\1\166",
            "\1\167",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\5\46\1\170\11\46"+
            "\1\171\1\46\1\172\1\46\1\173\6\46",
            "\1\175",
            "\1\176\11\uffff\1\177\2\uffff\1\u0080",
            "\1\u0081\1\uffff\1\u0082",
            "\1\u0083",
            "\1\u0084",
            "\1\u0085\12\uffff\1\u0086\4\uffff\1\u0087",
            "\1\u0088",
            "\1\u0089\2\uffff\1\u008a\14\uffff\1\u008b",
            "\1\u008c\1\u008d",
            "\1\u008e\20\uffff\1\u008f",
            "\1\u0090\1\uffff\1\u0091\2\uffff\1\u0092",
            "\1\u0093",
            "\1\u0094",
            "\1\u0095\1\u0096",
            "\1\u0097",
            "",
            "",
            "\1\u0098\20\uffff\1\u0099",
            "\1\u009b",
            "",
            "",
            "\1\u009d",
            "",
            "",
            "\1\u009f",
            "\1\u00a1",
            "",
            "",
            "",
            "",
            "",
            "",
            "\1\u00a3",
            "\1\u00a5",
            "\1\u00a7\1\u00a8",
            "\1\u00ab\1\u00aa",
            "",
            "\1\u00ad",
            "",
            "\1\u00af",
            "\0\u00b2",
            "",
            "",
            "\1\u00b3",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u00b5\7\uffff\1\u00b6",
            "\1\u00b7",
            "\1\u00b8",
            "\1\u00b9",
            "\1\u00ba",
            "\1\u00bb",
            "\1\u00bc",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u00be",
            "\1\u00bf",
            "\1\u00c0",
            "\1\u00c1",
            "\1\u00c2",
            "\1\u00c3\3\uffff\1\u00c4",
            "\1\u00c5",
            "\1\u00c6",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u00c7\1\u00c9\1\u00c8",
            "\1\u00ca\1\u00cb\3\uffff\1\u00cc",
            "\1\u00cd",
            "\1\u00cf\14\uffff\1\u00ce",
            "\1\u00d0\1\u00d1\3\uffff\1\u00d2",
            "\1\u00d3\2\uffff\1\u00d4",
            "\1\u00d5\2\uffff\1\u00d6",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u00d8",
            "\1\u00d9\1\uffff\1\u00da",
            "\1\u00db\7\uffff\1\u00dd\11\uffff\1\u00dc",
            "\1\u00de\3\uffff\1\u00df\12\uffff\1\u00e0",
            "\1\u00e1",
            "\1\u00e2",
            "\1\u00e3\1\uffff\1\u00e4\3\uffff\1\u00e5",
            "\1\u00e6",
            "\1\u00e7\11\uffff\1\u00e8",
            "\1\u00e9",
            "\1\u00ea",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u00ed\13\uffff\1\u00ec",
            "\1\u00ee",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\5\46\1\u00ef\24\46",
            "\1\u00f0",
            "\1\u00f1\11\uffff\1\u00f2\1\u00f3",
            "\12\46\7\uffff\32\46\4\uffff\1\u00f4\1\uffff\32\46",
            "\1\u00f6",
            "\1\u00f7",
            "\1\u00f8",
            "\1\u00f9",
            "\1\u00fa",
            "\1\u00fb",
            "\1\u00fc",
            "\1\u00fd",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u00ff",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0101",
            "",
            "\1\u0102",
            "\1\u0103",
            "\1\u0104",
            "\1\u0105\11\uffff\1\u0106",
            "\1\u0108\11\uffff\1\u0107",
            "\1\u0109",
            "\1\u010a",
            "\1\u010b",
            "\1\u010c\1\uffff\1\u010e\1\u010f\7\uffff\1\u0110\1\u0111\2"+
            "\uffff\1\u0112\1\u0113\1\uffff\1\u010d",
            "\1\u0114",
            "\1\u0115",
            "\1\u0116\1\uffff\1\u0117\11\uffff\1\u0118",
            "\1\u0119",
            "\1\u011a",
            "\1\u011b",
            "\1\u011c",
            "\1\u011d\15\uffff\1\u011e",
            "\1\u011f",
            "\1\u0120",
            "\1\u0121",
            "\1\u0122",
            "\1\u0123",
            "\1\u0124",
            "\1\u0125",
            "\1\u0126",
            "\1\u0127",
            "\1\u0128",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "\1\u0129",
            "",
            "",
            "",
            "",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\24\46\1\u012b\5\46",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\4\46\1\u012e\25\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0131",
            "\1\u0132",
            "\12\46\7\uffff\32\46\4\uffff\1\u0133\1\uffff\10\46\1\u0134"+
            "\21\46",
            "\1\u0136",
            "\1\u0137",
            "",
            "\1\u0138",
            "\1\u0139",
            "\1\u013a",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u013c",
            "\1\u013d",
            "\1\u013e\3\uffff\1\u013f",
            "\1\u0140",
            "\1\u0141",
            "\1\u0142",
            "\1\u0143",
            "\1\u0144",
            "\1\u0145",
            "\1\u0146\2\uffff\1\u0147\14\uffff\1\u0148\2\uffff\1\u0149",
            "\1\u014a\2\uffff\1\u014b",
            "\1\u014c",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u014e",
            "\1\u014f\2\uffff\1\u0150",
            "\1\u0151\6\uffff\1\u0152\10\uffff\1\u0153\1\u0154\1\uffff\1"+
            "\u0155",
            "\1\u0156",
            "\1\u0157",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\10\46\1\u0158\21"+
            "\46",
            "\1\u015a",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u015c",
            "\1\u015d",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\10\46\1\u015e\21"+
            "\46",
            "\1\u015f",
            "\1\u0160",
            "\1\u0161",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0163",
            "\1\u0164",
            "\1\u0165",
            "\1\u0166",
            "\1\u0167",
            "\1\u0168",
            "\1\u0169\1\u016a",
            "\1\u016b",
            "\1\u016c",
            "\1\u016d",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\6\46\1\u016e\23\46",
            "\1\u016f",
            "",
            "\1\u0170",
            "\1\u0171",
            "\1\u0172",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0174",
            "\1\u0175",
            "\1\u0176",
            "\1\u0177\14\uffff\1\u0178",
            "\1\u0179\4\uffff\1\u017a\1\uffff\1\u017b\2\uffff\1\u017c",
            "",
            "\1\u017d",
            "\1\u017e",
            "\1\u017f",
            "\1\u0180",
            "\1\u0181",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\4\46\1\u0182\17\46"+
            "\1\u0183\5\46",
            "\1\u0185",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u0187",
            "",
            "\1\u0188",
            "\1\u0189",
            "\1\u018a",
            "\1\u018b",
            "\1\u018c",
            "\1\u018d\10\uffff\1\u018e",
            "\1\u018f\2\uffff\1\u0190\10\uffff\1\u0191\1\u0192",
            "\1\u0193",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0196",
            "\1\u0197\6\uffff\1\u0198",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\17\46\1\u0199\3\46"+
            "\1\u019a\6\46",
            "\1\u019c",
            "\1\u019d",
            "\1\u019e",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u01a0\6\uffff\1\u01a1\5\uffff\1\u01a2",
            "\1\u01a3",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u01a5",
            "\1\u01a6",
            "\1\u01a7\5\uffff\1\u01a8",
            "\1\u01a9",
            "\1\u01aa",
            "\1\u01ab",
            "\1\u01ac",
            "\1\u01ad",
            "\1\u01ae",
            "\1\u01af",
            "\1\u01b0\2\uffff\1\u01b1",
            "\1\u01b2",
            "\1\u01b3\1\uffff\1\u01b4\2\uffff\1\u01b5\1\uffff\1\u01b6",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\1\u01b7\31\46",
            "\1\u01b9",
            "\1\u01ba\2\uffff\1\u01bb",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\10\46\1\u01bc\11"+
            "\46\1\u01bd\7\46",
            "\1\u01bf\3\uffff\1\u01c0",
            "\1\u01c1",
            "\1\u01c2",
            "",
            "",
            "\1\u01c3",
            "",
            "",
            "\1\u01c4",
            "",
            "",
            "\1\u01c5",
            "\1\u01c6",
            "\1\u01c7\22\uffff\1\u01c8",
            "\1\u01c9",
            "",
            "\1\u01ca",
            "\1\u01cb",
            "\1\u01cc",
            "\1\u01cd",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u01d1",
            "\1\u01d2",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u01d4",
            "\1\u01d5",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u01d7",
            "\1\u01d8",
            "\1\u01d9",
            "\1\u01da",
            "\1\u01db",
            "\1\u01dc",
            "\1\u01dd",
            "\1\u01de",
            "",
            "\1\u01df",
            "\1\u01e0",
            "\1\u01e1",
            "\1\u01e3\6\uffff\1\u01e2",
            "\1\u01e4",
            "\1\u01e5",
            "\1\u01e6",
            "\1\u01e7",
            "\1\u01e8",
            "\1\u01e9",
            "\1\u01ea",
            "",
            "\1\u01eb",
            "",
            "\1\u01ec",
            "\1\u01ed",
            "\1\u01ee",
            "\1\u01ef",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u01f1",
            "",
            "\1\u01f2",
            "\1\u01f3",
            "\1\u01f4",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\24\46\1\u01f5\5\46",
            "\1\u01f7",
            "\1\u01f8",
            "\1\u01f9",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u01fb",
            "\1\u01fc",
            "\1\u01fd",
            "\1\u01fe",
            "\1\u01ff",
            "\1\u0200",
            "\1\u0201",
            "\1\u0202",
            "",
            "\1\u0203",
            "\1\u0204",
            "\1\u0205",
            "\1\u0206",
            "\1\u0207",
            "\1\u0208",
            "\1\u0209",
            "\1\u020a",
            "\1\u020b",
            "\1\u020c",
            "\1\u020d",
            "\1\u020e",
            "\1\u020f\3\uffff\1\u0210",
            "\1\u0211",
            "\1\u0212",
            "\1\u0213",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\1\u0215\31\46",
            "\1\u0217",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\1\u0218\31\46",
            "\1\u0219",
            "\1\u021a",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\4\46\1\u021b\25\46",
            "\1\u021d",
            "\1\u021e",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\4\46\1\u021f\25\46",
            "\1\u0221",
            "\1\u0222",
            "\1\u0223",
            "\1\u0224",
            "",
            "",
            "\1\u0225",
            "\1\u0226",
            "\1\u0227",
            "\1\u0228",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\16\46\1\u0229\13"+
            "\46",
            "",
            "\1\u022b",
            "\1\u022c",
            "\1\u022d",
            "",
            "\1\u022e",
            "\1\u022f",
            "\1\u0230",
            "\1\u0231",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0233",
            "\1\u0234",
            "\1\u0235",
            "\1\u0236",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0238",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u023a",
            "\1\u023b",
            "\1\u023c",
            "\1\u023d",
            "\1\u023e",
            "\12\46\7\uffff\32\46\4\uffff\1\u023f\1\uffff\32\46",
            "\1\u0240",
            "\1\u0241",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0243",
            "\1\u0244",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0246",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0247",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u024a",
            "\1\u024c\17\uffff\1\u024b",
            "\1\u024d",
            "\1\u024e",
            "\1\u0250\4\uffff\1\u024f",
            "\1\u0251",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0253",
            "\1\u0254",
            "\1\u0255",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0257",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0258",
            "",
            "",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u025b",
            "\1\u025c",
            "",
            "\1\u025d",
            "\1\u025e",
            "\1\u025f",
            "\1\u0260",
            "\1\u0261",
            "\1\u0262",
            "\1\u0263",
            "\1\u0264",
            "\1\u0265",
            "\1\u0266",
            "\1\u0267",
            "\1\u0268",
            "\1\u0269",
            "\1\u026a",
            "\1\u026b",
            "\1\u026c",
            "\1\u026d",
            "\1\u026e",
            "\1\u026f",
            "\1\u0270\3\uffff\1\u0271",
            "\1\u0272",
            "\1\u0273",
            "\1\u0274",
            "\1\u0275\3\uffff\1\u0276",
            "\1\u0277",
            "",
            "\1\u0278",
            "\1\u0279",
            "\1\u027a",
            "\1\u027b",
            "\1\u027c",
            "",
            "\1\u027d",
            "\1\u027e",
            "\1\u027f\21\uffff\1\u0280",
            "",
            "\1\u0281",
            "\1\u0282",
            "\1\u0283",
            "\1\u0284",
            "\1\u0285",
            "\1\u0286",
            "\1\u0287",
            "\1\u0288",
            "\1\u0289",
            "\1\u028a",
            "\1\u028b",
            "\1\u028c",
            "\1\u028d",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u028f",
            "\1\u0290",
            "\1\u0291",
            "\1\u0292",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0295",
            "\1\u0296",
            "\1\u0297",
            "\1\u0298",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u029a",
            "",
            "\1\u029b",
            "\1\u029c",
            "\1\u029d\2\uffff\1\u029e",
            "\1\u029f",
            "\1\u02a0",
            "",
            "\1\u02a1",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u02a3",
            "",
            "\1\u02a4",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\22\46\1\u02a5\7\46",
            "\1\u02a6",
            "\1\u02a7",
            "\1\u02a8",
            "\1\u02a9",
            "\1\u02aa",
            "\1\u02ab",
            "\1\u02ac",
            "",
            "\1\u02ad",
            "\1\u02ae",
            "\1\u02af",
            "\1\u02b0",
            "\1\u02b1",
            "\1\u02b2",
            "\1\u02b3",
            "",
            "\1\u02b4",
            "\1\u02b5",
            "\1\u02b6",
            "\1\u02b7",
            "",
            "\1\u02b8",
            "",
            "\1\u02b9",
            "\1\u02ba",
            "\1\u02bb",
            "\1\u02bc\23\uffff\1\u02bd",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u02be",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u02c0",
            "",
            "\1\u02c1",
            "\1\u02c2",
            "",
            "\1\u02c3",
            "\1\u02c4",
            "",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u02c6",
            "\1\u02c7",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u02c9",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u02ca",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u02cc",
            "\1\u02cd",
            "\1\u02ce",
            "",
            "\1\u02cf",
            "\1\u02d0",
            "",
            "",
            "\1\u02d1",
            "\1\u02d2",
            "\1\u02d3",
            "\1\u02d4",
            "\1\u02d5",
            "\1\u02d6",
            "\1\u02d7",
            "\1\u02d8",
            "\1\u02d9",
            "\1\u02da",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u02dc",
            "\1\u02dd",
            "\1\u02de",
            "\1\u02df",
            "\1\u02e0",
            "\1\u02e1",
            "\1\u02e2",
            "\1\u02e3",
            "\1\u02e4",
            "\1\u02e5",
            "\1\u02e6",
            "\1\u02e7",
            "\1\u02e8",
            "\1\u02e9",
            "\1\u02ea",
            "\1\u02eb",
            "\1\u02ec",
            "\1\u02ed",
            "\1\u02ee",
            "\1\u02ef",
            "\1\u02f0",
            "\1\u02f1",
            "\1\u02f2",
            "\1\u02f3",
            "\1\u02f4",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u02f6",
            "\1\u02f7",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u02fa",
            "\1\u02fb",
            "\1\u02fc",
            "\1\u02fd",
            "\1\u02fe",
            "\1\u02ff",
            "\1\u0300",
            "\1\u0301",
            "\1\u0302",
            "",
            "\1\u0303",
            "\1\u0304",
            "\1\u0305",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "",
            "\1\u0307",
            "\1\u0308",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u030a",
            "",
            "\1\u030b",
            "\1\u030c",
            "\1\u030d",
            "\1\u030e",
            "\1\u030f",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0311",
            "\1\u0312",
            "",
            "\1\u0313",
            "\1\u0314",
            "\1\u0315",
            "\1\u0316",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0318",
            "\1\u0319\3\uffff\1\u031a",
            "\1\u031b",
            "\1\u031c",
            "\1\u031d",
            "\1\u031e",
            "\1\u031f",
            "\1\u0320",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0322",
            "\1\u0323",
            "\1\u0324",
            "\1\u0325",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0327",
            "\1\u0328",
            "\1\u0329",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u032b",
            "\1\u032c",
            "\1\u032d",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u032e",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0330",
            "\1\u0331",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0332",
            "",
            "\1\u0333",
            "\1\u0334",
            "",
            "\1\u0335",
            "\1\u0336",
            "",
            "\1\u0337",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\22\46\1\u0338\7\46",
            "\1\u033a",
            "\1\u033b",
            "\1\u033c",
            "\1\u033d",
            "\1\u033e",
            "\1\u033f",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0342",
            "\1\u0343",
            "\1\u0344",
            "\1\u0345",
            "\1\u0346",
            "",
            "\1\u0347",
            "\1\u0348",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u034a",
            "\1\u034b",
            "\1\u034c",
            "\1\u034d",
            "\1\u034e",
            "\1\u034f",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0351",
            "\1\u0352",
            "\1\u0353",
            "\1\u0354",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0355",
            "\1\u0356",
            "\1\u0357",
            "\1\u0358\10\uffff\1\u0359",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u035b",
            "\1\u035c",
            "\1\u035d",
            "\1\u035e",
            "\1\u035f",
            "",
            "\1\u0360",
            "\1\u0361",
            "",
            "",
            "\1\u0362",
            "\1\u0363",
            "\1\u0364",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0367",
            "\1\u0368",
            "\1\u0369",
            "\1\u036a",
            "\1\u036b\6\uffff\1\u036c\2\uffff\1\u036d",
            "\1\u036e",
            "\1\u036f\16\uffff\1\u0370",
            "",
            "\1\u0371",
            "\1\u0372",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0374",
            "\1\u0375",
            "\1\u0376",
            "\1\u0377",
            "\1\u0378",
            "",
            "\1\u0379",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u037b",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u037c",
            "\1\u037d",
            "",
            "\1\u037e",
            "\1\u037f",
            "\1\u0380",
            "\1\u0381",
            "\1\u0382",
            "\1\u0383",
            "\1\u0384",
            "\1\u0385",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u0387",
            "\1\u0388",
            "\1\u0389",
            "\1\u038a",
            "",
            "\1\u038b",
            "\1\u038c",
            "\1\u038d",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u038f",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0391",
            "",
            "\1\u0392",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0393",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0395",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0397",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u039a",
            "\1\u039b",
            "\1\u039c",
            "\1\u039d",
            "\1\u039e",
            "\1\u039f",
            "",
            "",
            "\1\u03a0",
            "\1\u03a1",
            "\1\u03a2",
            "\1\u03a3",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03a5",
            "\1\u03a6",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03a8",
            "\1\u03a9",
            "\1\u03aa",
            "\1\u03ab",
            "\1\u03ac",
            "",
            "\1\u03ad",
            "\1\u03ae",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03b0",
            "\1\u03b1",
            "\1\u03b2",
            "\1\u03b3",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03b5",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03b7",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03ba",
            "\1\u03bb",
            "\12\46\7\uffff\32\46\4\uffff\1\u03bc\1\uffff\32\46",
            "\1\u03be",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03c0",
            "",
            "",
            "\1\u03c1",
            "\1\u03c2",
            "\1\u03c3",
            "\1\u03c4",
            "\1\u03c5",
            "\1\u03c6",
            "\1\u03c7",
            "\1\u03c8",
            "\1\u03c9",
            "\1\u03ca",
            "\1\u03cb",
            "\1\u03cc",
            "",
            "\1\u03cd",
            "\1\u03ce",
            "\1\u03cf",
            "\1\u03d0",
            "\1\u03d1",
            "\1\u03d2",
            "",
            "\1\u03d3",
            "\1\u03d4",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03d5",
            "\1\u03d6",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03d8",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03da",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03dc",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03de",
            "\1\u03df",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03e1",
            "",
            "\1\u03e2",
            "",
            "\1\u03e3",
            "\1\u03e4",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\22\46\1\u03e5\7\46",
            "",
            "\1\u03e6",
            "",
            "\1\u03e7",
            "",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03e9",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03eb",
            "\1\u03ec",
            "\1\u03ed",
            "\1\u03ee",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03f0",
            "",
            "\1\u03f1",
            "\1\u03f2",
            "",
            "\1\u03f3",
            "\1\u03f4",
            "\1\u03f5",
            "\1\u03f6",
            "\1\u03f7",
            "\1\u03f8",
            "\1\u03f9",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u03fb",
            "\1\u03fc",
            "\1\u03fd",
            "",
            "\1\u03fe",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "",
            "\1\u03ff",
            "\1\u0400",
            "\1\u0401\2\uffff\1\u0402",
            "",
            "\1\u0403",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\u0404\1\uffff\32\46",
            "\1\u0406",
            "\1\u0407",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0409",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u040b",
            "\1\u040c",
            "\1\u040d",
            "\1\u040e",
            "\1\u040f",
            "\1\u0410",
            "\1\u0411",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0413",
            "\1\u0414",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0415",
            "\1\u0416",
            "\1\u0417",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u0419",
            "",
            "\1\u041a",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u041c",
            "\1\u041d",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u041f",
            "\1\u0420",
            "",
            "\1\u0421",
            "",
            "\1\u0422",
            "\1\u0423",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\22\46\1\u0424\7\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\22\46\1\u0426\7\46",
            "",
            "\1\u0428",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\22\46\1\u042b\7\46",
            "\1\u042c",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\22\46\1\u042d\7\46",
            "\1\u042e",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0430",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0431",
            "\1\u0432",
            "\1\u0433",
            "\1\u0434",
            "\1\u0435",
            "\1\u0436",
            "\1\u0437",
            "\1\u0438",
            "\1\u0439",
            "",
            "\1\u043a",
            "\1\u043b",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u043d",
            "\1\u043e",
            "\1\u043f",
            "\1\u0440",
            "\1\u0441",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0443",
            "",
            "\1\u0444",
            "\1\u0445",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0448",
            "",
            "\1\u0449",
            "\1\u044a",
            "",
            "\1\u044b",
            "\1\u044c",
            "",
            "\1\u044d",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u044f",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0451",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u0452",
            "",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0453",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0454",
            "",
            "\1\u0455",
            "\1\u0456",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u045b",
            "\1\u045c",
            "\1\u045d",
            "\1\u045e",
            "\1\u045f",
            "\1\u0460",
            "",
            "\1\u0461",
            "\1\u0462\16\uffff\1\u0463",
            "\1\u0464",
            "\1\u0465",
            "\1\u0466",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0468",
            "\1\u0469",
            "",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u046f",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u0471",
            "\1\u0472",
            "\1\u0473",
            "\1\u0474",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "",
            "",
            "",
            "\1\u0477",
            "\1\u0478",
            "\1\u0479",
            "\1\u047a",
            "\1\u047b",
            "\1\u047c",
            "\1\u047d",
            "\1\u047e",
            "\1\u047f",
            "\1\u0480",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0482",
            "",
            "\1\u0483",
            "\1\u0484",
            "",
            "",
            "",
            "",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0487",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0489",
            "",
            "",
            "\1\u048a",
            "\1\u048b",
            "\1\u048c",
            "\1\u048d",
            "\1\u048e",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0490",
            "\1\u0491",
            "\1\u0492",
            "\1\u0493",
            "",
            "\1\u0494",
            "\1\u0495",
            "\1\u0496",
            "",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u0498",
            "\1\u0499",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            "\1\u049d",
            "\1\u049e",
            "\1\u049f",
            "\1\u04a0",
            "\1\u04a1",
            "\1\u04a2",
            "\1\u04a3",
            "",
            "\1\u04a4",
            "\1\u04a5",
            "",
            "",
            "",
            "\1\u04a6",
            "\1\u04a7",
            "\1\u04a8",
            "\1\u04a9",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u04ab",
            "\1\u04ac",
            "\1\u04ad",
            "\1\u04ae",
            "\1\u04af",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u04b1",
            "\1\u04b2",
            "",
            "\1\u04b3",
            "\1\u04b4",
            "\1\u04b5",
            "\1\u04b6",
            "\1\u04b7",
            "",
            "\1\u04b8",
            "\1\u04b9",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u04bb",
            "\1\u04bc",
            "\1\u04bd",
            "\1\u04be",
            "\1\u04bf",
            "\1\u04c0",
            "",
            "\1\u04c1",
            "\1\u04c2",
            "\1\u04c3",
            "\1\u04c4",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u04c8",
            "\1\u04c9",
            "\1\u04ca",
            "",
            "",
            "",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\1\u04cc",
            "\1\u04cd",
            "",
            "\1\u04ce",
            "\1\u04cf",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "\12\46\7\uffff\32\46\4\uffff\1\46\1\uffff\32\46",
            "",
            ""
    };

    static final short[] DFA44_eot = DFA.unpackEncodedString(DFA44_eotS);
    static final short[] DFA44_eof = DFA.unpackEncodedString(DFA44_eofS);
    static final char[] DFA44_min = DFA.unpackEncodedStringToUnsignedChars(DFA44_minS);
    static final char[] DFA44_max = DFA.unpackEncodedStringToUnsignedChars(DFA44_maxS);
    static final short[] DFA44_accept = DFA.unpackEncodedString(DFA44_acceptS);
    static final short[] DFA44_special = DFA.unpackEncodedString(DFA44_specialS);
    static final short[][] DFA44_transition;

    static {
        int numStates = DFA44_transitionS.length;
        DFA44_transition = new short[numStates][];
        for (int i=0; i<numStates; i++) {
            DFA44_transition[i] = DFA.unpackEncodedString(DFA44_transitionS[i]);
        }
    }

    class DFA44 extends DFA {

        public DFA44(BaseRecognizer recognizer) {
            this.recognizer = recognizer;
            this.decisionNumber = 44;
            this.eot = DFA44_eot;
            this.eof = DFA44_eof;
            this.min = DFA44_min;
            this.max = DFA44_max;
            this.accept = DFA44_accept;
            this.special = DFA44_special;
            this.transition = DFA44_transition;
        }
        public String getDescription() {
            return "1:1: Tokens : ( ABS | AD | ABSURDUM | ALL | ALTERS | ALTERNATIVE | AND | ARRAY | ASSUME | AUX_CODE | AUX_VAR | AUX_VARS | AUXILIARY | AXIOM | BOOLEAN | BASECASE | BY | CARTPROD | CATEGORICAL | CASE | CHANGING | CLEARS | COMMON | CONCLUSION | COMMUTATIVITY | COMPLEMENT | CONCEPT | MODULE_CONCEPT | CONFIRM | CONJUNCT | CONSTRAINT | CONTRADICTION | CONVENTION | COROLLARY | CORR | DECREASING | DEDUCTION | DEFINES | DEFINITION | DISTRIBUTION | DIV | DO | DURATION | ELAPSED_TIME | ELSE | ELIMINATION | END | ENHANCED | ENHANCEMENT | MODULE_ENHANCEMENT | ENSURES | EQUALITY | EVALUATES | EXCLUDED | EXEMPLAR | EXISTENTIAL | EXISTS | EXIT | FACILITY | FAC_FINAL | FAC_INIT | FAMILY | FINALIZATION | FROM | FOR | FORGET | GENERALIZATION | IF | IFF | IMPLICIT | IMPLIES | INDUCTIVE | INDUCTIVECASE | INITIALIZATION | INSTANTIATION | INTERSECT | INTRODUCES | IS | IN | NOT_IN | NOT_PROP_SUBSET | NOT_SUBSET | NOT_SUBSTR | PROP_SUBSET | SUBSET | SUBSTR | ITERATE | LAMBDA | LEMMA | LOCAL | MAINP_DISP | MAINTAINING | MATH | MIDDLE | MOD | MODELED | MODUS | NOT | CAT | OF | OPERATION | OR | OTHERWISE | PERF_FINAL | PERF_INIT | PONENS | PRESERVES | PROCEDURE | MODULE_PROFILE | PROOF | PROOFS_FOR | PROPERTY | QED | QUANTIFIER | REALIZATION | MODULE_REALIZATION | REALIZED | REASSIGNS | RECORD | RECURSIVE | REDUCTIO | RELATED | REM | REMEMBER | REPEAT | REPLACES | REPRESENTED | REQUIRES | RESPECTS | RESTORES | RULE | SELF | SHORT_FOR | STATIC | SUBTYPE | SUCH | SUPPOSITION | THAT | THEN | THEOREM | THEORY | THERE | TIMES | TYPE | TYPE_FAMILY | UNION | UNIQUE | UNIT | UNIVERSAL | UPDATES | USES | VAR | VARIABLES | WHEN | WHERE | WHILE | WITHOUT | WITH_PROFILE | IDENTIFIER | WS | SL_COMMENT | ML_COMMENT | NUMERIC_LITERAL | CHARACTER_LITERAL | DOT | COMMA | LPAREN | RPAREN | LBRACE | RBRACE | DBL_LBRACE | DBL_RBRACE | LSQBRACK | RSQBRACK | HASH | CARAT | PLUS | MINUS | AMPERSAND | MULTIPLY | DIVIDE | EXP | RANGE | NOT_EQL | GT_EQL | LT_EQL | EQL | LT | GT | LL | GG | FUNCARROW | COLON | SEMICOLON | SWAP_OP | ASSIGN_OP | BAR | DBL_BAR | DQUOTE | TILDE | STRING_LITERAL | FREE_OPERATOR );";
        }
        public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
            IntStream input = _input;
        	int _s = s;
            switch ( s ) {
                    case 0 : 
                        int LA44_63 = input.LA(1);

                        s = -1;
                        if ( ((LA44_63>='\u0000' && LA44_63<='\uFFFF')) ) {s = 178;}

                        else s = 177;

                        if ( s>=0 ) return s;
                        break;
            }
            if (state.backtracking>0) {state.failed=true; return -1;}
            NoViableAltException nvae =
                new NoViableAltException(getDescription(), 44, _s, input);
            error(nvae);
            throw nvae;
        }
    }
 

}