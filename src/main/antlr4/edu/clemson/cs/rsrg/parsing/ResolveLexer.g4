lexer grammar ResolveLexer;

ABS
    :   'abs'
    ;

ABSTRACT_VAR
    :   'Abstract_Var'
    ;

AFFECTS
    :	'affects'
    ;

ALTERS
    :   'alt'
    |   'alters'
    ;

AND
    :   'and'
    ;

ARRAY
    :   'Array'
    ;

AXIOM
    :   'Axiom'
    ;

BASECASE
    :   'Base_Case'
    ;

BIG_CONCAT
    :   'Big_Concatenation'
    ;

BIG_INTERSECT
    :   'Big_Intersection'
    ;

BIG_PRODUCT
    :   'Big_Product'
    ;

BIG_SUM
    :   'Big_Sum'
    ;

BIG_UNION
    :   'Big_Union'
    ;

BY
    :   'by'
    ;

CARTPROD
    :   'Cart_Prod'
    ;

CASE
    :   'Case'
    ;

CATEGORICAL
    :   'Categorical'
    ;

CHANGING
    :   'changing'
    ;

CLEARS
    :   'clr'
    |   'clears'
    ;

COMPLEMENT
    :   'complement'
    ;

CONCEPT
    :   'Concept'
    ;

CONFIRM
    :   'Confirm'
    ;

CONSTRAINT
    :   'Constraint'
    |   'Constraints'
    |   'constraint'
    |   'constraints'
    ;

CONVENTION
    :   'Convention'
    |   'Conventions'
    |   'convention'
    |   'conventions'
    ;

COROLLARY
    :   'Corollary'
    ;

CORR
    :   'correspondence'
    ;

DECREASING
    :   'decreasing'
    ;

DEFINES
    :   'Defines'
    ;

DEFINITION
    :   'Definition'
    |   'Def'
    ;

DIV
    :   'div'
    ;

DO
    :   'do'
    ;

DURATION
    :   'duration'
    ;

ELAPSED_TIME
    :   'elapsed_time'
    ;

ELSE
    :   'Else'
    |   'else'
    ;

END
    :   'end'
    ;

ENHANCED
    :   'enhanced'
    ;

ENHANCEMENT
    :   'Enhancement'
    ;

ENSURES
    :   'ensures'
    ;

EVALUATES
    :   'eval'
    |   'evaluates'
    ;

EXEMPLAR
    :   'exemplar'
    ;

EXISTS
    :   'There exists'
    |   'there exists'
    ;

EXISTS_UNIQUE
    :   'There exists unique'
    |   'there exists unique'
    ;

EXTERNALLY
    :   'externally'
    ;

FACILITY
    :   'Facility'
    ;

FAC_FINAL
    :   'Facility_Finalization'
    ;

FAC_INIT
    :   'Facility_Initialization'
    ;

FAMILY
    :   'Family'
    ;

FINALIZATION
    :   'finalization'
    ;

FOR
    :   'For'
    |   'for'
    ;

FORALL
    :   'For all'
    |   'for all'
    ;

FORGET
    :   'Forget'
    ;

FROM
    :   'from'
    ;

IF
    :   'If'
    |   'if'
    ;

IFF
    :   'iff'
    ;

IMPLICIT
    :   'Implicit'
    ;

IMPLIES
    :   'implies'
    ;

IN
    :   'is_in'
    ;

INDUCTIVE
    :   'Inductive'
    ;

INDUCTIVE_BASE_NUM
    :   '(i).'
    ;

INDUCTIVE_HYP_NUM
    :   '(ii).'
    ;

INITIALIZATION
    :   'initialization'
    ;

INSTANTIATION
    :   'instantiation'
    ;

INTERSECT
    :   'intersect'
    ;

INTRODUCES
    :   'introduces'
    ;

IS
    :   'is'
    ;

IS_IN
    :   'is_in'
    ;

ITERATE
    :   'Iterate'
    ;

LAMBDA
    :   'lambda'
    ;

LEMMA
    :   'Lemma'
    ;

MAINP_DISP
    :   'mainp_disp'
    ;

MAINTAINING
    :   'maintaining'
    ;

MOD
    :   'mod'
    ;

MODELED
    :   'modeled'
    ;

MODUS
    :   'modus'
    ;

NOT
    :   'not'
    ;

NOT_IN
    :   'is_not_in'
    ;

NOT_PROP_SUBSET
    :   'is_not_proper_subset_of'
    ;

NOT_SUBSET
    :   'is_not_subset_of'
    ;

NOT_SUBSTR
    :   'is_not_substring_of'
    ;

OF
    :   'of'
    ;

ON
    :   'on'
    ;

OP
    :   'op'
    ;

OPERATION
    :   'Oper'
    |   'Operation'
    ;

OR
    :   'or'
    ;

OTHERWISE
    :   'otherwise'
    ;

PERF_FINAL
    :   'perf_finalization'
    ;

PERF_INIT
    :   'perf_initialization'
    ;

PONENS
    :   'ponens'
    ;

PRECIS
    :   'Precis'
    ;

PRESERVES
    :   'pres'
    |   'preserves'
    ;

PRESUME
    :	'Presume'
    ;

PROFILE
    :   'Profile'
    ;

PROCEDURE
    :   'Proc'
    |   'Procedure'
    ;

PROPERTY
    :   'Property'
    ;

PROP_SUBSET
    :   'is_proper_subset_of'
    ;

REALIZATION
    :   'Realization'
    ;

REALIZED
    :   'realized'
    ;

RECORD
    :   'Record'
    ;

RECURSIVE
    :   'Recursive'
    ;

RELATED
    :   'related'
    ;

REM
    :   'rem'
    ;

REMEMBER
    :   'Remember'
    ;

REPLACES
    :   'rpl'
    |   'replaces'
    ;

REPRESENTED
    :   'represented'
    ;

REQUIRES
    :   'requires'
    ;

RESTORES
    :   'rest'
    |   'restores'
    ;

SHARED
    :   'Shared'
    ;

SHAREDVARIABLES
    :   'Shared Variables'
    ;

SHORT_FOR
    :   'short_for'
    ;

SUBSET
    :   'is_subset_of'
    ;

SUBSTR
    :   'is_substring_of'
    ;

SUCHTHAT
    :   'such that'
    ;

THEN
    :   'then'
    ;

THEOREM
    :   'Theorem'
    ;

THEOREM_ASSOCIATIVE
    :   'Theorem (Associative)'
    ;

THEOREM_COMMUTATIVE
    :   'Theorem (Commutative)'
    ;

TYPE
    :   'Type'
    |   'type'
    ;

UNION
    :   'union'
    ;

UPDATES
    :   'upd'
    |   'updates'
    ;

USES
    :   'uses'
    ;

VAR
    :   'Var'
    ;

WHERE
    :   'where'
    ;

WHICH_ENTAILS
    :   'which_entails'
    ;

WHILE
    :   'While'
    ;

WITHOUT
    :   'without'
    ;

WITH_PROFILE
    :   'with_profile'
    ;

// Additional Symbol Tokens

ASSIGN_OP
    :   ':='
    ;

BAR
    :   '|'
    ;

CARAT
    :   '^'
    ;

COLON
    :   ':'
    ;

COMMA
    :   ','
    ;

CONCAT
    :   'o'
    ;

DBL_BAR
    :   '||'
    ;

DBL_LBRACE
    :   '{{'
    ;

DBL_RBRACE
    :   '}}'
    ;

DIVIDE
    :   '/'
    ;

DOT
    :   '.'
    ;

EQL
    :   '='
    ;

EXP
    :   '**'
    ;

FUNCARROW
    :   '->'
    ;

GG
    :   '>>'
    ;

GT
    :   '>'
    ;

GT_EQL
    :   '>='
    ;

HASH
    :   '#'
    ;

LBRACE
    :   '{'
    ;

LL
    :   '<<'
    ;

LPAREN
    :   '('
    ;

LSQBRACK
    :   '['
    ;

LT
    :   '<'
    ;

LT_EQL
    :   '<='
    ;

MINUS
    :   '-'
    ;

MULTIPLY
    :   '*'
    ;

NOT_EQL
    :   '/='
    ;

PLUS
    :   '+'
    ;

QUALIFIER
    :   '::'
    ;

RANGE
    :   '..'
    ;

RBRACE
    :   '}'
    ;

RPAREN
    :   ')'
    ;

RSQBRACK
    :   ']'
    ;

SEMICOLON
    :   ';'
    ;

SWAP_OP
    :   ':=:'
    ;

TILDE
    :   '~'
    ;

// literal rules and fragments

BOOLEAN_LITERAL
    :   'B'
    |   'false'
    |   'true'
    ;

INTEGER_LITERAL
    :   Digits
    ;

REAL_LITERAL
    :   Digits DOT Digits+
    ;

CHARACTER_LITERAL
    :   '\'' SingleCharacter '\''
    ;

STRING_LITERAL
    :   '\"' StringCharacters? '\"'
    ;

fragment
StringCharacters
    :   StringCharacter+
    ;

fragment
StringCharacter
    :   ~["\\]
    ;

fragment
Digits
    :   [0-9]+
    ;

fragment
Digit
    :   [0-9]
    ;

fragment
SingleCharacter
    :   ~['\\]
    ;

// whitespace, identifier rules, and comments

COMMENT
    :   '(*' .*? '*)' -> skip
    ;

IDENTIFIER
    :   LETTER LETTER_OR_DIGIT*
    ;

LETTER
    :   [a-zA-Z]
    ;

LETTER_OR_DIGIT
    :   [a-zA-Z0-9$_]
    ;

LINE_COMMENT
    :   '--' ~[\r\n]* -> skip
    ;

SPACE
    :  [ \t\r\n\u000C]+ -> skip
    ;
