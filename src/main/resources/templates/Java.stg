/*
 * This softare is released under the new BSD 2006 license.
 *
 * Note the new BSD license is equivalent to the MIT License, except for the
 * no-endorsement final clause.
 *
 * Copyright (c) 2007, Clemson University
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of the Clemson University nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This sofware has been developed by past and present members of the
 * Reusable Sofware Research Groups (RSRG) at Clemson University and
 * The Ohio State University.
 */

group Java;
import "Base.stg"

package(directories) ::= "package <directories; separator = {.}>;"

include(directories) ::= "import <directories; separator = {.}>.*;"

class(declaration, variables, classes, constructors, functions, parameters, STDFACS) ::= <<
<declaration> {
	<STDFACS>
    <parameters     :   {l | <l>;}>
	<variables      :   {j | <j.type> <j.name>;}>
    <constructors   :   {v | <constructor(v.modifier, v.name, parameters, variables)>}>
    <classes>
	<functions>
}
>>

facility_class(declaration, variables, classes, functions, invoker, STDFACS) ::= <<
<declaration> {
    <STDFACS>
    <variables      :   {k | public static final <k>}>
    <classes>
    <functions>

    public static void main(String[] args) {
        <declaration.name> start = new <declaration.name>();
    	start.<invoker>();
    }
}
>>

class_declaration(modifier, kind, name, extension, implementations) ::= <<
    <modifier> <kind> <name> <extension> <implementations>
>>

class_extends(name) ::= "extends <name>"

class_implements(names) ::= "implements <names; separator = {, }>"

operation_argument_item(realization, actualQualifier, actualName,
                        formalname, type, function) ::= <<
new <realization>.<function.name>() {
    <function   :  {f | <function_def("public", f.type, f.name, f.parameters,
                                  f.facilities, f.variables,
    f.parameters    : { p | <actualQualifier>.<actualName>((TYPE)<p.name>);}
    )>}>

}
>>

//-------------------------------------------------------------------
//   facilities
//-------------------------------------------------------------------

qualified_type(concept, name) ::= "<concept>.<name>"

var_decl(modifier, type, name, init) ::= "<type> <name> = <init>;"

rtype_init(typeName) ::= "getType<typeName>().initialValue()"

var_init(type, facility, arguments) ::= <<
<facility>.create<type.name>(<arguments; separator = ", ">)>>

facility_dec(type, name, rhs) ::= <%<type> <name> = <rhs>;%>

facility_init(realization, arguments, isProxied) ::= <%
    <if(isProxied)><realization>.createProxy
    <else>new <realization><endif>(<arguments; separator = ", ">)%>

facility_proxied_init(realization, arguments) ::= <%
    <realization>.createProxy(<arguments; separator = ", ">)%>

//-------------------------------------------------------------------
//   classes
//-------------------------------------------------------------------

record_class(declaration, variables) ::= <%
<declaration> {
    <declaration.name>_Rep rep;
    <declaration.name>() {
        rep = new <declaration.name>_Rep();
    }
    public Object getRep() {
        return rep;
    }
    public void setRep(Object o) {
        rep = (<declaration.name>_Rep)o;
    }
    public RType initialValue() {
        return new <declaration.name>();
    }
    public String toString() {
        return rep.toString();
    }
}
class <declaration.name>_Rep {
    <variables      : {v | <v.type> <v.name>;}>
    <declaration.name>_Rep() {
        <variables  : {v | <v.name> = <v.init>;}>
    }
    public String toString() {
        StringBuffer sb = new StringBuffer();
        <variables : {v | sb.append(<v.name>.toString());}>
        return sb.toString();
    }
}%>

//-------------------------------------------------------------------
//   constructors
//-------------------------------------------------------------------

constructor(modifier, name, parameters, variables) ::= <%
<modifier> <name>(<parameters; separator = ", ">) {
    <parameters : {p | this.<p.name> = <p.name>;}>
    <variables  : {v | <v.name> = <v.init>;}>
}%>

unqualified_call(name, arguments) ::= <%
    <name>(<arguments; separator = ", ">);%>

qualified_call(qualifier, name, arguments) ::= <%
    <qualifier>.<name>(<arguments; separator = ", ">);%>

name_exp(name) ::= <%<name>%>

variable_dot_exp(modulename, typename, name, field, arguments) ::= <%
    (((<modulename>.<typename>)<first(arguments)>).rep.<rest(arguments);
    separator = {.}>
%>

param_exp(qualifier, name, arguments) ::=
    <%<qualifier>.<name>(<arguments; separator = ", ">)%>

while(arguments, stmts) ::= <%
while (((Std_Boolean_Realiz.Boolean)(<arguments>)).val) {
    <stmts>
}%>