/*
 * This softare is released under the new BSD 2006 license.
 *
 * Note the new BSD license is equivalent to the MIT License, except for the
 * no-endorsement final clause.
 *
 * Copyright (c) 2007, Clemson University
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of the Clemson University nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This sofware has been developed by past and present members of the
 * Reusable Software Research Groups (RSRG) at Clemson University and
 * The Ohio State University.
 */

group Java;
import "Base.stg"

package(directories) ::= <<
/**
 * This class was automatically generated by the RESOLVE to Java
 * translator. This file should not be modified.
 */
package <directories; separator = {.}>;
>>

include(directories) ::= "import <directories; separator = {.}>.*;"

interface_class(name, extend, classes, functions, public=true) ::= <<
<if(public)>public interface <name> extends <extend> {
<else>interface <name> extends <extend> {<endif>
    <classes; separator = "\n">
    <functions; separator = "\n">
}>>

facility_class(name, variables, records, functions, invoker) ::= <<
public class <name> {

    // These standard facilities are hardcoded into Java.stg but can be
    // removed once the controller recieves some attention.
    public static final Boolean_Template Std_Boolean_Fac =
	 new Std_Boolean_Realiz();
	public static final Integer_Template Std_Integer_Fac =
	 new Std_Integer_Realiz();
	public static final Character_Template Std_Character_Fac =
	 new Std_Character_Realiz();
	public static final Char_Str_Template Std_Char_Str_Fac =
	 new Std_Char_Str_Realiz();

    <variables  : {k | public static final <k>}>
    <functions  : {f | <function_def("public static", f.type, f.name,
                                      f.parameters, f.facilities, f.variables,
                                      f.stmts)>}; separator = "\n">
    <records; separator = "\n">
    public static void main(String[] args) {
        <name> start = new <name>();
    	start.<invoker>();
    }
}>>

concept_body_class(name, implement, parameters, variables, functions,
classes) ::= <<
public class <name> extends RESOLVE_BASE implements <implement> {

    // These standard facilities are hardcoded into Java.stg but can be
    // removed once the controller recieves some attention.
    Boolean_Template Std_Boolean_Fac =
	 new Std_Boolean_Realiz();
	Integer_Template Std_Integer_Fac =
	 new Std_Integer_Realiz();
	Character_Template Std_Character_Fac =
	 new Std_Character_Realiz();
	Char_Str_Template Std_Char_Str_Fac =
	 new Std_Char_Str_Realiz();

    <parameters : {p | <p>;}; separator = "\n">
    <variables  : {j | <j.type> <j.name>;}; separator = "\n">

    public <name>(<parameters; separator = ", ">) {
        <parameters : {p | this.<p.name> = <p.name>;}; separator = "\n">
        <variables  : {v | <v.name> = <v.init>;}; separator = "\n">
    }

    <classes    ; separator = "\n">
    <functions  ; separator = "\n">
}>>

enhancement_body_class(name, implement, parameters, variables, functions,
conceptfunctions, classes) ::= <<
public class <name> implements <implement; separator = ", "> {

    // These standard facilities are hardcoded into Java.stg but can be
    // removed once the controller recieves some attention.
    Boolean_Template Std_Boolean_Fac =
	 new Std_Boolean_Realiz();
	Integer_Template Std_Integer_Fac =
	 new Std_Integer_Realiz();
	Character_Template Std_Character_Fac =
	 new Std_Character_Realiz();
	Char_Str_Template Std_Char_Str_Fac =
	 new Std_Char_Str_Realiz();

    <parameters : {p | <p>;}; separator = "\n">
    <variables  : {j | <j.type> <j.name>;}; separator = "\n">
	<first(implement)> con;

    public <name>(<parameters; separator = ", ">, <first(implement)> con) {
        <parameters : {p | this.<p.name> = <p.name>;}; separator = "\n">
        <variables  : {v | <v.name> = <v.init>;}; separator = "\n">
        this.con = con;
    }

    <functions; separator = "\n">

    public void swap(RType r1, RType r2) {
		con.swap(r1, r2);
	}
	public void assign(RType r1, RType r2) {
		con.assign(r1, r2);
	}
	<conceptfunctions; separator = "\n">

    public Object invoke(Object proxy, Method method, Object[] args) throws
    Throwable {
        if ("<first(functions).name>".equals(method.getName())) {
            return method.invoke(this, args);
        }
        <rest(functions) :
            {e | else if ("<e.name>".equals(method.getName()) {
                return method.invoke(this, args);
            \} }>
        else {
            return method.invoke(con, args);
        }
    }

    public static <first(implement)> createProxy(<parameters; separator = ", ">
        , <first(implement)> toWrap) {

        <name> eObj = new <name>(<parameters : {p | <p.name>}; separator =
        ", "><if(parameters)>,<endif> toWrap);
        Class[] toWrapInterfaces = toWrap.getClass().getInterfaces();
        Class[] thisInterfaces = new Class[toWrapInterfaces.length+1];
        Class[] tmpInterfaces = eObj.getClass().getInterfaces();
        thisInterfaces[0] = tmpInterfaces[0];
        System.arraycopy(toWrapInterfaces, 0, thisInterfaces, 1,
                                                 toWrapInterfaces.length);

        return (<first(implement)>)(Proxy.newProxyInstance(<first(implement)>
            .class.getClassLoader(), thisInterfaces, eObj));
    }
}>>

enhanced_stmt(returns, name, arguments) ::= <%
    <if(returns)>return<endif> con.<name>(<arguments; separator = ", ">);%>



// You need to look up the function and see what the declared type of the
// parameters for the actual function...
//new BubbleSort_Realiz.Order() {
//    public void Order(RType  parm1, RType  parm2) {
 //       Ordered((Integer_Template.Integer)p0, (Integer_Template.Integer)p1);
 //   }
//}
operation_argument_item(realization, actualQualifier, actualName,
                        formalname, type, function) ::= <<

new <realization>.<function.name>() {
    <function   :  {f | <function_def("public", f.type, f.name, f.parameters,
                                  f.facilities, f.variables,
    f.parameters    : { p | <actualQualifier>.<actualName>((TYPE)<p.name>);}
    )>}>
}
>>

//-------------------------------------------------------------------
//   facilities
//-------------------------------------------------------------------

qualified_type(concept, name) ::= <%<concept>.<name>%>

var_decl(modifier, type, name, init) ::= <%<type> <name> = <init>;%>

rtype_init(typeName) ::= <%getType<typeName>().initialValue()%>

var_init(type, facility, arguments) ::= <%
    <facility>.create<type.name>(<arguments; separator = ", ">)%>

enhancement_var_init(type, arguments) ::= <%
    con.create<type.name>(<arguments; separator = ", ">)%>

facility_dec(type, name, rhs) ::= <%<type> <name> = <rhs>;%>

facility_init(realization, arguments, isProxied) ::= <%
    <if(isProxied)><realization>.createProxy
    <else>new <realization><endif>(<arguments; separator = ", ">)%>

facility_proxied_init(realization, arguments) ::= <%
    <realization>.createProxy(<arguments; separator = ", ">)%>

//-------------------------------------------------------------------
//   classes
//-------------------------------------------------------------------

record_class(name, implement, declaration, variables, facility) ::= <<
<if(facility)>class <name> extends RESOLVE_BASE implements RType {
<else>class <name> implements <implement><endif> {
    <name>_Rep rep;
    <name>() {
        rep = new <name>_Rep();
    }
    public Object getRep() {
        return rep;
    }
    public void setRep(Object o) {
        rep = (<name>_Rep)o;
    }
    public RType initialValue() {
        return new <name>();
    }
    public String toString() {
        return rep.toString();
    }
}
class <name>_Rep {
    <variables : {v | <v.type> <v.name>;}; separator = "\n">
    <name>_Rep() {
        <variables : {v | <v.name> = <v.init>;}; separator = "\n">
    }
    public String toString() {
        StringBuffer sb = new StringBuffer();
        <variables : {v | sb.append(<v.name>.toString());}; separator = "\n">
        return sb.toString();
    }
}>>

//-------------------------------------------------------------------
//   constructors
//-------------------------------------------------------------------

unqualified_call(name, arguments) ::= <%
    <name>(<arguments; separator = ", ">);%>

qualified_call(qualifier, name, arguments) ::= <%
    <qualifier>.<name>(<arguments; separator = ", ">);%>

name_exp(name) ::= <%<name>%>

variable_dot_exp(modulename, typename, name, field, arguments) ::= <%
    ((<modulename>.<typename>)<first(arguments)>).rep.<rest(arguments);
    separator = {.}>
%>

qualified_param_exp(qualifier, name, arguments) ::=
    <%<qualifier>.<name>(<arguments; separator = ", ">)%>

unqualified_param_exp(name, arguments) ::=
    <%<name>(<arguments; separator = ", ">)%>

while(arguments, stmts) ::= <<
while (((Std_Boolean_Realiz.Boolean)(<arguments>)).val) {
    <stmts; separator = "\n">
}>>