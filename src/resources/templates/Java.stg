group Java;
import "Base.stg"

package(directories) ::= <<
/**
 * This class was automatically generated by the RESOLVE to Java
 * translator. This file should not be modified.
 */
package <directories; separator = {.}>;
>>

include(directories) ::= "import <directories; separator = {.}>.*;"

interface_class(name, extend, classes, functions, public=true) ::= <<
<if(public)>public interface <name> <if(extend)>extends <extend><endif> {
<else>interface <name> <if(extend)>extends <extend><endif> {<endif>
	<classes; separator = "\n">
    <functions; separator = "\n">
}>>

facility_class(name, variables, records, functions, invoker) ::= <<
public class <name> {

    // These standard facilities are hardcoded into Java.stg but can be
    // removed once the controller receives some attention.
	public static final Boolean_Template Std_Boolean_Fac =
		new Std_Boolean_Realiz();
	public static final Integer_Template Std_Integer_Fac =
		new Std_Integer_Realiz();
	public static final Character_Template Std_Character_Fac =
		new Std_Character_Realiz();
	public static final Char_Str_Template Std_Char_Str_Fac =
		new Std_Char_Str_Realiz();

    <variables  : {k | public final <k>}; separator = "\n">

    <functions  : {f | <function_def("public", f.type, f.name,
                                      f.parameters, f.facilities, f.variables,
                                      f.stmts)>}; separator = "\n\n">
    <records; separator = "\n\n">
    public static void main(String[] args) {
		<name> start = new <name>();
		start.<invoker>();
	}
}>>

concept_body_class(name, implement, parameters, variables, functions,
classes) ::= <<
public class <name> extends RESOLVE_BASE implements <implement> {

	// These standard facilities are hardcoded into Java.stg but can be
	// removed once the controller receives some attention.
    Boolean_Template Std_Boolean_Fac =
		new Std_Boolean_Realiz();
	Integer_Template Std_Integer_Fac =
		new Std_Integer_Realiz();
	Character_Template Std_Character_Fac =
		new Std_Character_Realiz();
	Char_Str_Template Std_Char_Str_Fac =
		new Std_Char_Str_Realiz();

	<parameters : {p | <p>;}; separator = "\n">
	<variables  : {j | <j.type> <j.name>;}; separator = "\n">

	public <name>(<parameters; separator = ", ">) {
		<parameters : {p | this.<p.name> = <p.name>;}; separator = "\n">
		<variables  : {v | <v.name> = <v.init>;}; separator = "\n">
	}

	<classes    ; separator = "\n">
	<functions  ; separator = "\n\n">
}>>

enhancement_body_class(name, implement, parameters, variables, functions,
conceptfunctions, conceptname, classes) ::= <<
public class <name> implements <implement; separator = ", "> {

    // These standard facilities are hardcoded into Java.stg but can be
    // removed once the controller receives some attention.
    Boolean_Template Std_Boolean_Fac =
		new Std_Boolean_Realiz();
	Integer_Template Std_Integer_Fac =
		new Std_Integer_Realiz();
	Character_Template Std_Character_Fac =
		new Std_Character_Realiz();
	Char_Str_Template Std_Char_Str_Fac =
		new Std_Char_Str_Realiz();

	<parameters : {p | <p>;}; separator = "\n">
	<variables  : {j | <j.type> <j.name>;}; separator = "\n">
	<conceptname> con;
	<classes>

	public <name>(<param_writer([parameters, conceptname : {c | <c> con}])>) {
		<parameters : {p | this.<p.name> = <p.name>;}; separator = "\n">
		<variables  : {v | <v.name> = <v.init>;}; separator = "\n">
		this.con = con;
	}

	<functions; separator = "\n">
	public void swap(RType r1, RType r2) {
		con.swap(r1, r2);
	}
	public void assign(RType r1, RType r2) {
		con.assign(r1, r2);
	}
	<conceptfunctions; separator = "\n\n">
	public Object invoke(Object proxy, Method method, Object[] args) throws
	Throwable {
		if ("<first(functions).name>".equals(method.getName())) {
			return method.invoke(this, args);
		}
		<rest(functions) :
            {e | else if ("<e.name>".equals(method.getName())) {
			return method.invoke(this, args);
            \} }>
        else {
			return method.invoke(con, args);
        }
    }

    public static <conceptname> createProxy(<param_writer([parameters,
    conceptname : {c | <c> toWrap}])>) {

        <name> eObj = new <name>(<param_writer([parameters : {p | <p.name>},
        "toWrap"])>);
        Class[] toWrapInterfaces = toWrap.getClass().getInterfaces();
        Class[] thisInterfaces = new Class[toWrapInterfaces.length+1];
        Class[] tmpInterfaces = eObj.getClass().getInterfaces();
        thisInterfaces[0] = tmpInterfaces[0];
        System.arraycopy(toWrapInterfaces, 0, thisInterfaces, 1,
                                                 toWrapInterfaces.length);

        return (<conceptname>)(Proxy.newProxyInstance(<conceptname>
            .class.getClassLoader(), thisInterfaces, eObj));
    }
}>>

param_writer(p) ::= <%<p; separator = ", ">%>

enhanced_stmt(returns, name, arguments) ::= <%
    <if(returns)>return<endif> con.<name>(<arguments; separator = ", ">);%>

operation_argument_item(realization, actualQualifier, actualName, type,
function, castedArguments, hasReturn) ::= <<

new <realization>.<function.name>() {
    <function   :  {f | <function_def("public", f.type, f.name, f.parameters,
                                  f.facilities, f.variables, { <if(hasReturn)>return <endif><if(actualQualifier)><actualQualifier>.<endif><actualName>(<castedArguments : {c | (<c.type>) <c.name>}; separator = ", ">); }
    )>}>
}>>

//-------------------------------------------------------------------
//   facilities
//-------------------------------------------------------------------

qualified_type(concept, name) ::= "<concept>.<name>"

var_decl(modifier, type, name, init) ::= "<type> <name> = <init>;"

rtype_init(typeName) ::= "getType<typeName>().initialValue()"

facility_type_var_init(name) ::= "new <name>()"

var_init(type, facility, arguments) ::= <%
    <facility>.create<type.name>(<arguments; separator = ", ">)%>

enhancement_var_init(type, arguments) ::= <%
    con.create<type.name>(<arguments; separator = ", ">)%>

facility_dec(type, name, rhs) ::= "<type> <name> = <rhs>;"

facility_init(realization, arguments, isProxied) ::= <%
    <if(isProxied)><realization>.createProxy
    <else>new <realization><endif>(<arguments; separator = ", ">)%>

facility_proxied_init(realization, arguments) ::= <%
    <realization>.createProxy(<arguments; separator = ", ">)%>

//-------------------------------------------------------------------
//   classes
//-------------------------------------------------------------------

record_class(name, implement, declaration, variables, facility, stmts) ::= <<
<if(facility)>class <name> extends RESOLVE_BASE implements RType
<else>class <name> implements <implement><endif> {
    <name>_Rep rep;
    
    <name>() {
        rep = new <name>_Rep();
    }
    
    public Object getRep() {
        return rep;
    }
    
    public void setRep(Object o) {
        rep = (<name>_Rep)o;
    }
    
    public RType initialValue() {
        return new <name>();
    }
    
    public String toString() {
        return rep.toString();
    }
}

class <name>_Rep {
    <variables : {v | <v.type> <v.name>;}; separator = "\n">
    
    <name>_Rep() {
        <variables : {v | <v.name> = <v.init>;}; separator = "\n">
        <stmts; separator = "\n">
    }
    
    public String toString() {
        StringBuffer sb = new StringBuffer();
        <variables : {v | sb.append(<v.name>.toString());}; separator = "\n">
        return sb.toString();
    }
}>>

//-------------------------------------------------------------------
//   constructors
//-------------------------------------------------------------------

unqualified_call(name, arguments) ::= <%
    <name>(<arguments; separator = ", ">);%>

qualified_call(qualifier, name, arguments) ::= <%
    <qualifier>.<name>(<arguments; separator = ", ">);%>

enhanced_call(enhancementname, facilityname, name, arguments) ::= <%
    ((<enhancementname>)<facilityname>).<name>(<arguments; separator = ", ">);%>

call_stmt(qualifier, name, arguments) ::= <%
<if(qualifier)><qualifier>.<endif><name>(<arguments; separator = ", ">);%>

name_exp(name) ::= <%<name>%>

variable_dot_exp(modulename, typename, name, field, arguments) ::= <%
    ((<modulename>.<typename>)<first(arguments)>).rep.<rest(arguments);
    separator = {.}>
%>

qualified_param_exp(qualifier, name, arguments) ::=
    <%<qualifier>.<name>(<arguments; separator = ", ">)%>

unqualified_param_exp(name, arguments) ::=
    <%<name>(<arguments; separator = ", ">)%>

while(arguments, stmts) ::= <<
while (((Std_Boolean_Realiz.Boolean)(<arguments>)).val) {
    <stmts; separator = "\n">
}>>

if(arguments, stmts) ::= <<
if (((Std_Boolean_Realiz.Boolean)(<arguments>)).val) {
    <stmts; separator = "\n">
}>>

else(stmts) ::= <<
else {
    <stmts; separator = "\n">
}>>