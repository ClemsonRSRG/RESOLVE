/*
 * GeneralPurposeProver.java
 * ---------------------------------
 * Copyright (c) 2022
 * RESOLVE Software Research Group
 * School of Computing
 * Clemson University
 * All rights reserved.
 * ---------------------------------
 * This file is subject to the terms and conditions defined in
 * file 'LICENSE.txt', which is part of this source code package.
 */
package edu.clemson.rsrg.nProver;

import edu.clemson.rsrg.absyn.expressions.Exp;
import edu.clemson.rsrg.init.CompileEnvironment;
import edu.clemson.rsrg.init.ResolveCompiler;
import edu.clemson.rsrg.init.flag.Flag;
import edu.clemson.rsrg.init.flag.FlagDependencies;
import edu.clemson.rsrg.init.output.OutputListener;
import edu.clemson.rsrg.nProver.registry.CongruenceClassRegistry;
import edu.clemson.rsrg.nProver.utilities.treewakers.AbstractRegisterSequent;
import edu.clemson.rsrg.nProver.utilities.treewakers.RegisterAntecedent;
import edu.clemson.rsrg.nProver.utilities.treewakers.RegisterSuccedent;
import edu.clemson.rsrg.treewalk.TreeWalker;
import edu.clemson.rsrg.typeandpopulate.symboltables.ModuleScope;
import edu.clemson.rsrg.typeandpopulate.typereasoning.TypeGraph;
import edu.clemson.rsrg.vcgeneration.VCGenerator;
import edu.clemson.rsrg.vcgeneration.sequents.Sequent;
import edu.clemson.rsrg.vcgeneration.utilities.VerificationCondition;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import static edu.clemson.rsrg.vcgeneration.VCGenerator.FLAG_VERIFY_VC;

/**
 * <p>
 * This class is a general purpose prover that attempts to prove the {@code VCs} generated by {@link VCGenerator}.
 * </p>
 *
 * @author Yu-Shan Sun
 * @author Nicodemus Msafiri J. M.
 *
 * @version 1.0
 */
public class GeneralPurposeProver {

    // ===========================================================
    // Member Fields
    // ===========================================================

    /**
     * <p>
     * The current job's compilation environment that stores all necessary objects and flags.
     * </p>
     */
    private final CompileEnvironment myCompileEnvironment;

    /**
     * <p>
     * The module scope for the file we are generating automated proofs for.
     * </p>
     */
    private final ModuleScope myCurrentModuleScope;

    /**
     * <p>
     * The number of tries before halting the automated prover
     * </p>
     */
    private final int myNumTriesBeforeHalting;

    /**
     * <p>
     * The various different output listeners that are expecting an update.
     * </p>
     */
    private List<OutputListener> myOutputListeners;

    /**
     * <p>
     * The number of milliseconds before stopping the prove for a VC.
     * </p>
     */
    private final long myTimeout;

    /**
     * <p>
     * This is the math type graph that indicates relationship between different math types.
     * </p>
     */
    private final TypeGraph myTypeGraph;

    /**
     * <p>
     * The module's final list of verification conditions.
     * </p>
     */
    private final List<VerificationCondition> myVerificationConditions;

    // ===========================================================
    // Flag Strings
    // ===========================================================

    public static final String FLAG_SECTION_NAME = "Prover";
    private static final String FLAG_DESC_GP_PROVER = "General Purpose Automated Prover"; // DESC -- Description
    private static final String FLAG_DESC_PROVER_NUMTRIES = "Number of Failed VCs Before Halting the Prover.";
    private static final String[] NUMTRIES_ARGS = { "numtries" };
    private static final String FLAG_DESC_PROVER_TIMEOUT = "Number of Milliseconds to Use as a Timeout Before Skipping Proving a VC.";
    private static final String[] FLAG_TIMEOUT_ARGS = { "milliseconds" };

    // ===========================================================
    // Flags
    // ===========================================================

    /**
     * Tells the compiler to prove the sequent VCs
     */
    public static final Flag FLAG_PROVE = new Flag(FLAG_SECTION_NAME, "sprove", FLAG_DESC_GP_PROVER); // sequent prove

    /**
     * <p>
     * Specifies number of milliseconds before skipping proving a VC.
     * </p>
     */
    private static final Flag FLAG_TIMEOUT = new Flag(FLAG_SECTION_NAME, "timeout", FLAG_DESC_PROVER_TIMEOUT,
            FLAG_TIMEOUT_ARGS, Flag.Type.HIDDEN);

    /**
     * <p>
     * Specify number of failed VCs before halting the prover.
     * </p>
     */
    private static final Flag FLAG_NUMTRIES = new Flag(FLAG_SECTION_NAME, "num_tries", FLAG_DESC_PROVER_NUMTRIES,
            NUMTRIES_ARGS, Flag.Type.HIDDEN);

    /**
     * <p>
     * Add all the required and implied flags for the {@code GeneralPurposeProver}.
     * </p>
     */
    public static void setUpFlags() {
        FlagDependencies.addImplies(FLAG_PROVE, FLAG_VERIFY_VC); // adding prove flag, also add verify VC flag
        FlagDependencies.addRequires(FLAG_TIMEOUT, FLAG_PROVE);
        FlagDependencies.addRequires(FLAG_NUMTRIES, FLAG_PROVE);
    }

    // ===========================================================
    // Constructors
    // ===========================================================

    /**
     * <p>
     * This creates an instance of the general purpose automated prover.
     * </p>
     *
     * @param vcs
     *            The list of VCs to be proven.
     * @param moduleScope
     *            The module scope associated with {@code name}.
     * @param compileEnvironment
     *            The current job's compilation environment that stores all necessary objects and flags.
     */
    public GeneralPurposeProver(List<VerificationCondition> vcs, ModuleScope moduleScope,
            CompileEnvironment compileEnvironment) {
        myCompileEnvironment = compileEnvironment;
        myCurrentModuleScope = moduleScope;
        myOutputListeners = myCompileEnvironment.getOutputListeners();
        myTypeGraph = compileEnvironment.getTypeGraph();
        myVerificationConditions = vcs;

        // Timeout
        if (myCompileEnvironment.flags.isFlagSet(FLAG_TIMEOUT)) {
            myTimeout = Long.parseLong(myCompileEnvironment.flags.getFlagArgument(FLAG_TIMEOUT, "milliseconds"));
        } else {
            myTimeout = 5000;
        }

        // Number of Tries
        if (myCompileEnvironment.flags.isFlagSet(FLAG_NUMTRIES)) {
            myNumTriesBeforeHalting = Integer
                    .parseInt(myCompileEnvironment.flags.getFlagArgument(FLAG_NUMTRIES, "numtries"));
        } else {
            myNumTriesBeforeHalting = -1;
        }
    }

    // ===========================================================
    // Public Methods
    // ===========================================================

    /**
     * <p>
     * This method runs the general purpose prover on all the VCs.
     * </p>
     */
    public void proveVCs() {
        // Loop through each of the VCs and attempt to prove them
        for (VerificationCondition vc : myVerificationConditions) {
            // Obtain the sequent to be proved
            Sequent sequent = vc.getSequent();
            if (myCompileEnvironment.flags.isFlagSet(ResolveCompiler.FLAG_DEBUG)) {
                StringBuffer sb = new StringBuffer();
                sb.append("\n-----------------Proving VC-----------------\n\n");
                sb.append("VC ");
                sb.append(vc.getName());
                sb.append("\n\n");

                myCompileEnvironment.getStatusHandler().info(null, sb.toString());
            }

            // Create a registry and label map
            CongruenceClassRegistry<Integer, String, String, String> registry = new CongruenceClassRegistry<>(1000,
                    1000, 1000, 1000);
            Map<String, Integer> expLabels = new LinkedHashMap<>();

            // NM: 0, 1 are spared for <= (1), = (2), e.t.c., the list can expand with
            // with more reflexive operators
            // preload <=, = into the map
            expLabels.put("<=", AbstractRegisterSequent.OP_LESS_THAN_OR_EQUALS);
            expLabels.put("=", AbstractRegisterSequent.OP_EQUALS);

            // Visit antecedents
            RegisterAntecedent regAntecedent = new RegisterAntecedent(registry, expLabels, 3);
            for (Exp exp : sequent.getAntecedents()) {
                TreeWalker.visit(regAntecedent, exp);
            }

            // Visit consequents
            RegisterSuccedent regConsequent = new RegisterSuccedent(regAntecedent.getRegistry(),
                    regAntecedent.getExpLabels(), regAntecedent.getNextLabel());
            for (Exp exp : sequent.getConcequents()) {
                TreeWalker.visit(regConsequent, exp);
            }

            if (myCompileEnvironment.flags.isFlagSet(ResolveCompiler.FLAG_DEBUG)) {
                StringBuffer sb = new StringBuffer();
                for (String exp : expLabels.keySet()) {
                    sb.append(exp);
                    sb.append(" -> ");
                    sb.append(expLabels.get(exp));
                    sb.append("\n");
                }
                sb.append("\n---------------Done Proving VC---------------\n");

                myCompileEnvironment.getStatusHandler().info(null, sb.toString());
            }
        }
    }

}