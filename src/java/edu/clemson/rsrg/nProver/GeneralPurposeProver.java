/*
 * GeneralPurposeProver.java
 * ---------------------------------
 * Copyright (c) 2023
 * RESOLVE Software Research Group
 * School of Computing
 * Clemson University
 * All rights reserved.
 * ---------------------------------
 * This file is subject to the terms and conditions defined in
 * file 'LICENSE.txt', which is part of this source code package.
 */
package edu.clemson.rsrg.nProver;

import edu.clemson.rsrg.absyn.declarations.moduledecl.*;
import edu.clemson.rsrg.absyn.expressions.Exp;
import edu.clemson.rsrg.init.CompileEnvironment;
import edu.clemson.rsrg.init.flag.Flag;
import edu.clemson.rsrg.init.flag.FlagDependencies;
import edu.clemson.rsrg.init.output.OutputListener;
import edu.clemson.rsrg.nProver.output.VCProverResult;
import edu.clemson.rsrg.nProver.registry.CongruenceClassRegistry;
import edu.clemson.rsrg.nProver.utilities.theorems.RelevantTheoremExtractor;
import edu.clemson.rsrg.nProver.utilities.treewakers.AbstractRegisterSequent;
import edu.clemson.rsrg.nProver.utilities.treewakers.RegisterAntecedent;
import edu.clemson.rsrg.nProver.utilities.treewakers.RegisterSuccedent;
import edu.clemson.rsrg.parsing.data.LocationDetailModel;
import edu.clemson.rsrg.treewalk.TreeWalker;
import edu.clemson.rsrg.typeandpopulate.entry.TheoremEntry;
import edu.clemson.rsrg.typeandpopulate.symboltables.ModuleScope;
import edu.clemson.rsrg.typeandpopulate.typereasoning.TypeGraph;
import edu.clemson.rsrg.vcgeneration.VCGenerator;
import edu.clemson.rsrg.vcgeneration.sequents.Sequent;
import edu.clemson.rsrg.vcgeneration.utilities.VerificationCondition;
import java.util.LinkedHashMap;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;
import org.stringtemplate.v4.STGroupFile;
import static edu.clemson.rsrg.vcgeneration.VCGenerator.FLAG_VERIFY_VC;

/**
 * <p>
 * This class is a general purpose prover that attempts to prove the {@code VCs} generated by {@link VCGenerator}.
 * </p>
 *
 * @author Yu-Shan Sun
 * @author Nicodemus Msafiri J. M.
 *
 * @version 1.0
 */
public class GeneralPurposeProver {

    // ===========================================================
    // Member Fields
    // ===========================================================

    /**
     * <p>
     * The current job's compilation environment that stores all necessary objects and flags.
     * </p>
     */
    private final CompileEnvironment myCompileEnvironment;

    /**
     * <p>
     * The module scope for the file we are generating automated proofs for.
     * </p>
     */
    private final ModuleScope myCurrentModuleScope;

    /**
     * <p>
     * The number of tries before halting the automated prover
     * </p>
     */
    private final int myNumTriesBeforeHalting;

    /**
     * <p>
     * The various different output listeners that are expecting an update.
     * </p>
     */
    private List<OutputListener> myOutputListeners;

    /**
     * <p>
     * The number of milliseconds before stopping the prove for a VC.
     * </p>
     */
    private final long myTimeout;

    /**
     * <p>
     * The total number of milliseconds spent proving VCs in this file.
     * </p>
     */
    private long myTotalElapsedTime;

    /**
     * <p>
     * This is the math type graph that indicates relationship between different math types.
     * </p>
     */
    private final TypeGraph myTypeGraph;

    /**
     * <p>
     * The module's final list of verification conditions.
     * </p>
     */
    private final List<VerificationCondition> myVerificationConditions;

    // -----------------------------------------------------------
    // Output-Related
    // -----------------------------------------------------------

    /**
     * <p>
     * String template groups for storing all the prover details.
     * </p>
     */
    private final STGroup mySTGroup;

    /**
     * <p>
     * String template for the prover generation details model.
     * </p>
     */
    private final ST myProofGenDetailsModel;

    /**
     * <p>
     * A list containing the prover results for each VC.
     * </p>
     */
    private final List<VCProverResult> myVCProverResults;

    // ===========================================================
    // Flag Strings
    // ===========================================================

    public static final String FLAG_SECTION_NAME = "Prover";
    private static final String FLAG_DESC_GP_PROVER = "General Purpose Automated Prover"; // DESC -- Description
    private static final String FLAG_DESC_PROVER_NUMTRIES = "Number of Failed VCs Before Halting the Prover.";
    private static final String[] NUMTRIES_ARGS = { "numtries" };
    private static final String FLAG_DESC_PROVER_TIMEOUT = "Number of Milliseconds to Use as a Timeout Before Skipping Proving a VC.";
    private static final String[] FLAG_TIMEOUT_ARGS = { "milliseconds" };

    // ===========================================================
    // Flags
    // ===========================================================

    /**
     * Tells the compiler to prove the sequent VCs
     */
    public static final Flag FLAG_PROVE = new Flag(FLAG_SECTION_NAME, "sprove", FLAG_DESC_GP_PROVER); // sequent prove

    /**
     * <p>
     * Specifies number of milliseconds before skipping proving a VC.
     * </p>
     */
    private static final Flag FLAG_TIMEOUT = new Flag(FLAG_SECTION_NAME, "timeout", FLAG_DESC_PROVER_TIMEOUT,
            FLAG_TIMEOUT_ARGS, Flag.Type.HIDDEN);

    /**
     * <p>
     * Specify number of failed VCs before halting the prover.
     * </p>
     */
    private static final Flag FLAG_NUMTRIES = new Flag(FLAG_SECTION_NAME, "num_tries", FLAG_DESC_PROVER_NUMTRIES,
            NUMTRIES_ARGS, Flag.Type.HIDDEN);

    /**
     * <p>
     * Add all the required and implied flags for the {@code GeneralPurposeProver}.
     * </p>
     */
    public static void setUpFlags() {
        FlagDependencies.addImplies(FLAG_PROVE, FLAG_VERIFY_VC); // adding prove flag, also add verify VC flag
        FlagDependencies.addRequires(FLAG_TIMEOUT, FLAG_PROVE);
        FlagDependencies.addRequires(FLAG_NUMTRIES, FLAG_PROVE);
    }

    // ===========================================================
    // Constructors
    // ===========================================================

    /**
     * <p>
     * This creates an instance of the general purpose automated prover.
     * </p>
     *
     * @param vcs
     *            The list of VCs to be proven.
     * @param moduleScope
     *            The module scope associated with {@code name}.
     * @param compileEnvironment
     *            The current job's compilation environment that stores all necessary objects and flags.
     */
    public GeneralPurposeProver(List<VerificationCondition> vcs, ModuleScope moduleScope,
            CompileEnvironment compileEnvironment) {
        myCompileEnvironment = compileEnvironment;
        myCurrentModuleScope = moduleScope;
        myOutputListeners = myCompileEnvironment.getOutputListeners();
        mySTGroup = new STGroupFile("templates/nProverVerboseOutput.stg");
        myTotalElapsedTime = 0;
        myTypeGraph = compileEnvironment.getTypeGraph();
        myVCProverResults = new ArrayList<>(vcs.size());
        myVerificationConditions = vcs;
        myProofGenDetailsModel = mySTGroup.getInstanceOf("outputProofGenDetails");

        // Timeout
        if (myCompileEnvironment.flags.isFlagSet(FLAG_TIMEOUT)) {
            myTimeout = Long.parseLong(myCompileEnvironment.flags.getFlagArgument(FLAG_TIMEOUT, "milliseconds"));
        } else {
            myTimeout = 5000;
        }

        // Number of Tries
        if (myCompileEnvironment.flags.isFlagSet(FLAG_NUMTRIES)) {
            myNumTriesBeforeHalting = Integer
                    .parseInt(myCompileEnvironment.flags.getFlagArgument(FLAG_NUMTRIES, "numtries"));
        } else {
            myNumTriesBeforeHalting = -1;
        }

        // Store verbose output about this module
        ST header;
        ModuleDec moduleDec = myCurrentModuleScope.getDefiningElement();
        if (moduleDec instanceof ConceptModuleDec) {
            header = mySTGroup.getInstanceOf("outputConceptHeader").add("conceptName", moduleDec.getName().getName());
        } else if (moduleDec instanceof ConceptRealizModuleDec) {
            header = mySTGroup.getInstanceOf("outputConceptRealizHeader")
                    .add("realizName", moduleDec.getName().getName())
                    .add("conceptName", ((ConceptRealizModuleDec) moduleDec).getConceptName().getName());
        } else if (moduleDec instanceof EnhancementModuleDec) {
            header = mySTGroup.getInstanceOf("outputEnhancementHeader")
                    .add("enhancementName", moduleDec.getName().getName())
                    .add("conceptName", ((EnhancementModuleDec) moduleDec).getConceptName().getName());
        } else if (moduleDec instanceof EnhancementRealizModuleDec) {
            header = mySTGroup.getInstanceOf("outputEnhancementRealizHeader")
                    .add("realizName", moduleDec.getName().getName())
                    .add("enhancementName", ((EnhancementRealizModuleDec) moduleDec).getEnhancementName().getName())
                    .add("conceptName", ((EnhancementRealizModuleDec) moduleDec).getConceptName().getName());
        } else {
            header = mySTGroup.getInstanceOf("outputFacilityHeader").add("facilityName", moduleDec.getName().getName());
        }
        myProofGenDetailsModel.add("fileHeader", header.render());
    }

    // ===========================================================
    // Public Methods
    // ===========================================================

    /**
     * <p>
     * This method returns the prover setting for how many unproved {@code VCs} we allow before halting.
     * </p>
     *
     * @return The number of tries with -1 indicating that we attempt to prove all VCs.
     */
    public final int getNumTriesBeforeHalting() {
        return myNumTriesBeforeHalting;
    }

    /**
     * <p>
     * This method returns the prover setting for the maximum amount of time we can spend proving each {@code VC}.
     * </p>
     *
     * @return The time that can be spent proving each {@code VC} in ms.
     */
    public final long getTimeout() {
        return myTimeout;
    }

    /**
     * <p>
     * This method returns the total elapsed time that we spent proving {@code VCs} in this {@link ModuleDec}.
     * </p>
     *
     * @return The total elapsed time in ms.
     */
    public final long getTotalElapsedTime() {
        return myTotalElapsedTime;
    }

    /**
     * <p>
     * This method returns a list containing the proof details for each {@code VC}.
     * </p>
     *
     * @return A {@link List} of {@link VCProverResult}.
     */
    public final List<VCProverResult> getVCProverResults() {
        return myVCProverResults;
    }

    /**
     * <p>
     * This method returns the verbose mode output with how we attempted to prove each {@code VCs} in this
     * {@link ModuleDec}.
     * </p>
     *
     * @return A string containing lots of details.
     */
    public final String getVerboseModeOutput() {
        return myProofGenDetailsModel.render();
    }

    /**
     * <p>
     * This method runs the general purpose prover on all the VCs.
     * </p>
     */
    public void proveVCs() {
        // Keep track to total elapsed time and number of unproved/timed out VCs
        myTotalElapsedTime = System.currentTimeMillis();
        int numUnproved = 0;

        // Loop through each of the VCs and attempt to prove them
        for (VerificationCondition vc : myVerificationConditions) {
            // Store the start time for generating proofs for this VC
            long startTime = System.nanoTime();
            // Obtain the sequent to be proved
            Sequent sequent = vc.getSequent();
            // Create a registry and label map
            CongruenceClassRegistry<Integer, String, String, String> registry = new CongruenceClassRegistry<>(1000,
                    1000, 1000, 1000);
            Map<String, Integer> expLabels = new LinkedHashMap<>();

            // NM: 0, 1 are spared for <= (1), = (2), etc., the list can expand with more reflexive operators
            // preload <=, = into the map
            expLabels.put("<=", AbstractRegisterSequent.OP_LESS_THAN_OR_EQUALS);
            expLabels.put("=", AbstractRegisterSequent.OP_EQUALS);

            // Visit antecedents
            RegisterAntecedent regAntecedent = new RegisterAntecedent(registry, expLabels, 3);
            for (Exp exp : sequent.getAntecedents()) {
                TreeWalker.visit(regAntecedent, exp);
            }

            // Visit consequents
            RegisterSuccedent regConsequent = new RegisterSuccedent(regAntecedent.getRegistry(),
                    regAntecedent.getExpLabels(), regAntecedent.getNextLabel());
            for (Exp exp : sequent.getConcequents()) {
                TreeWalker.visit(regConsequent, exp);
            }

            // Store the end time for generating proofs for this VC
            long endTime = System.nanoTime();

            // Store the prover results for this VC
            myVCProverResults.add(
                    new VCProverResult(vc, TimeUnit.MILLISECONDS.convert(endTime - startTime, TimeUnit.NANOSECONDS),
                            registry.checkIfProved(), false, false));

            // Store the verbose proof detail for this VC
            String result = registry.checkIfProved() ? "Proved" : "Not Proved";
            storeVCProofVerboseDetail(vc, result, registry, expLabels);
        }

        // Compute the total elapsed time in generating proofs for the VCs in this module
        myTotalElapsedTime = System.currentTimeMillis() - myTotalElapsedTime;

        // applying theorems

        RelevantTheoremExtractor theorems = new RelevantTheoremExtractor(myCurrentModuleScope);

        for (TheoremEntry te : theorems.theoremEntryQuery()) {
            System.out.println(te.getAssertion());
        }

    }

    // ===========================================================
    // Private Methods
    // ===========================================================

    /**
     * <p>
     * An helper method that stores verbose detail about proving this {@code VC}.
     * </p>
     *
     * @param vc
     *            The {@link VerificationCondition} we have attempted to prove.
     * @param result
     *            The prover results.
     * @param registry
     *            The congruence class registry used on this {@code VC}.
     * @param expLabels
     *            The expression labels assigned to the expressions in this {@code VC}.
     */
    private void storeVCProofVerboseDetail(VerificationCondition vc, String result,
            CongruenceClassRegistry<Integer, String, String, String> registry, Map<String, Integer> expLabels) {
        // Create a model for adding all the details associated with this VC.
        LocationDetailModel detailModel = vc.getLocationDetailModel();
        ST vcModel = mySTGroup.getInstanceOf("outputVC");
        vcModel.add("vcNum", vc.getName());

        // Add additional detail if this VC has impacting reduction
        if (vc.getHasImpactingReductionFlag()) {
            vcModel.add("hasImpactingReduction", true);
        }

        // Warn the user if are missing the LocationDetailModel
        if (detailModel != null) {
            vcModel.add("location", detailModel.getDestinationLoc());
            vcModel.add("locationDetail", detailModel.getDetailMessage());
        } else {
            myCompileEnvironment.getStatusHandler().warning(vc.getLocation(), "[FileOutputListener] VC " + vc.getName()
                    + " is missing information about how this VC got generated.");
        }

        // Output the associated sequent
        Sequent sequent = vc.getSequent();
        ST sequentModel = mySTGroup.getInstanceOf("outputSequent");
        sequentModel.add("consequents", sequent.getConcequents());
        sequentModel.add("antecedents", sequent.getAntecedents());

        // Add this sequent to our vc model
        vcModel.add("sequent", sequentModel.render());

        // Store the congruence class registry array information
        ST ccRegistryArraysModel = mySTGroup.getInstanceOf("outputCCRegistryArrays");
        ccRegistryArraysModel.add("clusterArguments", registry.getClusterArgArray());
        ccRegistryArraysModel.add("clusters", registry.getClusterArray());
        ccRegistryArraysModel.add("plantations", registry.getPlantationArray());
        ccRegistryArraysModel.add("classes", registry.getCongruenceClassArray());

        // Add the VC to the VC proof detail model
        ST vcProofDetailModel = mySTGroup.getInstanceOf("outputVCProofDetails");
        vcProofDetailModel.add("vcNum", vc.getName());
        vcProofDetailModel.add("vc", vcModel.render());
        vcProofDetailModel.add("result", result);
        vcProofDetailModel.add("expLabels", expLabels);
        vcProofDetailModel.add("registryArrays", ccRegistryArraysModel.render());

        // Add VC proof detail model to prover generation details
        myProofGenDetailsModel.add("vcProofDetails", vcProofDetailModel.render());
    }
}