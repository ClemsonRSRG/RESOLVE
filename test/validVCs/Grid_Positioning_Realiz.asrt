VCs for Grid_Positioning_Realiz.rb generated Mon Oct 07 15:35:47 EDT 2024

================================= VC(s): =================================

VC 0_1:
Well Defined Correspondence for Grid_Pos at Grid_Positioning_Realiz.rb(4:6)

Goal:
(0 <= GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 0_2:
Well Defined Correspondence for Grid_Pos at Grid_Positioning_Realiz.rb(4:6)

Goal:
(GP.X <= Max_Right)

Given(s):
1. (1 <= Max_Right)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Top)

VC 0_3:
Well Defined Correspondence for Grid_Pos at Grid_Positioning_Realiz.rb(4:6)

Goal:
(0 <= GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 0_4:
Well Defined Correspondence for Grid_Pos at Grid_Positioning_Realiz.rb(4:6)

Goal:
(GP.Y <= Max_Top)

Given(s):
1. (1 <= Max_Top)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Right)

VC 1_1:
Convention for Grid_Pos Generated by Initialization Rule (Concept Type Realization) at Grid_Positioning_Realiz.rb(4:1)

Goal:
(0 <= 0)

Given(s):

VC 1_2:
Convention for Grid_Pos Generated by Initialization Rule (Concept Type Realization) at Grid_Positioning_Realiz.rb(4:1)

Goal:
(0 <= Max_Right)

Given(s):
1. (1 <= Max_Right)

VC 1_3:
Convention for Grid_Pos Generated by Initialization Rule (Concept Type Realization) at Grid_Positioning_Realiz.rb(4:1)

Goal:
(0 <= 0)

Given(s):

VC 1_4:
Convention for Grid_Pos Generated by Initialization Rule (Concept Type Realization) at Grid_Positioning_Realiz.rb(4:1)

Goal:
(0 <= Max_Top)

Given(s):
1. (1 <= Max_Top)

VC 1_5:
Initialization Ensures Clause of Grid_Pos at Grid_Positioning_Template.co(11:17)

Goal:
(0 = 0)

Given(s):

VC 1_6:
Initialization Ensures Clause of Grid_Pos at Grid_Positioning_Template.co(11:17)

Goal:
(0 = 0)

Given(s):

VC 2_1:
Requires Clause of Difference at Grid_Positioning_Realiz.rb(12:10)

Goal:
(min_int <= (GP.X - 1))

Given(s):
1. (min_int <= 0)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= GP.X)
7. (1 <= Max_Top)
8. (1 <= Max_Right)

VC 2_2:
Requires Clause of Difference at Grid_Positioning_Realiz.rb(12:10)

Goal:
((GP.X - 1) <= max_int)

Given(s):
1. (1 <= max_int)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= GP.X)
7. (1 <= Max_Top)
8. (1 <= Max_Right)

VC 2_3:
Type Convention for Grid_Pos Generated by Move_Left at Grid_Positioning_Realiz.rb(11:11)

Goal:
(0 <= (GP.X - 1))

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= GP.X)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 2_4:
Type Convention for Grid_Pos Generated by Move_Left at Grid_Positioning_Realiz.rb(11:11)

Goal:
((GP.X - 1) <= Max_Right)

Given(s):
1. (1 <= Max_Right)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= GP.X)
7. (1 <= Max_Top)

VC 2_5:
Type Convention for Grid_Pos Generated by Move_Left at Grid_Positioning_Realiz.rb(11:11)

Goal:
(0 <= GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= GP.X)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 2_6:
Type Convention for Grid_Pos Generated by Move_Left at Grid_Positioning_Realiz.rb(11:11)

Goal:
(GP.Y <= Max_Top)

Given(s):
1. (1 <= Max_Top)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= GP.X)
7. (1 <= Max_Right)

VC 2_7:
Ensures Clause of Move_Left at Grid_Positioning_Realiz.rb(11:11)

Goal:
((GP.X - 1) = (GP.X - 1))

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= GP.X)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 2_8:
Ensures Clause of Move_Left at Grid_Positioning_Realiz.rb(11:11)

Goal:
(GP.Y = GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= GP.X)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 3_1:
Requires Clause of Sum at Grid_Positioning_Realiz.rb(16:10)

Goal:
(min_int <= (GP.X + 1))

Given(s):
1. (min_int <= 0)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. ((GP.X + 1) <= Max_Right)
7. (1 <= Max_Top)
8. (1 <= Max_Right)

VC 3_2:
Requires Clause of Sum at Grid_Positioning_Realiz.rb(16:10)

Goal:
((GP.X + 1) <= max_int)

Given(s):
1. (1 <= max_int)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. ((GP.X + 1) <= Max_Right)
7. (1 <= Max_Top)
8. (1 <= Max_Right)

VC 3_3:
Type Convention for Grid_Pos Generated by Move_Right at Grid_Positioning_Realiz.rb(15:11)

Goal:
(0 <= (GP.X + 1))

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. ((GP.X + 1) <= Max_Right)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 3_4:
Type Convention for Grid_Pos Generated by Move_Right at Grid_Positioning_Realiz.rb(15:11)

Goal:
((GP.X + 1) <= Max_Right)

Given(s):
1. (1 <= Max_Right)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. ((GP.X + 1) <= Max_Right)
7. (1 <= Max_Top)

VC 3_5:
Type Convention for Grid_Pos Generated by Move_Right at Grid_Positioning_Realiz.rb(15:11)

Goal:
(0 <= GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. ((GP.X + 1) <= Max_Right)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 3_6:
Type Convention for Grid_Pos Generated by Move_Right at Grid_Positioning_Realiz.rb(15:11)

Goal:
(GP.Y <= Max_Top)

Given(s):
1. (1 <= Max_Top)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. ((GP.X + 1) <= Max_Right)
7. (1 <= Max_Right)

VC 3_7:
Ensures Clause of Move_Right at Grid_Positioning_Realiz.rb(15:11)

Goal:
((GP.X + 1) = (GP.X + 1))

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. ((GP.X + 1) <= Max_Right)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 3_8:
Ensures Clause of Move_Right at Grid_Positioning_Realiz.rb(15:11)

Goal:
(GP.Y = GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. ((GP.X + 1) <= Max_Right)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 4_1:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Left at Grid_Positioning_Realiz.rb(19:11)

Goal:
(0 <= GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 4_2:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Left at Grid_Positioning_Realiz.rb(19:11)

Goal:
(GP.X <= Max_Right)

Given(s):
1. (1 <= Max_Right)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Top)

VC 4_3:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Left at Grid_Positioning_Realiz.rb(19:11)

Goal:
(0 <= GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 4_4:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Left at Grid_Positioning_Realiz.rb(19:11)

Goal:
(GP.Y <= Max_Top)

Given(s):
1. (1 <= Max_Top)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Right)

VC 4_5:
Ensures Clause of Is_OK_to_Move_Left at Grid_Positioning_Realiz.rb(19:11)

Goal:
((1 <= GP.X) = (1 <= GP.X))

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 4_6:
Ensures Clause of Is_OK_to_Move_Left (Condition from "RESTORES" parameter mode) at Grid_Positioning_Realiz.rb(19:39)

Goal:
(GP.X = GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 4_7:
Ensures Clause of Is_OK_to_Move_Left (Condition from "RESTORES" parameter mode) at Grid_Positioning_Realiz.rb(19:39)

Goal:
(GP.Y = GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 5_1:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Right at Grid_Positioning_Realiz.rb(23:11)

Goal:
(0 <= GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 5_2:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Right at Grid_Positioning_Realiz.rb(23:11)

Goal:
(GP.X <= Max_Right)

Given(s):
1. (1 <= Max_Right)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Top)

VC 5_3:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Right at Grid_Positioning_Realiz.rb(23:11)

Goal:
(0 <= GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 5_4:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Right at Grid_Positioning_Realiz.rb(23:11)

Goal:
(GP.Y <= Max_Top)

Given(s):
1. (1 <= Max_Top)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Right)

VC 5_5:
Ensures Clause of Is_OK_to_Move_Right at Grid_Positioning_Realiz.rb(23:11)

Goal:
(((1 + GP.X) <= Max_Right) = ((GP.X + 1) <= Max_Right))

Given(s):
1. (1 <= Max_Right)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Top)

VC 5_6:
Ensures Clause of Is_OK_to_Move_Right (Condition from "RESTORES" parameter mode) at Grid_Positioning_Realiz.rb(23:40)

Goal:
(GP.X = GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 5_7:
Ensures Clause of Is_OK_to_Move_Right (Condition from "RESTORES" parameter mode) at Grid_Positioning_Realiz.rb(23:40)

Goal:
(GP.Y = GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 6_1:
Requires Clause of Difference at Grid_Positioning_Realiz.rb(28:10)

Goal:
(min_int <= (GP.Y - 1))

Given(s):
1. (min_int <= 0)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= GP.Y)
7. (1 <= Max_Top)
8. (1 <= Max_Right)

VC 6_2:
Requires Clause of Difference at Grid_Positioning_Realiz.rb(28:10)

Goal:
((GP.Y - 1) <= max_int)

Given(s):
1. (1 <= max_int)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= GP.Y)
7. (1 <= Max_Top)
8. (1 <= Max_Right)

VC 6_3:
Type Convention for Grid_Pos Generated by Move_Down at Grid_Positioning_Realiz.rb(27:11)

Goal:
(0 <= GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= GP.Y)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 6_4:
Type Convention for Grid_Pos Generated by Move_Down at Grid_Positioning_Realiz.rb(27:11)

Goal:
(GP.X <= Max_Right)

Given(s):
1. (1 <= Max_Right)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= GP.Y)
7. (1 <= Max_Top)

VC 6_5:
Type Convention for Grid_Pos Generated by Move_Down at Grid_Positioning_Realiz.rb(27:11)

Goal:
(0 <= (GP.Y - 1))

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= GP.Y)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 6_6:
Type Convention for Grid_Pos Generated by Move_Down at Grid_Positioning_Realiz.rb(27:11)

Goal:
((GP.Y - 1) <= Max_Top)

Given(s):
1. (1 <= Max_Top)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= GP.Y)
7. (1 <= Max_Right)

VC 6_7:
Ensures Clause of Move_Down at Grid_Positioning_Realiz.rb(27:11)

Goal:
((GP.Y - 1) = (GP.Y - 1))

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= GP.Y)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 6_8:
Ensures Clause of Move_Down at Grid_Positioning_Realiz.rb(27:11)

Goal:
(GP.X = GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= GP.Y)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 7_1:
Requires Clause of Sum at Grid_Positioning_Realiz.rb(32:10)

Goal:
(min_int <= (GP.Y + 1))

Given(s):
1. (min_int <= 0)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. ((GP.Y + 1) <= Max_Top)
7. (1 <= Max_Top)
8. (1 <= Max_Right)

VC 7_2:
Requires Clause of Sum at Grid_Positioning_Realiz.rb(32:10)

Goal:
((GP.Y + 1) <= max_int)

Given(s):
1. (1 <= max_int)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. ((GP.Y + 1) <= Max_Top)
7. (1 <= Max_Top)
8. (1 <= Max_Right)

VC 7_3:
Type Convention for Grid_Pos Generated by Move_Up at Grid_Positioning_Realiz.rb(31:11)

Goal:
(0 <= GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. ((GP.Y + 1) <= Max_Top)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 7_4:
Type Convention for Grid_Pos Generated by Move_Up at Grid_Positioning_Realiz.rb(31:11)

Goal:
(GP.X <= Max_Right)

Given(s):
1. (1 <= Max_Right)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. ((GP.Y + 1) <= Max_Top)
7. (1 <= Max_Top)

VC 7_5:
Type Convention for Grid_Pos Generated by Move_Up at Grid_Positioning_Realiz.rb(31:11)

Goal:
(0 <= (GP.Y + 1))

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. ((GP.Y + 1) <= Max_Top)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 7_6:
Type Convention for Grid_Pos Generated by Move_Up at Grid_Positioning_Realiz.rb(31:11)

Goal:
((GP.Y + 1) <= Max_Top)

Given(s):
1. (1 <= Max_Top)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. ((GP.Y + 1) <= Max_Top)
7. (1 <= Max_Right)

VC 7_7:
Ensures Clause of Move_Up at Grid_Positioning_Realiz.rb(31:11)

Goal:
((GP.Y + 1) = (GP.Y + 1))

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. ((GP.Y + 1) <= Max_Top)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 7_8:
Ensures Clause of Move_Up at Grid_Positioning_Realiz.rb(31:11)

Goal:
(GP.X = GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. ((GP.Y + 1) <= Max_Top)
6. (1 <= Max_Top)
7. (1 <= Max_Right)

VC 8_1:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Down at Grid_Positioning_Realiz.rb(35:11)

Goal:
(0 <= GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 8_2:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Down at Grid_Positioning_Realiz.rb(35:11)

Goal:
(GP.X <= Max_Right)

Given(s):
1. (1 <= Max_Right)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Top)

VC 8_3:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Down at Grid_Positioning_Realiz.rb(35:11)

Goal:
(0 <= GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 8_4:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Down at Grid_Positioning_Realiz.rb(35:11)

Goal:
(GP.Y <= Max_Top)

Given(s):
1. (1 <= Max_Top)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Right)

VC 8_5:
Ensures Clause of Is_OK_to_Move_Down at Grid_Positioning_Realiz.rb(35:11)

Goal:
((1 <= GP.Y) = (1 <= GP.Y))

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 8_6:
Ensures Clause of Is_OK_to_Move_Down (Condition from "RESTORES" parameter mode) at Grid_Positioning_Realiz.rb(35:39)

Goal:
(GP.X = GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 8_7:
Ensures Clause of Is_OK_to_Move_Down (Condition from "RESTORES" parameter mode) at Grid_Positioning_Realiz.rb(35:39)

Goal:
(GP.Y = GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 9_1:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Up at Grid_Positioning_Realiz.rb(39:11)

Goal:
(0 <= GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 9_2:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Up at Grid_Positioning_Realiz.rb(39:11)

Goal:
(GP.X <= Max_Right)

Given(s):
1. (1 <= Max_Right)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Top)

VC 9_3:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Up at Grid_Positioning_Realiz.rb(39:11)

Goal:
(0 <= GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 9_4:
Type Convention for Grid_Pos Generated by Is_OK_to_Move_Up at Grid_Positioning_Realiz.rb(39:11)

Goal:
(GP.Y <= Max_Top)

Given(s):
1. (1 <= Max_Top)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Right)

VC 9_5:
Ensures Clause of Is_OK_to_Move_Up at Grid_Positioning_Realiz.rb(39:11)

Goal:
(((1 + GP.Y) <= Max_Top) = ((GP.Y + 1) <= Max_Top))

Given(s):
1. (1 <= Max_Top)
2. (0 <= GP.X)
3. (GP.X <= Max_Right)
4. (0 <= GP.Y)
5. (GP.Y <= Max_Top)
6. (1 <= Max_Right)

VC 9_6:
Ensures Clause of Is_OK_to_Move_Up (Condition from "RESTORES" parameter mode) at Grid_Positioning_Realiz.rb(39:37)

Goal:
(GP.X = GP.X)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 9_7:
Ensures Clause of Is_OK_to_Move_Up (Condition from "RESTORES" parameter mode) at Grid_Positioning_Realiz.rb(39:37)

Goal:
(GP.Y = GP.Y)

Given(s):
1. (0 <= GP.X)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (1 <= Max_Right)

VC 10_1:
Type Convention for Grid_Pos Generated by Clear at Grid_Positioning_Realiz.rb(43:11)

Goal:
(0 <= 0)

Given(s):

VC 10_2:
Type Convention for Grid_Pos Generated by Clear at Grid_Positioning_Realiz.rb(43:11)

Goal:
(0 <= Max_Right)

Given(s):
1. (1 <= Max_Right)
2. (GP.X <= Max_Right)
3. (0 <= GP.Y)
4. (GP.Y <= Max_Top)
5. (1 <= Max_Top)
6. (0 <= GP.X)

VC 10_3:
Type Convention for Grid_Pos Generated by Clear at Grid_Positioning_Realiz.rb(43:11)

Goal:
(0 <= 0)

Given(s):

VC 10_4:
Type Convention for Grid_Pos Generated by Clear at Grid_Positioning_Realiz.rb(43:11)

Goal:
(0 <= Max_Top)

Given(s):
1. (1 <= Max_Top)
2. (GP.Y <= Max_Top)
3. (0 <= GP.X)
4. (GP.X <= Max_Right)
5. (0 <= GP.Y)
6. (1 <= Max_Right)

VC 10_5:
Ensures Clause of Clear (Condition from "CLEARS" parameter mode) at Grid_Positioning_Realiz.rb(43:24)

Goal:
(0 = 0)

Given(s):

VC 10_6:
Ensures Clause of Clear (Condition from "CLEARS" parameter mode) at Grid_Positioning_Realiz.rb(43:24)

Goal:
(0 = 0)

Given(s):

========================= VC Generation Details  =========================

    Concept Realization Name:   Grid_Positioning_Realiz
    Concept Name:               Grid_Positioning_Template

==========================================================================

========================= Grid_Pos =========================

Applied Well Defined Correspondence Rule (Concept Type Realization): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));
    Confirm ((0 <= Conc.GP.X) and (Conc.GP.X <= Max_Right) and (0 <= Conc.GP.Y) and (Conc.GP.Y <= Max_Top));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));

VC(s):
     |- (0 <= Conc.GP.X)

     |- (Conc.GP.X <= Max_Right)

     |- (0 <= Conc.GP.Y)

     |- (Conc.GP.Y <= Max_Top)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((0 <= Conc.GP.X) and (Conc.GP.X <= Max_Right) and (0 <= Conc.GP.Y) and (Conc.GP.Y <= Max_Top))" shape="box" ];
      2 [ label=" |- (0 <= Conc.GP.X) and (Conc.GP.X <= Max_Right)" shape="box" ];
      3 [ label=" |- (0 <= Conc.GP.Y) and (Conc.GP.Y <= Max_Top)" shape="box" ];
      4 [ label=" |- (0 <= Conc.GP.X)" shape="box" color="red" ];
      5 [ label=" |- (Conc.GP.X <= Max_Right)" shape="box" color="red" ];
      6 [ label=" |- (0 <= Conc.GP.Y)" shape="box" color="red" ];
      7 [ label=" |- (Conc.GP.Y <= Max_Top)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
      3 -> 6;
      3 -> 7;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)));

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)) |- " shape="box" ];
      2 [ label="(Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):
    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.X)

    (1 <= Max_Right), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top) |- (GP.X <= Max_Right)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.Y)

    (1 <= Max_Top), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Right) |- (GP.Y <= Max_Top)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Initialization of Grid_Pos =========================

Applied Initialization of Grid_Pos (Setup): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;
    _Initialize(GP : Grid_Pos);

VC(s):

_____________________

Applied Initialization Rule (Concept Type Realization): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;
    _Initialize(GP : Grid_Pos);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume (true and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Confirm ((Conc.GP.X = 0) and (Conc.GP.Y = 0));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;
    _Initialize(GP : Grid_Pos);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume (true and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));

VC(s):
     |- (Conc.GP.X = 0)

     |- (Conc.GP.Y = 0)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Conc.GP.X = 0) and (Conc.GP.Y = 0))" shape="box" ];
      2 [ label=" |- (Conc.GP.X = 0)" shape="box" color="red" ];
      3 [ label=" |- (Conc.GP.Y = 0)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;
    _Initialize(GP : Grid_Pos);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));

VC(s):
     |- (GP.X = 0)

     |- (GP.Y = 0)

Reduction Tree(s):
    strict digraph G {
      1 [ label="(true and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))) |- " shape="box" ];
      2 [ label="true, (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;
    _Initialize(GP : Grid_Pos);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (GP.X = 0)

     |- (GP.Y = 0)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))" shape="box" ];
      2 [ label=" |- (0 <= GP.X) and (GP.X <= Max_Right)" shape="box" ];
      3 [ label=" |- (0 <= GP.Y) and (GP.Y <= Max_Top)" shape="box" ];
      4 [ label=" |- (0 <= GP.X)" shape="box" color="red" ];
      5 [ label=" |- (GP.X <= Max_Right)" shape="box" color="red" ];
      6 [ label=" |- (0 <= GP.Y)" shape="box" color="red" ];
      7 [ label=" |- (GP.Y <= Max_Top)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
      3 -> 6;
      3 -> 7;
    }

_____________________

Applied Variable Declaration/Initialization Rule (Known Program Type): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;
    Assume ((GP.X = 0) and (GP.Y = 0));

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (GP.X = 0)

     |- (GP.Y = 0)

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;

VC(s):
     |- (0 <= 0)

     |- (0 <= Max_Right)

     |- (0 <= 0)

     |- (0 <= Max_Top)

     |- (0 = 0)

     |- (0 = 0)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((GP.X = 0) and (GP.Y = 0)) |- " shape="box" ];
      2 [ label="(GP.X = 0), (GP.Y = 0) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Remember Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));

VC(s):
     |- (0 <= 0)

     |- (0 <= Max_Right)

     |- (0 <= 0)

     |- (0 <= Max_Top)

     |- (0 = 0)

     |- (0 = 0)

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):
     |- (0 <= 0)

    (1 <= Max_Right) |- (0 <= Max_Right)

     |- (0 <= 0)

    (1 <= Max_Top) |- (0 <= Max_Top)

     |- (0 = 0)

     |- (0 = 0)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Finalization of Grid_Pos =========================

Applied Finalization of Grid_Pos (Setup): 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;

VC(s):

_____________________

Applied Finalization Rule (Concept Type Realization): 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;
    _Finalize(GP : Grid_Pos);
    Confirm true;
    Assume (true and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Confirm true;

VC(s):

_____________________

Applied Confirm Rule and Simplified: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;
    _Finalize(GP : Grid_Pos);
    Confirm true;
    Assume (true and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));

VC(s):

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;
    _Finalize(GP : Grid_Pos);
    Confirm true;

VC(s):

Reduction Tree(s):
    strict digraph G {
      1 [ label="(true and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))) |- " shape="box" ];
      2 [ label="true, (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule and Simplified: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;
    _Finalize(GP : Grid_Pos);

VC(s):

_____________________

Applied Variable Finalization Rule (Known Program Type): 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;
    Assume true;

VC(s):

_____________________

Applied Assume Rule and Simplified: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));
    Remember;

VC(s):

_____________________

Applied Remember Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)));

VC(s):

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):

Reduction Tree(s):
    strict digraph G {
      1 [ label="(((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Move_Left =========================

Applied Procedure Declaration Rule (Part 1): 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.X));
    Remember;

VC(s):

_____________________

Applied Procedure Declaration Rule (Part 2): 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.X));
    Remember;
    GP.X := Difference(GP.X, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));
    Confirm ((Conc.GP.X = (#Conc.GP.X - 1)) and (Conc.GP.Y = #Conc.GP.Y));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.X));
    Remember;
    GP.X := Difference(GP.X, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));

VC(s):
     |- (Conc.GP.X = (#Conc.GP.X - 1))

     |- (Conc.GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Conc.GP.X = (#Conc.GP.X - 1)) and (Conc.GP.Y = #Conc.GP.Y))" shape="box" ];
      2 [ label=" |- (Conc.GP.X = (#Conc.GP.X - 1))" shape="box" color="red" ];
      3 [ label=" |- (Conc.GP.Y = #Conc.GP.Y)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.X));
    Remember;
    GP.X := Difference(GP.X, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));

VC(s):
     |- (GP.X = (#Conc.GP.X - 1))

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)) |- " shape="box" ];
      2 [ label="(Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.X));
    Remember;
    GP.X := Difference(GP.X, 1);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (GP.X = (#Conc.GP.X - 1))

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))" shape="box" ];
      2 [ label=" |- (0 <= GP.X) and (GP.X <= Max_Right)" shape="box" ];
      3 [ label=" |- (0 <= GP.Y) and (GP.Y <= Max_Top)" shape="box" ];
      4 [ label=" |- (0 <= GP.X)" shape="box" color="red" ];
      5 [ label=" |- (GP.X <= Max_Right)" shape="box" color="red" ];
      6 [ label=" |- (0 <= GP.Y)" shape="box" color="red" ];
      7 [ label=" |- (GP.Y <= Max_Top)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
      3 -> 6;
      3 -> 7;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.X));
    Remember;
    Confirm (min_int <= (GP.X - 1)) and ((GP.X - 1) <= max_int);

VC(s):
     |- (0 <= (GP.X - 1))

     |- ((GP.X - 1) <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- ((GP.X - 1) = (#Conc.GP.X - 1))

     |- (GP.Y = #Conc.GP.Y)

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.X));
    Remember;

VC(s):
     |- (min_int <= (GP.X - 1))

     |- ((GP.X - 1) <= max_int)

     |- (0 <= (GP.X - 1))

     |- ((GP.X - 1) <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- ((GP.X - 1) = (#Conc.GP.X - 1))

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- (min_int <= (GP.X - 1)) and ((GP.X - 1) <= max_int)" shape="box" ];
      2 [ label=" |- (min_int <= (GP.X - 1))" shape="box" color="red" ];
      3 [ label=" |- ((GP.X - 1) <= max_int)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Remember Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.X));

VC(s):
     |- (min_int <= (GP.X - 1))

     |- ((GP.X - 1) <= max_int)

     |- (0 <= (GP.X - 1))

     |- ((GP.X - 1) <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- ((GP.X - 1) = (Conc.GP.X - 1))

     |- (GP.Y = Conc.GP.Y)

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):
    (min_int <= 0), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.X), (1 <= Max_Top), (1 <= Max_Right) |- (min_int <= (GP.X - 1))

    (1 <= max_int), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.X), (1 <= Max_Top), (1 <= Max_Right) |- ((GP.X - 1) <= max_int)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.X), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= (GP.X - 1))

    (1 <= Max_Right), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.X), (1 <= Max_Top) |- ((GP.X - 1) <= Max_Right)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.X), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.Y)

    (1 <= Max_Top), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.X), (1 <= Max_Right) |- (GP.Y <= Max_Top)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.X), (1 <= Max_Top), (1 <= Max_Right) |- ((GP.X - 1) = (GP.X - 1))

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.X), (1 <= Max_Top), (1 <= Max_Right) |- (GP.Y = GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="(((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.X)) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y), (1 <= Conc.GP.X) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Move_Right =========================

Applied Procedure Declaration Rule (Part 1): 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.X + 1) <= Max_Right));
    Remember;

VC(s):

_____________________

Applied Procedure Declaration Rule (Part 2): 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.X + 1) <= Max_Right));
    Remember;
    GP.X := Sum(GP.X, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));
    Confirm ((Conc.GP.X = (#Conc.GP.X + 1)) and (Conc.GP.Y = #Conc.GP.Y));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.X + 1) <= Max_Right));
    Remember;
    GP.X := Sum(GP.X, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));

VC(s):
     |- (Conc.GP.X = (#Conc.GP.X + 1))

     |- (Conc.GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Conc.GP.X = (#Conc.GP.X + 1)) and (Conc.GP.Y = #Conc.GP.Y))" shape="box" ];
      2 [ label=" |- (Conc.GP.X = (#Conc.GP.X + 1))" shape="box" color="red" ];
      3 [ label=" |- (Conc.GP.Y = #Conc.GP.Y)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.X + 1) <= Max_Right));
    Remember;
    GP.X := Sum(GP.X, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));

VC(s):
     |- (GP.X = (#Conc.GP.X + 1))

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)) |- " shape="box" ];
      2 [ label="(Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.X + 1) <= Max_Right));
    Remember;
    GP.X := Sum(GP.X, 1);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (GP.X = (#Conc.GP.X + 1))

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))" shape="box" ];
      2 [ label=" |- (0 <= GP.X) and (GP.X <= Max_Right)" shape="box" ];
      3 [ label=" |- (0 <= GP.Y) and (GP.Y <= Max_Top)" shape="box" ];
      4 [ label=" |- (0 <= GP.X)" shape="box" color="red" ];
      5 [ label=" |- (GP.X <= Max_Right)" shape="box" color="red" ];
      6 [ label=" |- (0 <= GP.Y)" shape="box" color="red" ];
      7 [ label=" |- (GP.Y <= Max_Top)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
      3 -> 6;
      3 -> 7;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.X + 1) <= Max_Right));
    Remember;
    Confirm (min_int <= (GP.X + 1)) and ((GP.X + 1) <= max_int);

VC(s):
     |- (0 <= (GP.X + 1))

     |- ((GP.X + 1) <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- ((GP.X + 1) = (#Conc.GP.X + 1))

     |- (GP.Y = #Conc.GP.Y)

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.X + 1) <= Max_Right));
    Remember;

VC(s):
     |- (min_int <= (GP.X + 1))

     |- ((GP.X + 1) <= max_int)

     |- (0 <= (GP.X + 1))

     |- ((GP.X + 1) <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- ((GP.X + 1) = (#Conc.GP.X + 1))

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- (min_int <= (GP.X + 1)) and ((GP.X + 1) <= max_int)" shape="box" ];
      2 [ label=" |- (min_int <= (GP.X + 1))" shape="box" color="red" ];
      3 [ label=" |- ((GP.X + 1) <= max_int)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Remember Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.X + 1) <= Max_Right));

VC(s):
     |- (min_int <= (GP.X + 1))

     |- ((GP.X + 1) <= max_int)

     |- (0 <= (GP.X + 1))

     |- ((GP.X + 1) <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- ((GP.X + 1) = (Conc.GP.X + 1))

     |- (GP.Y = Conc.GP.Y)

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):
    (min_int <= 0), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.X + 1) <= Max_Right), (1 <= Max_Top), (1 <= Max_Right) |- (min_int <= (GP.X + 1))

    (1 <= max_int), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.X + 1) <= Max_Right), (1 <= Max_Top), (1 <= Max_Right) |- ((GP.X + 1) <= max_int)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.X + 1) <= Max_Right), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= (GP.X + 1))

    (1 <= Max_Right), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.X + 1) <= Max_Right), (1 <= Max_Top) |- ((GP.X + 1) <= Max_Right)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.X + 1) <= Max_Right), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.Y)

    (1 <= Max_Top), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.X + 1) <= Max_Right), (1 <= Max_Right) |- (GP.Y <= Max_Top)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.X + 1) <= Max_Right), (1 <= Max_Top), (1 <= Max_Right) |- ((GP.X + 1) = (GP.X + 1))

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.X + 1) <= Max_Right), (1 <= Max_Top), (1 <= Max_Right) |- (GP.Y = GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="(((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.X + 1) <= Max_Right)) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y), ((Conc.GP.X + 1) <= Max_Right) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Is_OK_to_Move_Left =========================

Applied Procedure Declaration Rule (Part 1): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;

VC(s):

_____________________

Applied Procedure Declaration Rule (Part 2): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Left := Less_Or_Equal(1, GP.X);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));
    Confirm ((Is_OK_to_Move_Left = (1 <= Conc.GP.X)) and ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y)));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Left := Less_Or_Equal(1, GP.X);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));

VC(s):
     |- (Is_OK_to_Move_Left = (1 <= Conc.GP.X))

     |- (Conc.GP.X = #Conc.GP.X)

     |- (Conc.GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Is_OK_to_Move_Left = (1 <= Conc.GP.X)) and ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y)))" shape="box" ];
      2 [ label=" |- (Is_OK_to_Move_Left = (1 <= Conc.GP.X))" shape="box" color="red" ];
      3 [ label=" |- ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y))" shape="box" ];
      4 [ label=" |- (Conc.GP.X = #Conc.GP.X)" shape="box" color="red" ];
      5 [ label=" |- (Conc.GP.Y = #Conc.GP.Y)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      3 -> 4;
      3 -> 5;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Left := Less_Or_Equal(1, GP.X);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));

VC(s):
     |- (Is_OK_to_Move_Left = (1 <= GP.X))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)) |- " shape="box" ];
      2 [ label="(Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Left := Less_Or_Equal(1, GP.X);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (Is_OK_to_Move_Left = (1 <= GP.X))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))" shape="box" ];
      2 [ label=" |- (0 <= GP.X) and (GP.X <= Max_Right)" shape="box" ];
      3 [ label=" |- (0 <= GP.Y) and (GP.Y <= Max_Top)" shape="box" ];
      4 [ label=" |- (0 <= GP.X)" shape="box" color="red" ];
      5 [ label=" |- (GP.X <= Max_Right)" shape="box" color="red" ];
      6 [ label=" |- (0 <= GP.Y)" shape="box" color="red" ];
      7 [ label=" |- (GP.Y <= Max_Top)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
      3 -> 6;
      3 -> 7;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- ((1 <= GP.X) = (1 <= GP.X))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

_____________________

Applied Remember Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- ((1 <= GP.X) = (1 <= GP.X))

     |- (GP.X = Conc.GP.X)

     |- (GP.Y = Conc.GP.Y)

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):
    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.X)

    (1 <= Max_Right), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top) |- (GP.X <= Max_Right)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.Y)

    (1 <= Max_Top), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Right) |- (GP.Y <= Max_Top)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- ((1 <= GP.X) = (1 <= GP.X))

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (GP.X = GP.X)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (GP.Y = GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Is_OK_to_Move_Right =========================

Applied Procedure Declaration Rule (Part 1): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;

VC(s):

_____________________

Applied Procedure Declaration Rule (Part 2): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Right := Less(GP.X, Max_Right);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));
    Confirm ((Is_OK_to_Move_Right = ((Conc.GP.X + 1) <= Max_Right)) and ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y)));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Right := Less(GP.X, Max_Right);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));

VC(s):
     |- (Is_OK_to_Move_Right = ((Conc.GP.X + 1) <= Max_Right))

     |- (Conc.GP.X = #Conc.GP.X)

     |- (Conc.GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Is_OK_to_Move_Right = ((Conc.GP.X + 1) <= Max_Right)) and ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y)))" shape="box" ];
      2 [ label=" |- (Is_OK_to_Move_Right = ((Conc.GP.X + 1) <= Max_Right))" shape="box" color="red" ];
      3 [ label=" |- ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y))" shape="box" ];
      4 [ label=" |- (Conc.GP.X = #Conc.GP.X)" shape="box" color="red" ];
      5 [ label=" |- (Conc.GP.Y = #Conc.GP.Y)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      3 -> 4;
      3 -> 5;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Right := Less(GP.X, Max_Right);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));

VC(s):
     |- (Is_OK_to_Move_Right = ((GP.X + 1) <= Max_Right))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)) |- " shape="box" ];
      2 [ label="(Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Right := Less(GP.X, Max_Right);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (Is_OK_to_Move_Right = ((GP.X + 1) <= Max_Right))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))" shape="box" ];
      2 [ label=" |- (0 <= GP.X) and (GP.X <= Max_Right)" shape="box" ];
      3 [ label=" |- (0 <= GP.Y) and (GP.Y <= Max_Top)" shape="box" ];
      4 [ label=" |- (0 <= GP.X)" shape="box" color="red" ];
      5 [ label=" |- (GP.X <= Max_Right)" shape="box" color="red" ];
      6 [ label=" |- (0 <= GP.Y)" shape="box" color="red" ];
      7 [ label=" |- (GP.Y <= Max_Top)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
      3 -> 6;
      3 -> 7;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (((1 + GP.X) <= Max_Right) = ((GP.X + 1) <= Max_Right))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

_____________________

Applied Remember Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (((1 + GP.X) <= Max_Right) = ((GP.X + 1) <= Max_Right))

     |- (GP.X = Conc.GP.X)

     |- (GP.Y = Conc.GP.Y)

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):
    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.X)

    (1 <= Max_Right), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top) |- (GP.X <= Max_Right)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.Y)

    (1 <= Max_Top), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Right) |- (GP.Y <= Max_Top)

    (1 <= Max_Right), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top) |- (((1 + GP.X) <= Max_Right) = ((GP.X + 1) <= Max_Right))

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (GP.X = GP.X)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (GP.Y = GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Move_Down =========================

Applied Procedure Declaration Rule (Part 1): 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.Y));
    Remember;

VC(s):

_____________________

Applied Procedure Declaration Rule (Part 2): 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.Y));
    Remember;
    GP.Y := Difference(GP.Y, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));
    Confirm ((Conc.GP.Y = (#Conc.GP.Y - 1)) and (Conc.GP.X = #Conc.GP.X));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.Y));
    Remember;
    GP.Y := Difference(GP.Y, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));

VC(s):
     |- (Conc.GP.Y = (#Conc.GP.Y - 1))

     |- (Conc.GP.X = #Conc.GP.X)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Conc.GP.Y = (#Conc.GP.Y - 1)) and (Conc.GP.X = #Conc.GP.X))" shape="box" ];
      2 [ label=" |- (Conc.GP.Y = (#Conc.GP.Y - 1))" shape="box" color="red" ];
      3 [ label=" |- (Conc.GP.X = #Conc.GP.X)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.Y));
    Remember;
    GP.Y := Difference(GP.Y, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));

VC(s):
     |- (GP.Y = (#Conc.GP.Y - 1))

     |- (GP.X = #Conc.GP.X)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)) |- " shape="box" ];
      2 [ label="(Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.Y));
    Remember;
    GP.Y := Difference(GP.Y, 1);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (GP.Y = (#Conc.GP.Y - 1))

     |- (GP.X = #Conc.GP.X)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))" shape="box" ];
      2 [ label=" |- (0 <= GP.X) and (GP.X <= Max_Right)" shape="box" ];
      3 [ label=" |- (0 <= GP.Y) and (GP.Y <= Max_Top)" shape="box" ];
      4 [ label=" |- (0 <= GP.X)" shape="box" color="red" ];
      5 [ label=" |- (GP.X <= Max_Right)" shape="box" color="red" ];
      6 [ label=" |- (0 <= GP.Y)" shape="box" color="red" ];
      7 [ label=" |- (GP.Y <= Max_Top)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
      3 -> 6;
      3 -> 7;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.Y));
    Remember;
    Confirm (min_int <= (GP.Y - 1)) and ((GP.Y - 1) <= max_int);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= (GP.Y - 1))

     |- ((GP.Y - 1) <= Max_Top)

     |- ((GP.Y - 1) = (#Conc.GP.Y - 1))

     |- (GP.X = #Conc.GP.X)

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.Y));
    Remember;

VC(s):
     |- (min_int <= (GP.Y - 1))

     |- ((GP.Y - 1) <= max_int)

     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= (GP.Y - 1))

     |- ((GP.Y - 1) <= Max_Top)

     |- ((GP.Y - 1) = (#Conc.GP.Y - 1))

     |- (GP.X = #Conc.GP.X)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- (min_int <= (GP.Y - 1)) and ((GP.Y - 1) <= max_int)" shape="box" ];
      2 [ label=" |- (min_int <= (GP.Y - 1))" shape="box" color="red" ];
      3 [ label=" |- ((GP.Y - 1) <= max_int)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Remember Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.Y));

VC(s):
     |- (min_int <= (GP.Y - 1))

     |- ((GP.Y - 1) <= max_int)

     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= (GP.Y - 1))

     |- ((GP.Y - 1) <= Max_Top)

     |- ((GP.Y - 1) = (Conc.GP.Y - 1))

     |- (GP.X = Conc.GP.X)

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):
    (min_int <= 0), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.Y), (1 <= Max_Top), (1 <= Max_Right) |- (min_int <= (GP.Y - 1))

    (1 <= max_int), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.Y), (1 <= Max_Top), (1 <= Max_Right) |- ((GP.Y - 1) <= max_int)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.Y), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.X)

    (1 <= Max_Right), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.Y), (1 <= Max_Top) |- (GP.X <= Max_Right)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.Y), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= (GP.Y - 1))

    (1 <= Max_Top), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.Y), (1 <= Max_Right) |- ((GP.Y - 1) <= Max_Top)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.Y), (1 <= Max_Top), (1 <= Max_Right) |- ((GP.Y - 1) = (GP.Y - 1))

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= GP.Y), (1 <= Max_Top), (1 <= Max_Right) |- (GP.X = GP.X)

Reduction Tree(s):
    strict digraph G {
      1 [ label="(((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and (1 <= Conc.GP.Y)) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y), (1 <= Conc.GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Move_Up =========================

Applied Procedure Declaration Rule (Part 1): 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.Y + 1) <= Max_Top));
    Remember;

VC(s):

_____________________

Applied Procedure Declaration Rule (Part 2): 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.Y + 1) <= Max_Top));
    Remember;
    GP.Y := Sum(GP.Y, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));
    Confirm ((Conc.GP.Y = (#Conc.GP.Y + 1)) and (Conc.GP.X = #Conc.GP.X));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.Y + 1) <= Max_Top));
    Remember;
    GP.Y := Sum(GP.Y, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));

VC(s):
     |- (Conc.GP.Y = (#Conc.GP.Y + 1))

     |- (Conc.GP.X = #Conc.GP.X)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Conc.GP.Y = (#Conc.GP.Y + 1)) and (Conc.GP.X = #Conc.GP.X))" shape="box" ];
      2 [ label=" |- (Conc.GP.Y = (#Conc.GP.Y + 1))" shape="box" color="red" ];
      3 [ label=" |- (Conc.GP.X = #Conc.GP.X)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.Y + 1) <= Max_Top));
    Remember;
    GP.Y := Sum(GP.Y, 1);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));

VC(s):
     |- (GP.Y = (#Conc.GP.Y + 1))

     |- (GP.X = #Conc.GP.X)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)) |- " shape="box" ];
      2 [ label="(Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.Y + 1) <= Max_Top));
    Remember;
    GP.Y := Sum(GP.Y, 1);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (GP.Y = (#Conc.GP.Y + 1))

     |- (GP.X = #Conc.GP.X)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))" shape="box" ];
      2 [ label=" |- (0 <= GP.X) and (GP.X <= Max_Right)" shape="box" ];
      3 [ label=" |- (0 <= GP.Y) and (GP.Y <= Max_Top)" shape="box" ];
      4 [ label=" |- (0 <= GP.X)" shape="box" color="red" ];
      5 [ label=" |- (GP.X <= Max_Right)" shape="box" color="red" ];
      6 [ label=" |- (0 <= GP.Y)" shape="box" color="red" ];
      7 [ label=" |- (GP.Y <= Max_Top)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
      3 -> 6;
      3 -> 7;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.Y + 1) <= Max_Top));
    Remember;
    Confirm (min_int <= (GP.Y + 1)) and ((GP.Y + 1) <= max_int);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= (GP.Y + 1))

     |- ((GP.Y + 1) <= Max_Top)

     |- ((GP.Y + 1) = (#Conc.GP.Y + 1))

     |- (GP.X = #Conc.GP.X)

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.Y + 1) <= Max_Top));
    Remember;

VC(s):
     |- (min_int <= (GP.Y + 1))

     |- ((GP.Y + 1) <= max_int)

     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= (GP.Y + 1))

     |- ((GP.Y + 1) <= Max_Top)

     |- ((GP.Y + 1) = (#Conc.GP.Y + 1))

     |- (GP.X = #Conc.GP.X)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- (min_int <= (GP.Y + 1)) and ((GP.Y + 1) <= max_int)" shape="box" ];
      2 [ label=" |- (min_int <= (GP.Y + 1))" shape="box" color="red" ];
      3 [ label=" |- ((GP.Y + 1) <= max_int)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Remember Rule: 

Free Variables:

Statements:
    Assume (((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.Y + 1) <= Max_Top));

VC(s):
     |- (min_int <= (GP.Y + 1))

     |- ((GP.Y + 1) <= max_int)

     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= (GP.Y + 1))

     |- ((GP.Y + 1) <= Max_Top)

     |- ((GP.Y + 1) = (Conc.GP.Y + 1))

     |- (GP.X = Conc.GP.X)

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):
    (min_int <= 0), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.Y + 1) <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (min_int <= (GP.Y + 1))

    (1 <= max_int), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.Y + 1) <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- ((GP.Y + 1) <= max_int)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.Y + 1) <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.X)

    (1 <= Max_Right), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.Y + 1) <= Max_Top), (1 <= Max_Top) |- (GP.X <= Max_Right)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.Y + 1) <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= (GP.Y + 1))

    (1 <= Max_Top), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.Y + 1) <= Max_Top), (1 <= Max_Right) |- ((GP.Y + 1) <= Max_Top)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.Y + 1) <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- ((GP.Y + 1) = (GP.Y + 1))

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), ((GP.Y + 1) <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (GP.X = GP.X)

Reduction Tree(s):
    strict digraph G {
      1 [ label="(((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) and ((Conc.GP.Y + 1) <= Max_Top)) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y), ((Conc.GP.Y + 1) <= Max_Top) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Is_OK_to_Move_Down =========================

Applied Procedure Declaration Rule (Part 1): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;

VC(s):

_____________________

Applied Procedure Declaration Rule (Part 2): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Down := Less_Or_Equal(1, GP.Y);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));
    Confirm ((Is_OK_to_Move_Down = (1 <= Conc.GP.Y)) and ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y)));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Down := Less_Or_Equal(1, GP.Y);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));

VC(s):
     |- (Is_OK_to_Move_Down = (1 <= Conc.GP.Y))

     |- (Conc.GP.X = #Conc.GP.X)

     |- (Conc.GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Is_OK_to_Move_Down = (1 <= Conc.GP.Y)) and ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y)))" shape="box" ];
      2 [ label=" |- (Is_OK_to_Move_Down = (1 <= Conc.GP.Y))" shape="box" color="red" ];
      3 [ label=" |- ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y))" shape="box" ];
      4 [ label=" |- (Conc.GP.X = #Conc.GP.X)" shape="box" color="red" ];
      5 [ label=" |- (Conc.GP.Y = #Conc.GP.Y)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      3 -> 4;
      3 -> 5;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Down := Less_Or_Equal(1, GP.Y);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));

VC(s):
     |- (Is_OK_to_Move_Down = (1 <= GP.Y))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)) |- " shape="box" ];
      2 [ label="(Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Down := Less_Or_Equal(1, GP.Y);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (Is_OK_to_Move_Down = (1 <= GP.Y))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))" shape="box" ];
      2 [ label=" |- (0 <= GP.X) and (GP.X <= Max_Right)" shape="box" ];
      3 [ label=" |- (0 <= GP.Y) and (GP.Y <= Max_Top)" shape="box" ];
      4 [ label=" |- (0 <= GP.X)" shape="box" color="red" ];
      5 [ label=" |- (GP.X <= Max_Right)" shape="box" color="red" ];
      6 [ label=" |- (0 <= GP.Y)" shape="box" color="red" ];
      7 [ label=" |- (GP.Y <= Max_Top)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
      3 -> 6;
      3 -> 7;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- ((1 <= GP.Y) = (1 <= GP.Y))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

_____________________

Applied Remember Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- ((1 <= GP.Y) = (1 <= GP.Y))

     |- (GP.X = Conc.GP.X)

     |- (GP.Y = Conc.GP.Y)

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):
    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.X)

    (1 <= Max_Right), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top) |- (GP.X <= Max_Right)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.Y)

    (1 <= Max_Top), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Right) |- (GP.Y <= Max_Top)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- ((1 <= GP.Y) = (1 <= GP.Y))

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (GP.X = GP.X)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (GP.Y = GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Is_OK_to_Move_Up =========================

Applied Procedure Declaration Rule (Part 1): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;

VC(s):

_____________________

Applied Procedure Declaration Rule (Part 2): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Up := Less(GP.Y, Max_Top);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));
    Confirm ((Is_OK_to_Move_Up = ((Conc.GP.Y + 1) <= Max_Top)) and ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y)));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Up := Less(GP.Y, Max_Top);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));

VC(s):
     |- (Is_OK_to_Move_Up = ((Conc.GP.Y + 1) <= Max_Top))

     |- (Conc.GP.X = #Conc.GP.X)

     |- (Conc.GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Is_OK_to_Move_Up = ((Conc.GP.Y + 1) <= Max_Top)) and ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y)))" shape="box" ];
      2 [ label=" |- (Is_OK_to_Move_Up = ((Conc.GP.Y + 1) <= Max_Top))" shape="box" color="red" ];
      3 [ label=" |- ((Conc.GP.X = #Conc.GP.X) and (Conc.GP.Y = #Conc.GP.Y))" shape="box" ];
      4 [ label=" |- (Conc.GP.X = #Conc.GP.X)" shape="box" color="red" ];
      5 [ label=" |- (Conc.GP.Y = #Conc.GP.Y)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      3 -> 4;
      3 -> 5;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Up := Less(GP.Y, Max_Top);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));

VC(s):
     |- (Is_OK_to_Move_Up = ((GP.Y + 1) <= Max_Top))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)) |- " shape="box" ];
      2 [ label="(Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    Is_OK_to_Move_Up := Less(GP.Y, Max_Top);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (Is_OK_to_Move_Up = ((GP.Y + 1) <= Max_Top))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))" shape="box" ];
      2 [ label=" |- (0 <= GP.X) and (GP.X <= Max_Right)" shape="box" ];
      3 [ label=" |- (0 <= GP.Y) and (GP.Y <= Max_Top)" shape="box" ];
      4 [ label=" |- (0 <= GP.X)" shape="box" color="red" ];
      5 [ label=" |- (GP.X <= Max_Right)" shape="box" color="red" ];
      6 [ label=" |- (0 <= GP.Y)" shape="box" color="red" ];
      7 [ label=" |- (GP.Y <= Max_Top)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
      3 -> 6;
      3 -> 7;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (((1 + GP.Y) <= Max_Top) = ((GP.Y + 1) <= Max_Top))

     |- (GP.X = #Conc.GP.X)

     |- (GP.Y = #Conc.GP.Y)

_____________________

Applied Remember Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (((1 + GP.Y) <= Max_Top) = ((GP.Y + 1) <= Max_Top))

     |- (GP.X = Conc.GP.X)

     |- (GP.Y = Conc.GP.Y)

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):
    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.X)

    (1 <= Max_Right), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top) |- (GP.X <= Max_Right)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (0 <= GP.Y)

    (1 <= Max_Top), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Right) |- (GP.Y <= Max_Top)

    (1 <= Max_Top), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Right) |- (((1 + GP.Y) <= Max_Top) = ((GP.Y + 1) <= Max_Top))

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (GP.X = GP.X)

    (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (1 <= Max_Right) |- (GP.Y = GP.Y)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Clear =========================

Applied Procedure Declaration Rule (Part 1): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;

VC(s):

_____________________

Applied Procedure Declaration Rule (Part 2): 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    GP.X := Replica(0);
    GP.Y := Replica(0);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));
    Confirm ((Conc.GP.X = 0) and (Conc.GP.Y = 0));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    GP.X := Replica(0);
    GP.Y := Replica(0);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));
    Assume ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y));

VC(s):
     |- (Conc.GP.X = 0)

     |- (Conc.GP.Y = 0)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Conc.GP.X = 0) and (Conc.GP.Y = 0))" shape="box" ];
      2 [ label=" |- (Conc.GP.X = 0)" shape="box" color="red" ];
      3 [ label=" |- (Conc.GP.Y = 0)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Assume Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    GP.X := Replica(0);
    GP.Y := Replica(0);
    Confirm ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top));

VC(s):
     |- (GP.X = 0)

     |- (GP.Y = 0)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)) |- " shape="box" ];
      2 [ label="(Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    GP.X := Replica(0);
    GP.Y := Replica(0);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= GP.Y)

     |- (GP.Y <= Max_Top)

     |- (GP.X = 0)

     |- (GP.Y = 0)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top))" shape="box" ];
      2 [ label=" |- (0 <= GP.X) and (GP.X <= Max_Right)" shape="box" ];
      3 [ label=" |- (0 <= GP.Y) and (GP.Y <= Max_Top)" shape="box" ];
      4 [ label=" |- (0 <= GP.X)" shape="box" color="red" ];
      5 [ label=" |- (GP.X <= Max_Right)" shape="box" color="red" ];
      6 [ label=" |- (0 <= GP.Y)" shape="box" color="red" ];
      7 [ label=" |- (GP.Y <= Max_Top)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
      3 -> 6;
      3 -> 7;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;
    GP.X := Replica(0);

VC(s):
     |- (0 <= GP.X)

     |- (GP.X <= Max_Right)

     |- (0 <= 0)

     |- (0 <= Max_Top)

     |- (GP.X = 0)

     |- (0 = 0)

_____________________

Applied Function Assignment Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));
    Remember;

VC(s):
     |- (0 <= 0)

     |- (0 <= Max_Right)

     |- (0 <= 0)

     |- (0 <= Max_Top)

     |- (0 = 0)

     |- (0 = 0)

_____________________

Applied Remember Rule: 

Free Variables:

Statements:
    Assume ((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y))));

VC(s):
     |- (0 <= 0)

     |- (0 <= Max_Right)

     |- (0 <= 0)

     |- (0 <= Max_Top)

     |- (0 = 0)

     |- (0 = 0)

_____________________

Applied Assume Rule: 

Free Variables:

Statements:

VC(s):
     |- (0 <= 0)

    (1 <= Max_Right), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (1 <= Max_Top), (0 <= GP.X) |- (0 <= Max_Right)

     |- (0 <= 0)

    (1 <= Max_Top), (GP.Y <= Max_Top), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (1 <= Max_Right) |- (0 <= Max_Top)

     |- (0 = 0)

     |- (0 = 0)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((((((1 <= Max_Top) and (1 <= Max_Right)) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (((0 <= GP.X) and (GP.X <= Max_Right) and (0 <= GP.Y) and (GP.Y <= Max_Top)) and ((Conc.GP.X = GP.X) and (Conc.GP.Y = GP.Y)))) |- " shape="box" ];
      2 [ label="(1 <= Max_Top), (1 <= Max_Right), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (0 <= GP.X), (GP.X <= Max_Right), (0 <= GP.Y), (GP.Y <= Max_Top), (Conc.GP.X = GP.X), (Conc.GP.Y = GP.Y) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

