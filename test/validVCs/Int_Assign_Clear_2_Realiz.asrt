VCs for Int_Assign_Clear_2_Realiz.rb generated Mon Oct 07 15:37:30 EDT 2024

================================= VC(s): =================================

VC 0_1:
Requires Clause of Sum at Int_Assign_Clear_2_Realiz.rb(7:7)

Goal:
(min_int <= (|S| + 1))

Given(s):
1. (min_int <= 0)
2. (|S| = 2)

VC 0_2:
Requires Clause of Sum at Int_Assign_Clear_2_Realiz.rb(7:7)

Goal:
((|S| + 1) <= max_int)

Given(s):
1. (1 <= max_int)
2. (|S| = 2)

VC 0_3:
Base Case of the Invariant of While Statement at Int_Assign_Clear_2_Realiz.rb(10:16)

Goal:
(|S| = ((|S| + 1) - 1))

Given(s):
1. (|S| = 2)

VC 0_4:
Requires Clause for Pop at Int_Assign_Clear_2_Realiz.rb(13:3)

Goal:
(1 <= |S''|)

Given(s):
1. (I'' /= (|S| + 1))
2. (|S''| = ((|S| + 1) - I''))
3. (|S| = 2)

VC 0_5:
Requires Clause for Increment at Int_Assign_Clear_2_Realiz.rb(14:3)

Goal:
((1 + I'') <= max_int)

Given(s):
1. (I'' /= (|S| + 1))
2. (|S''| = ((|S| + 1) - I''))
3. (1 <= max_int)
4. (|S| = 2)

VC 0_6:
Inductive Case of Invariant of While Statement at Int_Assign_Clear_2_Realiz.rb(10:16)

Goal:
(|S'| = ((|S| + 1) - (1 + I'')))

Given(s):
1. (S'' = (<Next_Entry'> o S'))
2. (I'' /= (|S| + 1))
3. (|S''| = ((|S| + 1) - I''))
4. (|S| = 2)

VC 0_7:
Termination of While Statement at Int_Assign_Clear_2_Realiz.rb(11:3)

Goal:
((1 + ((|S| + 1) - (1 + I''))) <= ((|S| + 1) - I''))

Given(s):
1. (I'' /= (|S| + 1))
2. (|S''| = ((|S| + 1) - I''))
3. (|S| = 2)

VC 1_1:
Requires Clause of Sum at Int_Assign_Clear_2_Realiz.rb(7:7)

Goal:
(min_int <= (|S| + 1))

Given(s):
1. (min_int <= 0)
2. (|S| = 2)

VC 1_2:
Requires Clause of Sum at Int_Assign_Clear_2_Realiz.rb(7:7)

Goal:
((|S| + 1) <= max_int)

Given(s):
1. (1 <= max_int)
2. (|S| = 2)

VC 1_3:
Base Case of the Invariant of While Statement at Int_Assign_Clear_2_Realiz.rb(10:16)

Goal:
(|S| = ((|S| + 1) - 1))

Given(s):
1. (|S| = 2)

VC 1_4:
Ensures Clause of Clear_2 at Int_Assign_Clear_2_Realiz.rb(2:11)

Goal:
(S' = Empty_String)

Given(s):
1. (I' = (|S| + 1))
2. (|S'| = ((|S| + 1) - I'))
3. (|S| = 2)

========================= VC Generation Details  =========================

    Enhancement Realization Name:   Int_Assign_Clear_2_Realiz
    Enhancement Name:               Clear_2_Capability
    Concept Name:                   Stack_Template

==========================================================================

========================= Clear_2 =========================

---------------------
Branching Conditions
---------------------
1. Expression at Int_Assign_Clear_2_Realiz.rb(8:9) is true. [Exp: (I /= D)]
---------------------

Applied Procedure Declaration Rule (Part 1): 

Free Variables:

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;

VC(s):

_____________________

Applied Procedure Declaration Rule (Part 2): 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);

    While ( Are_Not_Equal(I, D) )
        changing I, Next_Entry, S;
        maintaining (|S| = (D - I));
        decreasing (D - I);
    do
        Pop(Next_Entry, S);
        Increment(I);
    end;

    _Finalize(D : Integer);
    _Finalize(I : Integer);
    Confirm (S = Empty_String);

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);

    While ( Are_Not_Equal(I, D) )
        changing I, Next_Entry, S;
        maintaining (|S| = (D - I));
        decreasing (D - I);
    do
        Pop(Next_Entry, S);
        Increment(I);
    end;

    _Finalize(D : Integer);
    _Finalize(I : Integer);

VC(s):
     |- (S = Empty_String)

_____________________

Applied Variable Finalization Rule (Known Program Type): 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);

    While ( Are_Not_Equal(I, D) )
        changing I, Next_Entry, S;
        maintaining (|S| = (D - I));
        decreasing (D - I);
    do
        Pop(Next_Entry, S);
        Increment(I);
    end;

    _Finalize(D : Integer);
    Assume true;

VC(s):
     |- (S = Empty_String)

_____________________

Applied Assume Rule and Simplified: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);

    While ( Are_Not_Equal(I, D) )
        changing I, Next_Entry, S;
        maintaining (|S| = (D - I));
        decreasing (D - I);
    do
        Pop(Next_Entry, S);
        Increment(I);
    end;

    _Finalize(D : Integer);

VC(s):
     |- (S = Empty_String)

_____________________

Applied Variable Finalization Rule (Known Program Type): 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);

    While ( Are_Not_Equal(I, D) )
        changing I, Next_Entry, S;
        maintaining (|S| = (D - I));
        decreasing (D - I);
    do
        Pop(Next_Entry, S);
        Increment(I);
    end;

    Assume true;

VC(s):
     |- (S = Empty_String)

_____________________

Applied Assume Rule and Simplified: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);

    While ( Are_Not_Equal(I, D) )
        changing I, Next_Entry, S;
        maintaining (|S| = (D - I));
        decreasing (D - I);
    do
        Pop(Next_Entry, S);
        Increment(I);
    end;


VC(s):
     |- (S = Empty_String)

_____________________

Applied While Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));

    If ( Are_Not_Equal(I, D) ) then
        Pop(Next_Entry, S);
        Increment(I);
        Confirm ((|S| = (D - I)) and ((1 + (D - I)) <= P_Val'));
    Else
        VC_Confirm
             |- (S = Empty_String)

    end;


VC(s):

_____________________

Applied If-Part Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));
    Stipulate (I /= D);
    Pop(Next_Entry, S);
    Increment(I);
    Confirm ((|S| = (D - I)) and ((1 + (D - I)) <= P_Val'));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));
    Stipulate (I /= D);
    Pop(Next_Entry, S);
    Increment(I);

VC(s):
     |- (|S| = (D - I))

     |- ((1 + (D - I)) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((|S| = (D - I)) and ((1 + (D - I)) <= P_Val'))" shape="box" ];
      2 [ label=" |- (|S| = (D - I))" shape="box" color="red" ];
      3 [ label=" |- ((1 + (D - I)) <= P_Val')" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));
    Stipulate (I /= D);
    Pop(Next_Entry, S);
    Confirm ((1 + I) <= max_int);
    Assume (I' = (1 + I));

VC(s):
     |- (|S| = (D - I'))

     |- ((1 + (D - I')) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));
    Stipulate (I /= D);
    Pop(Next_Entry, S);
    Confirm ((1 + I) <= max_int);

VC(s):
     |- (|S| = (D - (1 + I)))

     |- ((1 + (D - (1 + I))) <= P_Val')

_____________________

Applied Confirm Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));
    Stipulate (I /= D);
    Pop(Next_Entry, S);

VC(s):
     |- ((1 + I) <= max_int)

     |- (|S| = (D - (1 + I)))

     |- ((1 + (D - (1 + I))) <= P_Val')

_____________________

Applied Call Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));
    Stipulate (I /= D);
    Confirm (1 <= |S|);
    Assume (S = (<Next_Entry'> o S'));

VC(s):
     |- ((1 + I) <= max_int)

     |- (|S'| = (D - (1 + I)))

     |- ((1 + (D - (1 + I))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));
    Stipulate (I /= D);
    Confirm (1 <= |S|);

VC(s):
     |- ((1 + I) <= max_int)

    (S = (<Next_Entry'> o S')) |- (|S'| = (D - (1 + I)))

     |- ((1 + (D - (1 + I))) <= P_Val')

_____________________

Applied Confirm Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));
    Stipulate (I /= D);

VC(s):
     |- (1 <= |S|)

     |- ((1 + I) <= max_int)

    (S = (<Next_Entry'> o S')) |- (|S'| = (D - (1 + I)))

     |- ((1 + (D - (1 + I))) <= P_Val')

_____________________

Applied Stipulate Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));

VC(s):
    (I /= D) |- (1 <= |S|)

    (I /= D) |- ((1 + I) <= max_int)

    (S = (<Next_Entry'> o S')), (I /= D) |- (|S'| = (D - (1 + I)))

    (I /= D) |- ((1 + (D - (1 + I))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;

VC(s):
    (I /= D), (|S| = (D - I)) |- (1 <= |S|)

    (I /= D), (|S| = (D - I)) |- ((1 + I) <= max_int)

    (S = (<Next_Entry'> o S')), (I /= D), (|S| = (D - I)) |- (|S'| = (D - (1 + I)))

    (I /= D), (|S| = (D - I)) |- ((1 + (D - (1 + I))) <= (D - I))

Reduction Tree(s):
    strict digraph G {
      1 [ label="((|S| = (D - I)) and (P_Val' = (D - I))) |- " shape="box" ];
      2 [ label="(|S| = (D - I)), (P_Val' = (D - I)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Change Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));

VC(s):
    (I'' /= D), (|S''| = (D - I'')) |- (1 <= |S''|)

    (I'' /= D), (|S''| = (D - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= D), (|S''| = (D - I'')) |- (|S'| = (D - (1 + I'')))

    (I'' /= D), (|S''| = (D - I'')) |- ((1 + (D - (1 + I''))) <= (D - I''))

_____________________

Applied Confirm Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);

VC(s):
     |- (|S| = (D - I))

    (I'' /= D), (|S''| = (D - I'')) |- (1 <= |S''|)

    (I'' /= D), (|S''| = (D - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= D), (|S''| = (D - I'')) |- (|S'| = (D - (1 + I'')))

    (I'' /= D), (|S''| = (D - I'')) |- ((1 + (D - (1 + I''))) <= (D - I''))

_____________________

Applied Function Assignment Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    Confirm (min_int <= (|S| + I)) and ((|S| + I) <= max_int);

VC(s):
     |- (|S| = ((|S| + I) - I))

    (I'' /= (|S| + I)), (|S''| = ((|S| + I) - I'')) |- (1 <= |S''|)

    (I'' /= (|S| + I)), (|S''| = ((|S| + I) - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= (|S| + I)), (|S''| = ((|S| + I) - I'')) |- (|S'| = ((|S| + I) - (1 + I'')))

    (I'' /= (|S| + I)), (|S''| = ((|S| + I) - I'')) |- ((1 + ((|S| + I) - (1 + I''))) <= ((|S| + I) - I''))

_____________________

Applied Confirm Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);

VC(s):
     |- (min_int <= (|S| + I))

     |- ((|S| + I) <= max_int)

     |- (|S| = ((|S| + I) - I))

    (I'' /= (|S| + I)), (|S''| = ((|S| + I) - I'')) |- (1 <= |S''|)

    (I'' /= (|S| + I)), (|S''| = ((|S| + I) - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= (|S| + I)), (|S''| = ((|S| + I) - I'')) |- (|S'| = ((|S| + I) - (1 + I'')))

    (I'' /= (|S| + I)), (|S''| = ((|S| + I) - I'')) |- ((1 + ((|S| + I) - (1 + I''))) <= ((|S| + I) - I''))

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- (min_int <= (|S| + I)) and ((|S| + I) <= max_int)" shape="box" ];
      2 [ label=" |- (min_int <= (|S| + I))" shape="box" color="red" ];
      3 [ label=" |- ((|S| + I) <= max_int)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (1 <= |S''|)

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (|S'| = ((|S| + 1) - (1 + I'')))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + ((|S| + 1) - (1 + I''))) <= ((|S| + 1) - I''))

_____________________

Applied Variable Declaration/Initialization Rule (Known Program Type): 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    Assume (I = 0);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (1 <= |S''|)

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (|S'| = ((|S| + 1) - (1 + I'')))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + ((|S| + 1) - (1 + I''))) <= ((|S| + 1) - I''))

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (1 <= |S''|)

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (|S'| = ((|S| + 1) - (1 + I'')))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + ((|S| + 1) - (1 + I''))) <= ((|S| + 1) - I''))

_____________________

Applied Variable Declaration/Initialization Rule (Known Program Type): 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    Assume (D = 0);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (1 <= |S''|)

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (|S'| = ((|S| + 1) - (1 + I'')))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + ((|S| + 1) - (1 + I''))) <= ((|S| + 1) - I''))

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (1 <= |S''|)

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (|S'| = ((|S| + 1) - (1 + I'')))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + ((|S| + 1) - (1 + I''))) <= ((|S| + 1) - I''))

_____________________

Applied Variable Declaration/Initialization Rule (Generic Program Type): 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    Assume Entry.Is_Initial(Next_Entry);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (1 <= |S''|)

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (|S'| = ((|S| + 1) - (1 + I'')))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + ((|S| + 1) - (1 + I''))) <= ((|S| + 1) - I''))

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (1 <= |S''|)

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (|S'| = ((|S| + 1) - (1 + I'')))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + ((|S| + 1) - (1 + I''))) <= ((|S| + 1) - I''))

_____________________

Applied Remember Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (1 <= |S''|)

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- (|S'| = ((|S| + 1) - (1 + I'')))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')) |- ((1 + ((|S| + 1) - (1 + I''))) <= ((|S| + 1) - I''))

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')
    I'' : Z
    Next_Entry'' : 'Entry'
    S'' : Str('Entry')

Statements:

VC(s):
    (min_int <= 0), (|S| = 2) |- (min_int <= (|S| + 1))

    (1 <= max_int), (|S| = 2) |- ((|S| + 1) <= max_int)

    (|S| = 2) |- (|S| = ((|S| + 1) - 1))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')), (|S| = 2) |- (1 <= |S''|)

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')), (1 <= max_int), (|S| = 2) |- ((1 + I'') <= max_int)

    (S'' = (<Next_Entry'> o S')), (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')), (|S| = 2) |- (|S'| = ((|S| + 1) - (1 + I'')))

    (I'' /= (|S| + 1)), (|S''| = ((|S| + 1) - I'')), (|S| = 2) |- ((1 + ((|S| + 1) - (1 + I''))) <= ((|S| + 1) - I''))

Reduction Tree(s):
    strict digraph G {
      1 [ label="(((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2)) |- " shape="box" ];
      2 [ label="(1 <= Max_Depth), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (|S| = 2) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Clear_2 =========================

---------------------
Branching Conditions
---------------------
1. Expression at Int_Assign_Clear_2_Realiz.rb(8:9) is false. [Exp: (I = D)]
---------------------

Applied Else-Part Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));
    Stipulate (I = D);
    VC_Confirm
         |- (S = Empty_String)


VC(s):

_____________________

Applied VCConfirm Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));
    Stipulate (I = D);

VC(s):
     |- (S = Empty_String)

_____________________

Applied Stipulate Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;
    Assume ((|S| = (D - I)) and (P_Val' = (D - I)));

VC(s):
    (I = D) |- (S = Empty_String)

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));
    Change I, Next_Entry, S;

VC(s):
    (I = D), (|S| = (D - I)) |- (S = Empty_String)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((|S| = (D - I)) and (P_Val' = (D - I))) |- " shape="box" ];
      2 [ label="(|S| = (D - I)), (P_Val' = (D - I)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Change Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);
    Confirm (|S| = (D - I));

VC(s):
    (I' = D), (|S'| = (D - I')) |- (S' = Empty_String)

_____________________

Applied Confirm Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    D := Sum(Depth(S), I);

VC(s):
     |- (|S| = (D - I))

    (I' = D), (|S'| = (D - I')) |- (S' = Empty_String)

_____________________

Applied Function Assignment Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);
    Confirm (min_int <= (|S| + I)) and ((|S| + I) <= max_int);

VC(s):
     |- (|S| = ((|S| + I) - I))

    (I' = (|S| + I)), (|S'| = ((|S| + I) - I')) |- (S' = Empty_String)

_____________________

Applied Confirm Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);
    I := Replica(1);

VC(s):
     |- (min_int <= (|S| + I))

     |- ((|S| + I) <= max_int)

     |- (|S| = ((|S| + I) - I))

    (I' = (|S| + I)), (|S'| = ((|S| + I) - I')) |- (S' = Empty_String)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- (min_int <= (|S| + I)) and ((|S| + I) <= max_int)" shape="box" ];
      2 [ label=" |- (min_int <= (|S| + I))" shape="box" color="red" ];
      3 [ label=" |- ((|S| + I) <= max_int)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    _Initialize(I : Integer);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I' = (|S| + 1)), (|S'| = ((|S| + 1) - I')) |- (S' = Empty_String)

_____________________

Applied Variable Declaration/Initialization Rule (Known Program Type): 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);
    Assume (I = 0);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I' = (|S| + 1)), (|S'| = ((|S| + 1) - I')) |- (S' = Empty_String)

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    _Initialize(D : Integer);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I' = (|S| + 1)), (|S'| = ((|S| + 1) - I')) |- (S' = Empty_String)

_____________________

Applied Variable Declaration/Initialization Rule (Known Program Type): 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);
    Assume (D = 0);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I' = (|S| + 1)), (|S'| = ((|S| + 1) - I')) |- (S' = Empty_String)

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    _Initialize(Next_Entry : Entry);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I' = (|S| + 1)), (|S'| = ((|S| + 1) - I')) |- (S' = Empty_String)

_____________________

Applied Variable Declaration/Initialization Rule (Generic Program Type): 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;
    Assume Entry.Is_Initial(Next_Entry);

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I' = (|S| + 1)), (|S'| = ((|S| + 1) - I')) |- (S' = Empty_String)

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));
    Remember;

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I' = (|S| + 1)), (|S'| = ((|S| + 1) - I')) |- (S' = Empty_String)

_____________________

Applied Remember Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:
    Assume (((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2));

VC(s):
     |- (min_int <= (|S| + 1))

     |- ((|S| + 1) <= max_int)

     |- (|S| = ((|S| + 1) - 1))

    (I' = (|S| + 1)), (|S'| = ((|S| + 1) - I')) |- (S' = Empty_String)

_____________________

Applied Assume Rule: 

Free Variables:
    Next_Entry : 'Entry'
    D : Z
    I : Z
    P_Val' : N
    I' : Z
    Next_Entry' : 'Entry'
    S' : Str('Entry')

Statements:

VC(s):
    (min_int <= 0), (|S| = 2) |- (min_int <= (|S| + 1))

    (1 <= max_int), (|S| = 2) |- ((|S| + 1) <= max_int)

    (|S| = 2) |- (|S| = ((|S| + 1) - 1))

    (I' = (|S| + 1)), (|S'| = ((|S| + 1) - I')), (|S| = 2) |- (S' = Empty_String)

Reduction Tree(s):
    strict digraph G {
      1 [ label="(((((1 <= Max_Depth) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) and (|S| = 2)) |- " shape="box" ];
      2 [ label="(1 <= Max_Depth), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len), (|S| = 2) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

