VCs for Do_Nothing_Realiz.rb generated Mon Oct 07 15:38:35 EDT 2024

================================= VC(s): =================================

VC 0_1:
Base Case of the Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(A = A)

Given(s):

VC 0_2:
Base Case of the Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(Lower_Bound <= Lower_Bound)

Given(s):
1. (Lower_Bound <= Upper_Bound)

VC 0_3:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(14:2)

Goal:
(Lower_Bound <= i'')

Given(s):
1. ((1 + i'') <= Upper_Bound)
2. (Lower_Bound <= i'')
3. (Lower_Bound <= Upper_Bound)

VC 0_4:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(14:2)

Goal:
(i'' <= Upper_Bound)

Given(s):
1. ((1 + i'') <= Upper_Bound)
2. (Lower_Bound <= i'')
3. (Lower_Bound <= Upper_Bound)

VC 0_5:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(15:2)

Goal:
(Lower_Bound <= i'')

Given(s):
1. (Temp1'''' = A(i))
2. (A'''''''' = lambda (j : Z).(
        Temp1'''''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
3. ((1 + i'') <= Upper_Bound)
4. (Lower_Bound <= i'')
5. (i = 0)
6. (Lower_Bound <= Upper_Bound)

VC 0_6:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(15:2)

Goal:
(i'' <= Upper_Bound)

Given(s):
1. (Temp1'''' = A(i))
2. (A'''''''' = lambda (j : Z).(
        Temp1'''''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
3. ((1 + i'') <= Upper_Bound)
4. (Lower_Bound <= i'')
5. (i = 0)
6. (Lower_Bound <= Upper_Bound)

VC 0_7:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(16:2)

Goal:
(Lower_Bound <= i'')

Given(s):
1. (Temp1''' = A''''''''(i''))
2. (A''''''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''''''([Universal] j)    otherwise))
3. (A'''''''' = lambda (j : Z).(
        Temp1'''''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
4. ((1 + i'') <= Upper_Bound)
5. (Lower_Bound <= i'')
6. (i = 0)
7. (Lower_Bound <= Upper_Bound)

VC 0_8:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(16:2)

Goal:
(i'' <= Upper_Bound)

Given(s):
1. (Temp1''' = A''''''''(i''))
2. (A''''''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''''''([Universal] j)    otherwise))
3. (A'''''''' = lambda (j : Z).(
        Temp1'''''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
4. ((1 + i'') <= Upper_Bound)
5. (Lower_Bound <= i'')
6. (i = 0)
7. (Lower_Bound <= Upper_Bound)

VC 0_9:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(17:2)

Goal:
(Lower_Bound <= i'')

Given(s):
1. (Temp2'''' = A'''''''(i''))
2. (A'''''' = lambda (j : Z).(
        Temp2'''''    if ([Universal] j = i'')
        A'''''''([Universal] j)    otherwise))
3. (Temp1''' = A''''''''(i''))
4. (A''''''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''''''([Universal] j)    otherwise))
5. (A'''''''' = lambda (j : Z).(
        Temp1'''''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
6. ((1 + i'') <= Upper_Bound)
7. (Lower_Bound <= i'')
8. (i = 0)
9. (Lower_Bound <= Upper_Bound)

VC 0_10:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(17:2)

Goal:
(i'' <= Upper_Bound)

Given(s):
1. (Temp2'''' = A'''''''(i''))
2. (A'''''' = lambda (j : Z).(
        Temp2'''''    if ([Universal] j = i'')
        A'''''''([Universal] j)    otherwise))
3. (Temp1''' = A''''''''(i''))
4. (A''''''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''''''([Universal] j)    otherwise))
5. (A'''''''' = lambda (j : Z).(
        Temp1'''''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
6. ((1 + i'') <= Upper_Bound)
7. (Lower_Bound <= i'')
8. (i = 0)
9. (Lower_Bound <= Upper_Bound)

VC 0_11:
Requires Clause for Increment at Do_Nothing_Realiz.rb(18:2)

Goal:
((1 + i'') <= max_int)

Given(s):
1. (Temp2''' = A''''''(i''))
2. (A''''' = lambda (j : Z).(
        A'''''''(i'')    if ([Universal] j = i'')
        A''''''([Universal] j)    otherwise))
3. (A'''''' = lambda (j : Z).(
        Temp2'''''    if ([Universal] j = i'')
        A'''''''([Universal] j)    otherwise))
4. (Temp1''' = A''''''''(i''))
5. (A''''''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''''''([Universal] j)    otherwise))
6. (A'''''''' = lambda (j : Z).(
        Temp1'''''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
7. ((1 + i'') <= Upper_Bound)
8. (Lower_Bound <= i'')
9. (i = 0)
10. (Lower_Bound <= Upper_Bound)
11. (1 <= max_int)

VC 0_12:
Inductive Case of Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(A = lambda (j : Z).(
        A'''''''(i'')    if ([Universal] j = i'')
        A''''''([Universal] j)    otherwise))

Given(s):
1. (Temp2''' = A''''''(i''))
2. (A'''''' = lambda (j : Z).(
        Temp2'''''    if ([Universal] j = i'')
        A'''''''([Universal] j)    otherwise))
3. (Temp1''' = A''''''''(i''))
4. (A''''''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''''''([Universal] j)    otherwise))
5. (A'''''''' = lambda (j : Z).(
        Temp1'''''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
6. ((1 + i'') <= Upper_Bound)
7. (Lower_Bound <= i'')
8. (i = 0)
9. (Lower_Bound <= Upper_Bound)

VC 0_13:
Inductive Case of Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(Lower_Bound <= (1 + i''))

Given(s):
1. (Temp2''' = A''''''(i''))
2. (A''''' = lambda (j : Z).(
        A'''''''(i'')    if ([Universal] j = i'')
        A''''''([Universal] j)    otherwise))
3. (A'''''' = lambda (j : Z).(
        Temp2'''''    if ([Universal] j = i'')
        A'''''''([Universal] j)    otherwise))
4. (Temp1''' = A''''''''(i''))
5. (A''''''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''''''([Universal] j)    otherwise))
6. (A'''''''' = lambda (j : Z).(
        Temp1'''''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
7. ((1 + i'') <= Upper_Bound)
8. (Lower_Bound <= i'')
9. (i = 0)
10. (Lower_Bound <= Upper_Bound)

VC 0_14:
Termination of While Statement at Do_Nothing_Realiz.rb(12:2)

Goal:
((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

Given(s):
1. (Temp2''' = A''''''(i''))
2. (A''''' = lambda (j : Z).(
        A'''''''(i'')    if ([Universal] j = i'')
        A''''''([Universal] j)    otherwise))
3. (A'''''' = lambda (j : Z).(
        Temp2'''''    if ([Universal] j = i'')
        A'''''''([Universal] j)    otherwise))
4. (Temp1''' = A''''''''(i''))
5. (A''''''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''''''([Universal] j)    otherwise))
6. (A'''''''' = lambda (j : Z).(
        Temp1'''''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
7. ((1 + i'') <= Upper_Bound)
8. (Lower_Bound <= i'')
9. (i = 0)
10. (Lower_Bound <= Upper_Bound)

VC 1_1:
Base Case of the Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(A = A)

Given(s):

VC 1_2:
Base Case of the Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(Lower_Bound <= Lower_Bound)

Given(s):
1. (Lower_Bound <= Upper_Bound)

VC 1_3:
Requires Clause for Swap_Entry [After Logical Reduction(s)] at Do_Nothing_Realiz.rb(21:2)

Goal:
(Lower_Bound <= i') or 
((1 + i') <= Upper_Bound)

Given(s):
1. (i' = Upper_Bound)
2. (Lower_Bound <= i')
3. (Lower_Bound <= Upper_Bound)

VC 1_4:
Requires Clause for Swap_Entry [After Logical Reduction(s)] at Do_Nothing_Realiz.rb(21:2)

Goal:
(i' <= Upper_Bound) or 
((1 + i') <= Upper_Bound)

Given(s):
1. (i' = Upper_Bound)
2. (Lower_Bound <= i')
3. (Lower_Bound <= Upper_Bound)

VC 1_5:
Requires Clause for Swap_Entry [After Logical Reduction(s)] at Do_Nothing_Realiz.rb(22:2)

Goal:
(Lower_Bound <= i') or 
((1 + i') <= Upper_Bound)

Given(s):
1. (Temp1'' = A(i))
2. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i')
        A([Universal] j)    otherwise))
3. (i' = Upper_Bound)
4. (Lower_Bound <= i')
5. (i = 0)
6. (Lower_Bound <= Upper_Bound)

VC 1_6:
Requires Clause for Swap_Entry [After Logical Reduction(s)] at Do_Nothing_Realiz.rb(22:2)

Goal:
(i' <= Upper_Bound) or 
((1 + i') <= Upper_Bound)

Given(s):
1. (Temp1'' = A(i))
2. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i')
        A([Universal] j)    otherwise))
3. (i' = Upper_Bound)
4. (Lower_Bound <= i')
5. (i = 0)
6. (Lower_Bound <= Upper_Bound)

VC 1_7:
Requires Clause for Swap_Entry [After Logical Reduction(s)] at Do_Nothing_Realiz.rb(23:2)

Goal:
(Lower_Bound <= i') or 
((1 + i') <= Upper_Bound)

Given(s):
1. (Temp1' = A''''(i'))
2. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i')
        A''''([Universal] j)    otherwise))
3. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i')
        A([Universal] j)    otherwise))
4. (i' = Upper_Bound)
5. (Lower_Bound <= i')
6. (i = 0)
7. (Lower_Bound <= Upper_Bound)

VC 1_8:
Requires Clause for Swap_Entry [After Logical Reduction(s)] at Do_Nothing_Realiz.rb(23:2)

Goal:
(i' <= Upper_Bound) or 
((1 + i') <= Upper_Bound)

Given(s):
1. (Temp1' = A''''(i'))
2. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i')
        A''''([Universal] j)    otherwise))
3. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i')
        A([Universal] j)    otherwise))
4. (i' = Upper_Bound)
5. (Lower_Bound <= i')
6. (i = 0)
7. (Lower_Bound <= Upper_Bound)

VC 1_9:
Requires Clause for Swap_Entry [After Logical Reduction(s)] at Do_Nothing_Realiz.rb(24:2)

Goal:
(Lower_Bound <= i') or 
((1 + i') <= Upper_Bound)

Given(s):
1. (Temp2'' = A'''(i'))
2. (A'' = lambda (j : Z).(
        Temp2'''    if ([Universal] j = i')
        A'''([Universal] j)    otherwise))
3. (Temp1' = A''''(i'))
4. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i')
        A''''([Universal] j)    otherwise))
5. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i')
        A([Universal] j)    otherwise))
6. (i' = Upper_Bound)
7. (Lower_Bound <= i')
8. (i = 0)
9. (Lower_Bound <= Upper_Bound)

VC 1_10:
Requires Clause for Swap_Entry [After Logical Reduction(s)] at Do_Nothing_Realiz.rb(24:2)

Goal:
(i' <= Upper_Bound) or 
((1 + i') <= Upper_Bound)

Given(s):
1. (Temp2'' = A'''(i'))
2. (A'' = lambda (j : Z).(
        Temp2'''    if ([Universal] j = i')
        A'''([Universal] j)    otherwise))
3. (Temp1' = A''''(i'))
4. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i')
        A''''([Universal] j)    otherwise))
5. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i')
        A([Universal] j)    otherwise))
6. (i' = Upper_Bound)
7. (Lower_Bound <= i')
8. (i = 0)
9. (Lower_Bound <= Upper_Bound)

VC 1_11:
Ensures Clause of Do_Nothing (Condition from "RESTORES" parameter mode) [After Logical Reduction(s)] at Do_Nothing_Realiz.rb(4:34)

Goal:
(lambda (j : Z).(
        A'''(i')    if ([Universal] j = i')
        A''([Universal] j)    otherwise) = A) or 
((1 + i') <= Upper_Bound)

Given(s):
1. (Temp2' = A''(i'))
2. (A'' = lambda (j : Z).(
        Temp2'''    if ([Universal] j = i')
        A'''([Universal] j)    otherwise))
3. (Temp1' = A''''(i'))
4. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i')
        A''''([Universal] j)    otherwise))
5. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i')
        A([Universal] j)    otherwise))
6. (i' = Upper_Bound)
7. (Lower_Bound <= i')
8. (i = 0)
9. (Lower_Bound <= Upper_Bound)

VC 2_1:
Base Case of the Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(A = A)

Given(s):

VC 2_2:
Base Case of the Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(Lower_Bound <= Lower_Bound)

Given(s):
1. (Lower_Bound <= Upper_Bound)

VC 2_3:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(14:2)

Goal:
(Lower_Bound <= i'')

Given(s):
1. ((1 + i'') <= Upper_Bound)
2. (Lower_Bound <= i'')
3. (Lower_Bound <= Upper_Bound)

VC 2_4:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(14:2)

Goal:
(i'' <= Upper_Bound)

Given(s):
1. ((1 + i'') <= Upper_Bound)
2. (Lower_Bound <= i'')
3. (Lower_Bound <= Upper_Bound)

VC 2_5:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(15:2)

Goal:
(Lower_Bound <= i'')

Given(s):
1. (Temp1'' = A(i))
2. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
3. ((1 + i'') <= Upper_Bound)
4. (Lower_Bound <= i'')
5. (i = 0)
6. (Lower_Bound <= Upper_Bound)

VC 2_6:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(15:2)

Goal:
(i'' <= Upper_Bound)

Given(s):
1. (Temp1'' = A(i))
2. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
3. ((1 + i'') <= Upper_Bound)
4. (Lower_Bound <= i'')
5. (i = 0)
6. (Lower_Bound <= Upper_Bound)

VC 2_7:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(16:2)

Goal:
(Lower_Bound <= i'')

Given(s):
1. (Temp1' = A''''(i''))
2. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''([Universal] j)    otherwise))
3. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
4. ((1 + i'') <= Upper_Bound)
5. (Lower_Bound <= i'')
6. (i = 0)
7. (Lower_Bound <= Upper_Bound)

VC 2_8:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(16:2)

Goal:
(i'' <= Upper_Bound)

Given(s):
1. (Temp1' = A''''(i''))
2. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''([Universal] j)    otherwise))
3. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
4. ((1 + i'') <= Upper_Bound)
5. (Lower_Bound <= i'')
6. (i = 0)
7. (Lower_Bound <= Upper_Bound)

VC 2_9:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(17:2)

Goal:
(Lower_Bound <= i'')

Given(s):
1. (Temp2'' = A'''(i''))
2. (A'' = lambda (j : Z).(
        Temp2'''    if ([Universal] j = i'')
        A'''([Universal] j)    otherwise))
3. (Temp1' = A''''(i''))
4. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''([Universal] j)    otherwise))
5. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
6. ((1 + i'') <= Upper_Bound)
7. (Lower_Bound <= i'')
8. (i = 0)
9. (Lower_Bound <= Upper_Bound)

VC 2_10:
Requires Clause for Swap_Entry at Do_Nothing_Realiz.rb(17:2)

Goal:
(i'' <= Upper_Bound)

Given(s):
1. (Temp2'' = A'''(i''))
2. (A'' = lambda (j : Z).(
        Temp2'''    if ([Universal] j = i'')
        A'''([Universal] j)    otherwise))
3. (Temp1' = A''''(i''))
4. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''([Universal] j)    otherwise))
5. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
6. ((1 + i'') <= Upper_Bound)
7. (Lower_Bound <= i'')
8. (i = 0)
9. (Lower_Bound <= Upper_Bound)

VC 2_11:
Requires Clause for Increment at Do_Nothing_Realiz.rb(18:2)

Goal:
((1 + i'') <= max_int)

Given(s):
1. (Temp2' = A''(i''))
2. (A' = lambda (j : Z).(
        A'''(i'')    if ([Universal] j = i'')
        A''([Universal] j)    otherwise))
3. (A'' = lambda (j : Z).(
        Temp2'''    if ([Universal] j = i'')
        A'''([Universal] j)    otherwise))
4. (Temp1' = A''''(i''))
5. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''([Universal] j)    otherwise))
6. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
7. ((1 + i'') <= Upper_Bound)
8. (Lower_Bound <= i'')
9. (i = 0)
10. (Lower_Bound <= Upper_Bound)
11. (1 <= max_int)

VC 2_12:
Inductive Case of Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(A = lambda (j : Z).(
        A'''(i'')    if ([Universal] j = i'')
        A''([Universal] j)    otherwise))

Given(s):
1. (Temp2' = A''(i''))
2. (A'' = lambda (j : Z).(
        Temp2'''    if ([Universal] j = i'')
        A'''([Universal] j)    otherwise))
3. (Temp1' = A''''(i''))
4. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''([Universal] j)    otherwise))
5. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
6. ((1 + i'') <= Upper_Bound)
7. (Lower_Bound <= i'')
8. (i = 0)
9. (Lower_Bound <= Upper_Bound)

VC 2_13:
Inductive Case of Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(Lower_Bound <= (1 + i''))

Given(s):
1. (Temp2' = A''(i''))
2. (A' = lambda (j : Z).(
        A'''(i'')    if ([Universal] j = i'')
        A''([Universal] j)    otherwise))
3. (A'' = lambda (j : Z).(
        Temp2'''    if ([Universal] j = i'')
        A'''([Universal] j)    otherwise))
4. (Temp1' = A''''(i''))
5. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''([Universal] j)    otherwise))
6. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
7. ((1 + i'') <= Upper_Bound)
8. (Lower_Bound <= i'')
9. (i = 0)
10. (Lower_Bound <= Upper_Bound)

VC 2_14:
Termination of While Statement at Do_Nothing_Realiz.rb(12:2)

Goal:
((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

Given(s):
1. (Temp2' = A''(i''))
2. (A' = lambda (j : Z).(
        A'''(i'')    if ([Universal] j = i'')
        A''([Universal] j)    otherwise))
3. (A'' = lambda (j : Z).(
        Temp2'''    if ([Universal] j = i'')
        A'''([Universal] j)    otherwise))
4. (Temp1' = A''''(i''))
5. (A''' = lambda (j : Z).(
        A(i)    if ([Universal] j = i'')
        A''''([Universal] j)    otherwise))
6. (A'''' = lambda (j : Z).(
        Temp1'''    if ([Universal] j = i'')
        A([Universal] j)    otherwise))
7. ((1 + i'') <= Upper_Bound)
8. (Lower_Bound <= i'')
9. (i = 0)
10. (Lower_Bound <= Upper_Bound)

VC 3_1:
Base Case of the Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(A = A)

Given(s):

VC 3_2:
Base Case of the Invariant of While Statement at Do_Nothing_Realiz.rb(11:14)

Goal:
(Lower_Bound <= Lower_Bound)

Given(s):
1. (Lower_Bound <= Upper_Bound)

VC 3_3:
Ensures Clause of Do_Nothing (Condition from "RESTORES" parameter mode) [After Logical Reduction(s)] at Do_Nothing_Realiz.rb(4:34)

Goal:
(A = A) or 
(i' = Upper_Bound) or 
((1 + i') <= Upper_Bound)

Given(s):
1. (Lower_Bound <= i')
2. (Lower_Bound <= Upper_Bound)

========================= VC Generation Details  =========================

    Enhancement Realization Name:   Do_Nothing_Realiz
    Enhancement Name:               Do_Nothing_Capability
    Concept Name:                   Static_Array_Template

==========================================================================

========================= Do_Nothing =========================

---------------------
Branching Conditions
---------------------
1. Expression at Do_Nothing_Realiz.rb(9:8) is true. [Exp: ((1 + i) <= Upper_Bound)]
2. Expression at Do_Nothing_Realiz.rb(20:5) is true. [Exp: (i = Upper_Bound)]
---------------------

Applied Procedure Declaration Rule (Part 1): 

Free Variables:

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;

VC(s):

_____________________

Applied Procedure Declaration Rule (Part 2): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;


    If ( Are_Equal(i, Upper_Bound) ) then
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
    end;

    _Finalize(i : Integer);
    Confirm (A = #A);

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;


    If ( Are_Equal(i, Upper_Bound) ) then
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
    end;

    _Finalize(i : Integer);

VC(s):
     |- (A = #A)

_____________________

Applied Variable Finalization Rule (Known Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;


    If ( Are_Equal(i, Upper_Bound) ) then
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
    end;

    Assume true;

VC(s):
     |- (A = #A)

_____________________

Applied Assume Rule and Simplified: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;


    If ( Are_Equal(i, Upper_Bound) ) then
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
    end;


VC(s):
     |- (A = #A)

_____________________

Applied If-Part Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Swap_Entry(A, Temp2, i);

VC(s):
     |- (A = #A)

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp2' = A(i)) and (A' = lambda (j : Z).(
        Temp2    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- (A' = #A)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp2' = A(i)) |- (lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise) = #A)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp2' = A(i)) and (A' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp2' = A(i)), (A' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2' = A(i)) |- (lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise) = #A)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp2'' = A(i)) and (A'' = lambda (j : Z).(
        Temp2    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2' = A''(i)) |- (lambda (j : Z).(
Temp2''if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp2'' = A(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (lambda (j : Z).(
A(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp2'' = A(i)) and (A'' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp2'' = A(i)), (A'' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2'' = A(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (lambda (j : Z).(
A(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp1' = A(i)) and (A''' = lambda (j : Z).(
        Temp1    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp1' = A(i)) and (A''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp1' = A(i)), (A''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Swap_Entry(A, Temp1, i);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp1'' = A(i)) and (A'''' = lambda (j : Z).(
        Temp1    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp1'' = A(i)) and (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp1'' = A(i)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate (i = Upper_Bound);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Stipulate Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;


VC(s):
    (i = Upper_Bound) |- (Lower_Bound <= i)

    (i = Upper_Bound) |- (i <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

_____________________

Applied While Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));

    If ( Less(i, Upper_Bound) ) then
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
        Confirm (((#A = A) and (Lower_Bound <= i)) and ((1 + (Upper_Bound + -(i))) <= P_Val'));
    Else
        VC_Confirm
            (i = Upper_Bound) |- (Lower_Bound <= i)

            (i = Upper_Bound) |- (i <= Upper_Bound)

            (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

            (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

            (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

            (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

            (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

            (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

            (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

    end;


VC(s):

_____________________

Applied If-Part Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Swap_Entry(A, Temp2, i);
    Increment(i);
    Confirm (((#A = A) and (Lower_Bound <= i)) and ((1 + (Upper_Bound + -(i))) <= P_Val'));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Swap_Entry(A, Temp2, i);
    Increment(i);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= i)

     |- ((1 + (Upper_Bound + -(i))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- (((#A = A) and (Lower_Bound <= i)) and ((1 + (Upper_Bound + -(i))) <= P_Val'))" shape="box" ];
      2 [ label=" |- ((#A = A) and (Lower_Bound <= i))" shape="box" ];
      3 [ label=" |- ((1 + (Upper_Bound + -(i))) <= P_Val')" shape="box" color="red" ];
      4 [ label=" |- (#A = A)" shape="box" color="red" ];
      5 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Swap_Entry(A, Temp2, i);
    Confirm ((1 + i) <= max_int);
    Assume (i' = (1 + i));

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= i')

     |- ((1 + (Upper_Bound + -(i'))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Swap_Entry(A, Temp2, i);
    Confirm ((1 + i) <= max_int);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= (1 + i))

     |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Swap_Entry(A, Temp2, i);

VC(s):
     |- ((1 + i) <= max_int)

     |- (#A = A)

     |- (Lower_Bound <= (1 + i))

     |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp2''' = A(i)) and (A''''' = lambda (j : Z).(
        Temp2    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- ((1 + i) <= max_int)

     |- (#A = A''''')

     |- (Lower_Bound <= (1 + i))

     |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp2''' = A(i)), (A''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2''' = A(i)) |- (#A = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise))

    (Temp2''' = A(i)), (A''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A(i)), (A''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp2''' = A(i)) and (A''''' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp2''' = A(i)), (A''''' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2''' = A(i)), (A''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2''' = A(i)) |- (#A = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise))

    (Temp2''' = A(i)), (A''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A(i)), (A''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp2'''' = A(i)) and (A'''''' = lambda (j : Z).(
        Temp2    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
Temp2''''if ([Universal] j = i)
A''''''([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2''' = A''''''(i)) |- (#A = lambda (j : Z).(
Temp2''''if ([Universal] j = i)
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
Temp2''''if ([Universal] j = i)
A''''''([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
Temp2''''if ([Universal] j = i)
A''''''([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp2'''' = A(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'''' = A(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2''' = A''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp2'''' = A(i)) and (A'''''' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp2'''' = A(i)), (A'''''' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2'''' = A(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'''' = A(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2''' = A''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp1''' = A(i)) and (A''''''' = lambda (j : Z).(
        Temp1    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2''' = A''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2''' = A''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp1''' = A(i)) and (A''''''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2''' = A''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A(i)), (A''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp1'''' = A(i)) and (A'''''''' = lambda (j : Z).(
        Temp1    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
Temp1''''if ([Universal] j = i)
A''''''''([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
Temp1''''if ([Universal] j = i)
A''''''''([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
Temp1''''if ([Universal] j = i)
A''''''''([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
Temp1''''if ([Universal] j = i)
A''''''''([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
Temp1''''if ([Universal] j = i)
A''''''''([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2''' = A''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
Temp1''''if ([Universal] j = i)
A''''''''([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
Temp1''''if ([Universal] j = i)
A''''''''([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
Temp1''''if ([Universal] j = i)
A''''''''([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp1'''' = A(i)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1'''' = A(i)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2''' = A''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp1'''' = A(i)) and (A'''''''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp1'''' = A(i)), (A'''''''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp1'''' = A(i)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1'''' = A(i)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2''' = A''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Stipulate Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));

VC(s):
    ((1 + i) <= Upper_Bound) |- (Lower_Bound <= i)

    ((1 + i) <= Upper_Bound) |- (i <= Upper_Bound)

    (Temp1'''' = A(i)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (Lower_Bound <= i)

    (Temp1'''' = A(i)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (i <= Upper_Bound)

    (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (Lower_Bound <= i)

    (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (i <= Upper_Bound)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (Lower_Bound <= i)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (i <= Upper_Bound)

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- ((1 + i) <= max_int)

    (Temp2''' = A''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (#A = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;

VC(s):
    ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i)

    ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound)

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i)

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound)

    (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i)

    (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i)

    (Temp2'''' = A'''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound)

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- ((1 + i) <= max_int)

    (Temp2''' = A''''''(i)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (#A = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= (1 + i))

    (Temp2''' = A''''''(i)), (A''''' = lambda (j : Z).(
A'''''''(i)if ([Universal] j = i)
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i)), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- ((1 + (Upper_Bound + -((1 + i)))) <= (Upper_Bound + -(i)))

Reduction Tree(s):
    strict digraph G {
      1 [ label="(((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i)))) |- " shape="box" ];
      2 [ label="(#A = A), (Lower_Bound <= i), (P_Val' = (Upper_Bound + -(i))) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Change Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'
    A''''''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''''' : 'Entry'
    Temp2''''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));

VC(s):
    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + i'') <= max_int)

    (Temp2''' = A''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (#A = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= (1 + i''))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'
    A''''''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''''' : 'Entry'
    Temp2''''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= i)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + i'') <= max_int)

    (Temp2''' = A''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (#A = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= (1 + i''))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((#A = A) and (Lower_Bound <= i))" shape="box" ];
      2 [ label=" |- (#A = A)" shape="box" color="red" ];
      3 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'
    A''''''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''''' : 'Entry'
    Temp2''''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + i'') <= max_int)

    (Temp2''' = A''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (#A = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= (1 + i''))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Variable Declaration/Initialization Rule (Known Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'
    A''''''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''''' : 'Entry'
    Temp2''''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    Assume (i = 0);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + i'') <= max_int)

    (Temp2''' = A''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (#A = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= (1 + i''))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'
    A''''''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''''' : 'Entry'
    Temp2''''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2''' = A''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (#A = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Variable Declaration/Initialization Rule (Generic Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'
    A''''''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''''' : 'Entry'
    Temp2''''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    Assume Entry.Is_Initial(Temp2);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2''' = A''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (#A = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'
    A''''''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''''' : 'Entry'
    Temp2''''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2''' = A''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (#A = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Variable Declaration/Initialization Rule (Generic Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'
    A''''''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''''' : 'Entry'
    Temp2''''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    Assume Entry.Is_Initial(Temp1);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2''' = A''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (#A = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'
    A''''''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''''' : 'Entry'
    Temp2''''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'''' = #A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2''' = A''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (#A = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Remember Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'
    A''''''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''''' : 'Entry'
    Temp2''''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));

VC(s):
     |- (A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'''' = A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'''' = A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2''' = A''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (A = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    i' : Z
    A''''' : (Z -> 'Entry')
    Temp2''' : 'Entry'
    A'''''' : (Z -> 'Entry')
    Temp2'''' : 'Entry'
    A''''''' : (Z -> 'Entry')
    Temp1''' : 'Entry'
    A'''''''' : (Z -> 'Entry')
    Temp1'''' : 'Entry'
    A''''''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''''' : 'Entry'
    Temp2''''' : 'Entry'

Statements:

VC(s):
     |- (A = A)

    (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (Lower_Bound <= Upper_Bound) |- (i'' <= Upper_Bound)

    (Temp1'''' = A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'')

    (Temp1'''' = A(i)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (i'' <= Upper_Bound)

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'')

    (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (i'' <= Upper_Bound)

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'')

    (Temp2'''' = A'''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (i'' <= Upper_Bound)

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound), (1 <= max_int) |- ((1 + i'') <= max_int)

    (Temp2''' = A''''''(i'')), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (A = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= (1 + i''))

    (Temp2''' = A''''''(i'')), (A''''' = lambda (j : Z).(
A'''''''(i'')if ([Universal] j = i'')
A''''''([Universal] j)otherwise)), (A'''''' = lambda (j : Z).(
Temp2'''''if ([Universal] j = i'')
A'''''''([Universal] j)otherwise)), (Temp1''' = A''''''''(i'')), (A''''''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''''''([Universal] j)otherwise)), (A'''''''' = lambda (j : Z).(
Temp1'''''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

Reduction Tree(s):
    strict digraph G {
      1 [ label="((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) |- " shape="box" ];
      2 [ label="(Lower_Bound <= Upper_Bound), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Do_Nothing =========================

---------------------
Branching Conditions
---------------------
1. Expression at Do_Nothing_Realiz.rb(9:8) is false. [Exp: not(((1 + i) <= Upper_Bound))]
2. Expression at Do_Nothing_Realiz.rb(20:5) is true. [Exp: (i = Upper_Bound)]
---------------------

Applied Else-Part Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate not(((1 + i) <= Upper_Bound));
    VC_Confirm
        (i = Upper_Bound) |- (Lower_Bound <= i)

        (i = Upper_Bound) |- (i <= Upper_Bound)

        (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

        (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

        (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

        (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

        (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

        (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

        (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)


VC(s):

_____________________

Applied VCConfirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate not(((1 + i) <= Upper_Bound));

VC(s):
    (i = Upper_Bound) |- (Lower_Bound <= i)

    (i = Upper_Bound) |- (i <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A)

_____________________

Applied Stipulate Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));

VC(s):
    (i = Upper_Bound) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)

    (i = Upper_Bound) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), (i = Upper_Bound) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A), ((1 + i) <= Upper_Bound)

Reduction Tree(s):
    strict digraph G {
      1 [ label="(i = Upper_Bound), not(((1 + i) <= Upper_Bound)) |- (Lower_Bound <= i)" shape="box" ];
      2 [ label="(i = Upper_Bound) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
    }

    strict digraph G {
      1 [ label="(i = Upper_Bound), not(((1 + i) <= Upper_Bound)) |- (i <= Upper_Bound)" shape="box" ];
      2 [ label="(i = Upper_Bound) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
    }

    strict digraph G {
      1 [ label="(Temp1'' = A(i)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound), not(((1 + i) <= Upper_Bound)) |- (Lower_Bound <= i)" shape="box" ];
      2 [ label="(Temp1'' = A(i)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
    }

    strict digraph G {
      1 [ label="(Temp1'' = A(i)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound), not(((1 + i) <= Upper_Bound)) |- (i <= Upper_Bound)" shape="box" ];
      2 [ label="(Temp1'' = A(i)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
    }

    strict digraph G {
      1 [ label="(Temp1' = A''''(i)), (A''' = lambda (j : Z).(
    A(i)if ([Universal] j = i)
    A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound), not(((1 + i) <= Upper_Bound)) |- (Lower_Bound <= i)" shape="box" ];
      2 [ label="(Temp1' = A''''(i)), (A''' = lambda (j : Z).(
    A(i)if ([Universal] j = i)
    A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
    }

    strict digraph G {
      1 [ label="(Temp1' = A''''(i)), (A''' = lambda (j : Z).(
    A(i)if ([Universal] j = i)
    A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound), not(((1 + i) <= Upper_Bound)) |- (i <= Upper_Bound)" shape="box" ];
      2 [ label="(Temp1' = A''''(i)), (A''' = lambda (j : Z).(
    A(i)if ([Universal] j = i)
    A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
    }

    strict digraph G {
      1 [ label="(Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
    A(i)if ([Universal] j = i)
    A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound), not(((1 + i) <= Upper_Bound)) |- (Lower_Bound <= i)" shape="box" ];
      2 [ label="(Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
    A(i)if ([Universal] j = i)
    A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
    }

    strict digraph G {
      1 [ label="(Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
    A(i)if ([Universal] j = i)
    A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound), not(((1 + i) <= Upper_Bound)) |- (i <= Upper_Bound)" shape="box" ];
      2 [ label="(Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
    A(i)if ([Universal] j = i)
    A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
    }

    strict digraph G {
      1 [ label="(Temp2' = A''(i)), (A'' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
    A(i)if ([Universal] j = i)
    A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound), not(((1 + i) <= Upper_Bound)) |- (lambda (j : Z).(
    A'''(i)if ([Universal] j = i)
    A''([Universal] j)otherwise) = #A)" shape="box" ];
      2 [ label="(Temp2' = A''(i)), (A'' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
    A(i)if ([Universal] j = i)
    A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)), (i = Upper_Bound) |- (lambda (j : Z).(
    A'''(i)if ([Universal] j = i)
    A''([Universal] j)otherwise) = #A), ((1 + i) <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;

VC(s):
    (i = Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)

    (i = Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), (i = Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), (i = Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), (i = Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), (i = Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), (i = Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i), ((1 + i) <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), (i = Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound), ((1 + i) <= Upper_Bound)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), (i = Upper_Bound), (Lower_Bound <= i) |- (lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise) = #A), ((1 + i) <= Upper_Bound)

Reduction Tree(s):
    strict digraph G {
      1 [ label="(((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i)))) |- " shape="box" ];
      2 [ label="(#A = A), (Lower_Bound <= i), (P_Val' = (Upper_Bound + -(i))) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Change Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    A''''' : (Z -> 'Entry')
    i' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));

VC(s):
    (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2' = A''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (lambda (j : Z).(
A'''(i')if ([Universal] j = i')
A''([Universal] j)otherwise) = #A), ((1 + i') <= Upper_Bound)

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    A''''' : (Z -> 'Entry')
    i' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= i)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2' = A''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (lambda (j : Z).(
A'''(i')if ([Universal] j = i')
A''([Universal] j)otherwise) = #A), ((1 + i') <= Upper_Bound)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((#A = A) and (Lower_Bound <= i))" shape="box" ];
      2 [ label=" |- (#A = A)" shape="box" color="red" ];
      3 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    A''''' : (Z -> 'Entry')
    i' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2' = A''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (lambda (j : Z).(
A'''(i')if ([Universal] j = i')
A''([Universal] j)otherwise) = #A), ((1 + i') <= Upper_Bound)

_____________________

Applied Variable Declaration/Initialization Rule (Known Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    A''''' : (Z -> 'Entry')
    i' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    Assume (i = 0);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2' = A''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i') |- (lambda (j : Z).(
A'''(i')if ([Universal] j = i')
A''([Universal] j)otherwise) = #A), ((1 + i') <= Upper_Bound)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    A''''' : (Z -> 'Entry')
    i' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2' = A''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (lambda (j : Z).(
A'''(i')if ([Universal] j = i')
A''([Universal] j)otherwise) = #A), ((1 + i') <= Upper_Bound)

_____________________

Applied Variable Declaration/Initialization Rule (Generic Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    A''''' : (Z -> 'Entry')
    i' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    Assume Entry.Is_Initial(Temp2);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2' = A''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (lambda (j : Z).(
A'''(i')if ([Universal] j = i')
A''([Universal] j)otherwise) = #A), ((1 + i') <= Upper_Bound)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    A''''' : (Z -> 'Entry')
    i' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2' = A''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (lambda (j : Z).(
A'''(i')if ([Universal] j = i')
A''([Universal] j)otherwise) = #A), ((1 + i') <= Upper_Bound)

_____________________

Applied Variable Declaration/Initialization Rule (Generic Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    A''''' : (Z -> 'Entry')
    i' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    Assume Entry.Is_Initial(Temp1);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2' = A''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (lambda (j : Z).(
A'''(i')if ([Universal] j = i')
A''([Universal] j)otherwise) = #A), ((1 + i') <= Upper_Bound)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    A''''' : (Z -> 'Entry')
    i' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2' = A''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
#A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (lambda (j : Z).(
A'''(i')if ([Universal] j = i')
A''([Universal] j)otherwise) = #A), ((1 + i') <= Upper_Bound)

_____________________

Applied Remember Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    A''''' : (Z -> 'Entry')
    i' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));

VC(s):
     |- (A = A)

     |- (Lower_Bound <= Lower_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i') |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2' = A''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0) |- (lambda (j : Z).(
A'''(i')if ([Universal] j = i')
A''([Universal] j)otherwise) = A), ((1 + i') <= Upper_Bound)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    P_Val' : N
    A''''' : (Z -> 'Entry')
    i' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:

VC(s):
     |- (A = A)

    (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= Lower_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i'), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (i' = Upper_Bound), (Lower_Bound <= i'), (Lower_Bound <= Upper_Bound) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0), (Lower_Bound <= Upper_Bound) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0), (Lower_Bound <= Upper_Bound) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'), ((1 + i') <= Upper_Bound)

    (Temp2'' = A'''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0), (Lower_Bound <= Upper_Bound) |- (i' <= Upper_Bound), ((1 + i') <= Upper_Bound)

    (Temp2' = A''(i')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i')
A([Universal] j)otherwise)), (i' = Upper_Bound), (Lower_Bound <= i'), (i = 0), (Lower_Bound <= Upper_Bound) |- (lambda (j : Z).(
A'''(i')if ([Universal] j = i')
A''([Universal] j)otherwise) = A), ((1 + i') <= Upper_Bound)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) |- " shape="box" ];
      2 [ label="(Lower_Bound <= Upper_Bound), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Do_Nothing =========================

---------------------
Branching Conditions
---------------------
1. Expression at Do_Nothing_Realiz.rb(9:8) is true. [Exp: ((1 + i) <= Upper_Bound)]
2. Expression at Do_Nothing_Realiz.rb(20:5) is false. [Exp: not((i = Upper_Bound))]
---------------------

Applied Else-Part Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;

    Stipulate not((i = Upper_Bound));

VC(s):
     |- (A = #A)

_____________________

Applied Stipulate Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

    While ( Less(i, Upper_Bound) )
        changing A, i, Temp1, Temp2;
        maintaining ((#A = A) and (Lower_Bound <= i));
        decreasing (Upper_Bound + -(i));
    do
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
    end;


VC(s):
     |- (A = #A), (i = Upper_Bound)

Reduction Tree(s):
    strict digraph G {
      1 [ label="not((i = Upper_Bound)) |- (A = #A)" shape="box" ];
      2 [ label=" |- (A = #A), (i = Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied While Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));

    If ( Less(i, Upper_Bound) ) then
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp1, i);
        Swap_Entry(A, Temp2, i);
        Swap_Entry(A, Temp2, i);
        Increment(i);
        Confirm (((#A = A) and (Lower_Bound <= i)) and ((1 + (Upper_Bound + -(i))) <= P_Val'));
    Else
        VC_Confirm
             |- (A = #A), (i = Upper_Bound)

    end;


VC(s):

_____________________

Applied If-Part Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Swap_Entry(A, Temp2, i);
    Increment(i);
    Confirm (((#A = A) and (Lower_Bound <= i)) and ((1 + (Upper_Bound + -(i))) <= P_Val'));

VC(s):

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Swap_Entry(A, Temp2, i);
    Increment(i);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= i)

     |- ((1 + (Upper_Bound + -(i))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- (((#A = A) and (Lower_Bound <= i)) and ((1 + (Upper_Bound + -(i))) <= P_Val'))" shape="box" ];
      2 [ label=" |- ((#A = A) and (Lower_Bound <= i))" shape="box" ];
      3 [ label=" |- ((1 + (Upper_Bound + -(i))) <= P_Val')" shape="box" color="red" ];
      4 [ label=" |- (#A = A)" shape="box" color="red" ];
      5 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
      2 -> 4;
      2 -> 5;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Swap_Entry(A, Temp2, i);
    Confirm ((1 + i) <= max_int);
    Assume (i' = (1 + i));

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= i')

     |- ((1 + (Upper_Bound + -(i'))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Swap_Entry(A, Temp2, i);
    Confirm ((1 + i) <= max_int);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= (1 + i))

     |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Swap_Entry(A, Temp2, i);

VC(s):
     |- ((1 + i) <= max_int)

     |- (#A = A)

     |- (Lower_Bound <= (1 + i))

     |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp2' = A(i)) and (A' = lambda (j : Z).(
        Temp2    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- ((1 + i) <= max_int)

     |- (#A = A')

     |- (Lower_Bound <= (1 + i))

     |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp2' = A(i)), (A' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2' = A(i)) |- (#A = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise))

    (Temp2' = A(i)), (A' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2' = A(i)), (A' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp2' = A(i)) and (A' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp2' = A(i)), (A' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp2, i);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2' = A(i)), (A' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2' = A(i)) |- (#A = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise))

    (Temp2' = A(i)), (A' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2' = A(i)), (A' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp2'' = A(i)) and (A'' = lambda (j : Z).(
        Temp2    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
Temp2''if ([Universal] j = i)
A''([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2' = A''(i)) |- (#A = lambda (j : Z).(
Temp2''if ([Universal] j = i)
A''([Universal] j)otherwise))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
Temp2''if ([Universal] j = i)
A''([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
Temp2''if ([Universal] j = i)
A''([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp2'' = A(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''([Universal] j)otherwise))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp2'' = A(i)) and (A'' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp2'' = A(i)), (A'' = lambda (j : Z).(
    Temp2if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Swap_Entry(A, Temp1, i);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2'' = A(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''([Universal] j)otherwise))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp1' = A(i)) and (A''' = lambda (j : Z).(
        Temp1    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp1' = A(i)) and (A''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp1' = A(i)), (A''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Swap_Entry(A, Temp1, i);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A(i)), (A''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Call Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));
    Assume ((Temp1'' = A(i)) and (A'''' = lambda (j : Z).(
        Temp1    if ([Universal] j = i)
        A([Universal] j)    otherwise)));

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
Temp1''if ([Universal] j = i)
A''''([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);
    Confirm ((Lower_Bound <= i) and (i <= Upper_Bound));

VC(s):
    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label="((Temp1'' = A(i)) and (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise))) |- " shape="box" ];
      2 [ label="(Temp1'' = A(i)), (A'''' = lambda (j : Z).(
    Temp1if ([Universal] j = i)
    A([Universal] j)otherwise)) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate ((1 + i) <= Upper_Bound);

VC(s):
     |- (Lower_Bound <= i)

     |- (i <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + i) <= max_int)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (#A = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- (Lower_Bound <= (1 + i))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((Lower_Bound <= i) and (i <= Upper_Bound))" shape="box" ];
      2 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      3 [ label=" |- (i <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Stipulate Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));

VC(s):
    ((1 + i) <= Upper_Bound) |- (Lower_Bound <= i)

    ((1 + i) <= Upper_Bound) |- (i <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (Lower_Bound <= i)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (i <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (Lower_Bound <= i)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- ((1 + i) <= max_int)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (#A = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- (Lower_Bound <= (1 + i))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound) |- ((1 + (Upper_Bound + -((1 + i)))) <= P_Val')

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;

VC(s):
    ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i)

    ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i)

    (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= i)

    (Temp2'' = A'''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (i <= Upper_Bound)

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- ((1 + i) <= max_int)

    (Temp2' = A''(i)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (#A = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- (Lower_Bound <= (1 + i))

    (Temp2' = A''(i)), (A' = lambda (j : Z).(
A'''(i)if ([Universal] j = i)
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2if ([Universal] j = i)
A'''([Universal] j)otherwise)), (Temp1' = A''''(i)), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i)
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1if ([Universal] j = i)
#A([Universal] j)otherwise)), ((1 + i) <= Upper_Bound), (Lower_Bound <= i) |- ((1 + (Upper_Bound + -((1 + i)))) <= (Upper_Bound + -(i)))

Reduction Tree(s):
    strict digraph G {
      1 [ label="(((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i)))) |- " shape="box" ];
      2 [ label="(#A = A), (Lower_Bound <= i), (P_Val' = (Upper_Bound + -(i))) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Change Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    A''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));

VC(s):
    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + i'') <= max_int)

    (Temp2' = A''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (#A = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= (1 + i''))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    A''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= i)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + i'') <= max_int)

    (Temp2' = A''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (#A = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= (1 + i''))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((#A = A) and (Lower_Bound <= i))" shape="box" ];
      2 [ label=" |- (#A = A)" shape="box" color="red" ];
      3 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    A''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + i'') <= max_int)

    (Temp2' = A''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (#A = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= (1 + i''))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Variable Declaration/Initialization Rule (Known Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    A''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    Assume (i = 0);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + i'') <= max_int)

    (Temp2' = A''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (#A = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= (1 + i''))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    A''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2' = A''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (#A = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Variable Declaration/Initialization Rule (Generic Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    A''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    Assume Entry.Is_Initial(Temp2);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2' = A''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (#A = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    A''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2' = A''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (#A = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Variable Declaration/Initialization Rule (Generic Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    A''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    Assume Entry.Is_Initial(Temp1);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2' = A''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (#A = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    A''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'' = #A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2' = A''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (#A = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
#A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
#A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Remember Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    A''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));

VC(s):
     |- (A = A)

     |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i'') |- (i'' <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= i'')

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (i'' <= Upper_Bound)

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + i'') <= max_int)

    (Temp2' = A''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (A = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- (Lower_Bound <= (1 + i''))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    i' : Z
    A' : (Z -> 'Entry')
    Temp2' : 'Entry'
    A'' : (Z -> 'Entry')
    Temp2'' : 'Entry'
    A''' : (Z -> 'Entry')
    Temp1' : 'Entry'
    A'''' : (Z -> 'Entry')
    Temp1'' : 'Entry'
    A''''' : (Z -> 'Entry')
    i'' : Z
    Temp1''' : 'Entry'
    Temp2''' : 'Entry'

Statements:

VC(s):
     |- (A = A)

    (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= Lower_Bound)

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'')

    ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (Lower_Bound <= Upper_Bound) |- (i'' <= Upper_Bound)

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'')

    (Temp1'' = A(i)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (i'' <= Upper_Bound)

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'')

    (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (i'' <= Upper_Bound)

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= i'')

    (Temp2'' = A'''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (i'' <= Upper_Bound)

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound), (1 <= max_int) |- ((1 + i'') <= max_int)

    (Temp2' = A''(i'')), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (A = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= (1 + i''))

    (Temp2' = A''(i'')), (A' = lambda (j : Z).(
A'''(i'')if ([Universal] j = i'')
A''([Universal] j)otherwise)), (A'' = lambda (j : Z).(
Temp2'''if ([Universal] j = i'')
A'''([Universal] j)otherwise)), (Temp1' = A''''(i'')), (A''' = lambda (j : Z).(
A(i)if ([Universal] j = i'')
A''''([Universal] j)otherwise)), (A'''' = lambda (j : Z).(
Temp1'''if ([Universal] j = i'')
A([Universal] j)otherwise)), ((1 + i'') <= Upper_Bound), (Lower_Bound <= i''), (i = 0), (Lower_Bound <= Upper_Bound) |- ((1 + (Upper_Bound + -((1 + i'')))) <= (Upper_Bound + -(i'')))

Reduction Tree(s):
    strict digraph G {
      1 [ label="((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) |- " shape="box" ];
      2 [ label="(Lower_Bound <= Upper_Bound), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

========================= Do_Nothing =========================

---------------------
Branching Conditions
---------------------
1. Expression at Do_Nothing_Realiz.rb(9:8) is false. [Exp: not(((1 + i) <= Upper_Bound))]
2. Expression at Do_Nothing_Realiz.rb(20:5) is false. [Exp: not((i = Upper_Bound))]
---------------------

Applied Else-Part Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate not(((1 + i) <= Upper_Bound));
    VC_Confirm
         |- (A = #A), (i = Upper_Bound)


VC(s):

_____________________

Applied VCConfirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));
    Stipulate not(((1 + i) <= Upper_Bound));

VC(s):
     |- (A = #A), (i = Upper_Bound)

_____________________

Applied Stipulate Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;
    Assume (((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i))));

VC(s):
     |- (A = #A), (i = Upper_Bound), ((1 + i) <= Upper_Bound)

Reduction Tree(s):
    strict digraph G {
      1 [ label="not(((1 + i) <= Upper_Bound)) |- (A = #A), (i = Upper_Bound)" shape="box" ];
      2 [ label=" |- (A = #A), (i = Upper_Bound), ((1 + i) <= Upper_Bound)" shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));
    Change A, i, Temp1, Temp2;

VC(s):
    (Lower_Bound <= i) |- (#A = #A), (i = Upper_Bound), ((1 + i) <= Upper_Bound)

Reduction Tree(s):
    strict digraph G {
      1 [ label="(((#A = A) and (Lower_Bound <= i)) and (P_Val' = (Upper_Bound + -(i)))) |- " shape="box" ];
      2 [ label="(#A = A), (Lower_Bound <= i), (P_Val' = (Upper_Bound + -(i))) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

Applied Change Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    A' : (Z -> 'Entry')
    i' : Z
    Temp1' : 'Entry'
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);
    Confirm ((#A = A) and (Lower_Bound <= i));

VC(s):
    (Lower_Bound <= i') |- (#A = #A), (i' = Upper_Bound), ((1 + i') <= Upper_Bound)

_____________________

Applied Confirm Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    A' : (Z -> 'Entry')
    i' : Z
    Temp1' : 'Entry'
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);
    i := Replica(Lower_Bound);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= i)

    (Lower_Bound <= i') |- (#A = #A), (i' = Upper_Bound), ((1 + i') <= Upper_Bound)

Reduction Tree(s):
    strict digraph G {
      1 [ label=" |- ((#A = A) and (Lower_Bound <= i))" shape="box" ];
      2 [ label=" |- (#A = A)" shape="box" color="red" ];
      3 [ label=" |- (Lower_Bound <= i)" shape="box" color="red" ];
      1 -> 2;
      1 -> 3;
    }

_____________________

Applied Function Assignment Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    A' : (Z -> 'Entry')
    i' : Z
    Temp1' : 'Entry'
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    _Initialize(i : Integer);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (Lower_Bound <= i') |- (#A = #A), (i' = Upper_Bound), ((1 + i') <= Upper_Bound)

_____________________

Applied Variable Declaration/Initialization Rule (Known Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    A' : (Z -> 'Entry')
    i' : Z
    Temp1' : 'Entry'
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);
    Assume (i = 0);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (Lower_Bound <= i') |- (#A = #A), (i' = Upper_Bound), ((1 + i') <= Upper_Bound)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    A' : (Z -> 'Entry')
    i' : Z
    Temp1' : 'Entry'
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    _Initialize(Temp2 : Entry);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (Lower_Bound <= i') |- (#A = #A), (i' = Upper_Bound), ((1 + i') <= Upper_Bound)

_____________________

Applied Variable Declaration/Initialization Rule (Generic Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    A' : (Z -> 'Entry')
    i' : Z
    Temp1' : 'Entry'
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);
    Assume Entry.Is_Initial(Temp2);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (Lower_Bound <= i') |- (#A = #A), (i' = Upper_Bound), ((1 + i') <= Upper_Bound)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    A' : (Z -> 'Entry')
    i' : Z
    Temp1' : 'Entry'
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    _Initialize(Temp1 : Entry);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (Lower_Bound <= i') |- (#A = #A), (i' = Upper_Bound), ((1 + i') <= Upper_Bound)

_____________________

Applied Variable Declaration/Initialization Rule (Generic Program Type): 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    A' : (Z -> 'Entry')
    i' : Z
    Temp1' : 'Entry'
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;
    Assume Entry.Is_Initial(Temp1);

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (Lower_Bound <= i') |- (#A = #A), (i' = Upper_Bound), ((1 + i') <= Upper_Bound)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    A' : (Z -> 'Entry')
    i' : Z
    Temp1' : 'Entry'
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));
    Remember;

VC(s):
     |- (#A = A)

     |- (Lower_Bound <= Lower_Bound)

    (Lower_Bound <= i') |- (#A = #A), (i' = Upper_Bound), ((1 + i') <= Upper_Bound)

_____________________

Applied Remember Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    A' : (Z -> 'Entry')
    i' : Z
    Temp1' : 'Entry'
    Temp2' : 'Entry'

Statements:
    Assume ((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len));

VC(s):
     |- (A = A)

     |- (Lower_Bound <= Lower_Bound)

    (Lower_Bound <= i') |- (A = A), (i' = Upper_Bound), ((1 + i') <= Upper_Bound)

_____________________

Applied Assume Rule: 

Free Variables:
    Temp1 : 'Entry'
    Temp2 : 'Entry'
    i : Z
    P_Val' : N
    A' : (Z -> 'Entry')
    i' : Z
    Temp1' : 'Entry'
    Temp2' : 'Entry'

Statements:

VC(s):
     |- (A = A)

    (Lower_Bound <= Upper_Bound) |- (Lower_Bound <= Lower_Bound)

    (Lower_Bound <= i'), (Lower_Bound <= Upper_Bound) |- (A = A), (i' = Upper_Bound), ((1 + i') <= Upper_Bound)

Reduction Tree(s):
    strict digraph G {
      1 [ label="((((Lower_Bound <= Upper_Bound) and ((min_int <= 0) and (1 <= max_int))) and (1 <= Last_Char_Num)) and (1 <= Max_Char_Str_Len)) |- " shape="box" ];
      2 [ label="(Lower_Bound <= Upper_Bound), (min_int <= 0), (1 <= max_int), (1 <= Last_Char_Num), (1 <= Max_Char_Str_Len) |- " shape="box" color="red" ];
      1 -> 2;
    }

_____________________

